---
engine: julia
lang: es-MX

---
# Julia como lenguaje de programaci√≥n para un curso de algoritmos {#sec-julia}

Nuestro objetivo trabajar sobre algoritmos, por lo que cualquier lenguaje que pueda expresar todo lo computable, puede ser adecuado. Pero dado que nuestro enfoque ser√° experimental, y nuestra metodolog√≠a incluye medir la factibilidad y desempe√±o de cada algoritmo en t√©rminos reales, entonces necesitamos un lenguaje donde las instrucciones, los acceso a memoria, y la manipulaci√≥n de la misma sea controlable. En este caso, y mediando con la f√°cilidad de aprendizaje y la productividad, este curso utiliza el lenguaje de programaci√≥n Julia.[^julia] Pero no hay porque preocuparse por aprender un nuevo lenguaje, el curso utiliza ejemplos en Julia y utiliza una variante de su sintaxis como pseudo-c√≥digo, pero las actividades se esperan tanto en Julia como en Python.

[^julia]: Se recomienda utilizar la versi√≥n 1.10 o superior, y puede obtenerse en <https://julialang.org/>.

Ambos lenguajes de programaci√≥n son f√°ciles de aprender y altamente productivos. Python es un lenguaje excelente para realizar prototipos, o para cuando existen bibliotecas que resuelvan el problema que se este enfrentando. Por otro lado, cuando se necesita control sobre las operaciones que se estan ejecutando, o la memoria que se aloja, Python no es un lenguaje que nos permita trabajar en ese sentido. Julia esta dise√±ado para ser veloz y a la vez mantener el din√°mismo que se espera de un lenguaje moderno, adicionalmente, es posible conocer los tipos de instrucciones que realmente se ejecutan, as√≠ como tambi√©n es posible controlar la alojaci√≥n de memoria, ya se mediante la utilizaci√≥n de patrones que as√≠ nos lo permitan, o mediante instrucciones que nos lo aseguren.

Este curso esta escrito en Quarto, y se esperan reportes de de tareas y actividades tanto en Quarto <https://quarto.org> como en Jupyter <https://jupyter.org/>. La mayor√≠a de los ejemplos estar√°n empotrados en el sitio, y en principio, deber√≠an poder replicarse copiando, pegando, y ejecutando en una terminal de Julia.

Es importante clarificar que este cap√≠tulo introducir√° el lenguaje de programaci√≥n Julia hasta el nivel que se requiere en este curso, ignorando una gran cantidad de capacidades que no son de inter√©s para nuestro curso. Se recomienda al alumno interesado la revisi√≥n del manual y la documentaci√≥n oficial para un estudio m√°s profundo del lenguaje. 

## El lenguaje de programaci√≥n Julia
Julia es un lenguaje singular, es un lenguaje din√°mico y de alto nivel, tiene de tipado fuerte y compila a c√≥digo m√°quina para cada una de las instrucciones que se dan. Su interfaz m√°s com√∫n es un REPL o \textit{read, eval, print, loop}, esto es que puede ser utilizado de manera interactiva, adem√°s de la ejecuci√≥n en scripts o notebooks como los que estaremos usando para reportar.

Es homoic√≥nico, que significa que la manera en que se representan sus programas coincide con las estructuras de datos b√°sicas, lo cual permite crear programas validos mediante programas. De manera pr√°ctica, tambi√©n le permite la reescritura de los programas utilizando otro programa utilizando _macros_, los cuales son funciones que modifican el c√≥digo y empiezan con el simbolo `@`. Estaremos viendo una serie de macros con prop√≥sitos muy espec√≠ficos, crear macros y la manipulaci√≥n autom√°tica de c√≥digo cae fuera de nuestro curso. 

El lenguaje tiene estructuras de datos b√°sicas como rangos, vistas, tuplas, arreglos, estructuras, diccionarios, conjuntos, cadenas de caracteres, as√≠ como expresiones de c√≥digo como datos y controla la ejecuci√≥n mediante condicionales, ciclos y funciones. Tiene un sistema de tipos de datos muy poderoso, que le permite entre otras cosas generar c√≥digo espec√≠fico para dichos tipos. El c√≥digo se organiza en scripts, y a nivel l√≥gico en m√≥dulos y paquetes. Una de sus caracter√≠sticas importantes el _despacho m√∫ltiple_ en las funciones, esto es, que para cada conjunto de tipos de argumentos, compilar√° una funci√≥n especializada. Este patr√≥n puede ser muy poderoso para escribir c√≥digo gen√©rico que pueda ser muy eficiente, a costa de m√∫ltiples c√≥digos de m√°quina para una funci√≥n. Esta estrateg√≠a tambi√©n viene con el problema que la primera vez que se ejecuta una funci√≥n con un conjunto espec√≠fico de tipos de argumentos, dicha funci√≥n ser√° especializada y compilada, lo cual puede representar un costo inicial importante en algunos casos donde no se pretenda procesar grandes cantidades de informaci√≥n. En particular, este problema se ha venido reduciendo en las versiones m√°s nuevas de Julia haciendo uso una estrateg√≠a de precompilaci√≥n para datos t√≠picos.

Entre los tipos de datos es capaz de manera enteros y n√∫meros de punto flotante de diferentes precisiones, caracteres, cadenas de caracteres, y simbolos. Los arreglos son realmente importantes en Julia, y soportan de manera nativa vectores, matrices y tensores, estaremos tocando apenas esta parte del lenguaje. El resto de esta unidad esta dedicada a precisar la sintaxis del lenguaje y anotaciones de importancia sobre su funcionamiento, y en particular, en el manejo que nos permitir√° generar c√≥digo eficiente que limite el alojamiento de memoria.

### Funciones
Las funciones son centrales en Julia, y son definidas mediante la sintaxis 
```{{julia}}
function fun(arg1, arg2...) # <1>
    # ... expresiones ...
end

function fun(arg1, arg2...; kwarg1=valor1, kwargs2...) # <2>
    # ... expresiones ...
end

fun(arg1, arg2...; kwarg1=valor1, kwargs2...) = expresion  # <3>

(arg1, arg2...; kwarg1=valor1, kwargs2...) -> expresion       # <4>

fun() do x # <5>
    x^2 # ... expresiones ...
end
```
1. Definici√≥n de una funci√≥n simple, los tipos de los argumentos se utilizan para generar m√∫ltiples versiones de una funci√≥n.
2. Tambi√©n se soportan argumentos nombrados, los cuales van despu√©s de `;`, se debe tener en cuenta que los tipos de los argumentos nombrados no son utilizados para determinar si una funci√≥n debe compilarse. Los argumentos nombrados pueden o no tener valores por omisi√≥n.
3. Si la funci√≥n tiene una estructura simple, de una expresi√≥n, es posible ignorar `function` y `end`, usando '=' para definirla.
4. Muchas veces es √∫til definir funciones an√≥nimas, que suelen pasarse a otras funciones de orden superior.
5. Un embellecedor √∫til para generar una funci√≥n an√≥nima (definida entre `do...end`) que se pasa como primer argumento a `fun`, e.g., es equivalente a `fun(x->x^2).`

El _√°mbito_ o _scope_ de las variables en Julia es sint√°ctico, que significa que se hereda del c√≥digo donde las funciones fueron definidas, y no din√°mico (que se hereda desde d√≥nde se ejecuta la funci√≥n). Aunque es el comportamiento de la mayor√≠a de los lenguajes modernos, es importante conocerlo sobre todo para la creaci√≥n de _cerraduras sint√°cticas_ en funciones.

Una funci√≥n se ejecuta con la sintaxis `nombre(arg1...)`. Conviene profundizar en las expresiones y dem√°s componentes del lenguaje antes del ir a m√°s ejemplos sobre funciones.

### Hola mundo
Uno de los programas m√°s comunes es el siguiente
```{julia}
println("¬°Hola üåé!")
```

### Expresiones y operadores
Las expresiones son la forma m√°s gen√©rica de expresar el c√≥digo en Julia, comprenden operaciones aritm√©ticas, asignaci√≥n y declaraci√≥n de variables, definiciones de bloques de c√≥digo, llamadas de funciones, entre otras.

Cada linea suele ser una expresi√≥n, a menos que se extienda por m√∫ltiples lineas por medio de un agrupador de c√≥digo o datos, estos pueden ser `begin...end`, `let...end`, `(...)`, `[...]`, `[...]`, `for...end`, `while...end`, `if...end`, `function...end`, `try...end`, entre las m√°s utilizadas.

Las definiciones de variables tienen la sintaxis `variable = valor`; las variables comunmente comienzan con una letra o `_`, las letras pueden ser caracteres _unicode_, no deben contener espacios ni puntuaciones como parte del nombre; `valor` es el resultado de evaluar o ejecutar una expresi√≥n.

Los operadores m√°s comunes son los aritm√©ticos `+`, `-`, `*`, `/`, `√∑`, `%`, `\`, `^`,  con precedencia y significado t√≠pico. Existen maneras compuestas de modificar una variable anteponiendo el operador aritm√©tico al simbolo de asignaci√≥n, e.g., `variable += valor`, que se expande a `variable = variable + valor`. Esto implica que `variable` debe estar previamente definida previo a la ejecuci√≥n.


Los operadores l√≥gicos tambi√©n tienen el significado esperado.

|operaci√≥n  |descripci√≥n|
|---        |---- |
| `a && b`  | AND l√≥gico                       |
| `a || b`  | OR l√≥gico                        |
| `a ‚äª b`   | XOR l√≥gico                       |
| `!a`      | negaci√≥n l√≥gica                  |
| `a < b`   | comparaci√≥n `a` es menor que `b` |
| `a > b`   | comparaci√≥n `a` es mayor que `b` |
| `a <= b`  | comparaci√≥n `a` es menor o igual que `b`     |
| `a >= b`  | comparaci√≥n `a` es mayor o igual que `b`     |
| `a == b`  | comparaci√≥n de igualdad                      |
| `a === b` | comparaci√≥n de igualdad (a nivel de tipo)    |
| `a != b`  | comparaci√≥n de desigualdad                   |
| `a !== b` | comparaci√≥n de desigualdad (a nivel de tipo) |

En particular `&&` y `||` implementan _corto circuito de c√≥digo_, por lo que pueden usarse para el control de que operaciones se ejecutan. Cuando se compara a nivel de tipo 0 (entero) ser√° diferente de 0.0 (real).

Tambi√©n hay operadores l√≥gicos a nivel de bit, los argumentos son enteros.

|operaci√≥n |descripci√≥n|
|---  |--- |
| `a & b`  | AND a nivel de bits              |
| `a | b`  | OR a nivel de bits               |
| `a ‚äª b`  | XOR a nivel del bits             |
| `~a`     | negaci√≥n l√≥gica a nivel de bits  |

### Literales
Dado que existen m√∫ltiples tipos de datos existen diferentes formas de definirlas; una de ellas, probablemente la que m√°s estaremos usando son los literales, es decir, escribir los datos directamente en el c√≥digo.

Los n√∫meros enteros se definen sin punto decimal, es posible usar `_` como separador y dar m√°s claridad al c√≥digo. Los enteros pueden tener 8, 16, 32, o 64 bits; por omisi√≥n, se empaquetan en variables del tipo `Int` (`Int64`). Los valores hexadecimales se interpretan como enteros sin signo, y adem√°s se empaquetan al n√∫mero de bits necesario minimo para contener. El comportamiento para valores en base 10 es el de hexadecimal es congruente con un lenguaje para programaci√≥n de sistemas.

```{julia}
a = 100
println((a, sizeof(a)))
b = Int8(100)
println((b, sizeof(b)))
c = 30_000_000
println((c, sizeof(c)))
d = 0xffff
println((d, sizeof(d)))
```

::: {.column-margin}
Existen n√∫meros enteros de precisi√≥n 128 pero las operaciones al d√≠a de hoy no son implementadas de manera nativa por los procesadores; as√≠ mismo se reconocen n√∫meros de punto flotante de precisi√≥n media `Float16` pero la mayor√≠a de los procesadores no tienen soporte nativo para realizar operaciones con ellos, aunque los procesadores de √∫ltima generaci√≥n si lo tienen.
:::

Si la precisi√≥n esta en duda o el contexto lo am√©rita, deber√° especificarlo usando el constructor del tipo e.g., `Int8(100)`, `UInt8(100)`, `Int16(100)`, `UInt16(100)`, `Int32(100)`, `UInt32(100)`, `Int64(100)`, `UInt64(100)`.

Los n√∫meros de punto flotante tienen diferentes formas de definirse, teniendo diferentes efectos.
Para n√∫meros de precision simple, 32 bits, se definen con el sufijo `f0` como `3f0`. El sufijo `e0` tambi√©n se puede usar para definir precisi√≥n doble (64 bit). El cero del sufijo en realidad tiene el objetivo de colocar el punto decimal, en notaci√≥n de ingenier√≠a, e.g., $0.003$ se define como $3f-3$ o $3e-3$, dependiendo del tipo de dato que se necesite. 
Si se omite sufijo y se pone solo punto decimal entonces se interpretar√° como precision doble. Los tipos son `Float32` y `Float64`.

Los datos booleanos se indican mediante `true` y `false` para verdadero y falso, respectivamente.

Los caracteres son s√≠mbolos para √≠ndicar cadenas, se suelen representar como enteros peque√±os en memoria. Se especifican con comillas simples `'a'`, `'z'`, `'!'` y soporta simbolos _unicode_ `'ü§†'`.

Las cadenas de caracteres son la manera de representar textos como datos, se guardan en zonas contiguas de memoria. Se especifican con comillas dobles y tambi√©n soportan s√≠mbolos unicode, e.g., `"hola mundo"`, `"pato es un üê∑"`.

::: {.column-margin}
Julia guarda los simbolos de manera especial y pueden ser utilizados para realizar identificaci√≥n de datos eficiente, sin embargo, no es buena idea saturar el sistema de manejo de s√≠mbolos por ejemplo para crear un vocabulario ya que no liberar√° la memoria despu√©s de definirlos ya que es un mec√°nismo dise√±ado para la representaci√≥n de los programas, pero lo suficientemente robusto y bien definido para usarse en el dise√±o e implementaci√≥n de programas de los usuarios.
:::

En Julia existe la noci√≥n de s√≠mbolo, que es una cadena que adem√°s solo existe en una posici√≥n en memoria se usa el prefijo `:` para denotarlos. 

```{julia}
println(:hola === :hola)
println(typeof(:hola))
println(Symbol("hola mundo"))
```

### Control de flujo
El control de flujo nos permite escoger que partes del c√≥digo se ejecutaran como consecuencia de la evaluaci√≥n de una expresi√≥n, esto incluye repeticiones.

Las condicionales son el control de flujo m√°s simple.
```{julia}
a = 10
if a % 2 == 0 # <1>
    "par" # <2>
else
    "impar" # <3>
end
```
1. Expresi√≥n condicional.
2. Expresi√≥n a ejecutarse si (1) es verdadero.
3. Expresi√≥n a evaluarse si (1) es falso.

Se puede ignorar la clausula `else` dando solo la opci√≥n de evaluar (2) si (1) es verdadero. Finalmente, note que la condicional es una expresi√≥n y devuelve un valor.
```{julia}
a = 10
if log10(a) == 1 # <1>
    "es 10" # <2>
end
```

Tambi√©n pueden concatenarse m√∫ltiples expresiones condicionales con `elseif` como se muestra a continuaci√≥n.
```{julia}
a = 9
if a % 2 == 0
    println("divisible entre 2")
elseif a % 3 == 0
    println("divisible entre 3")
else
    println("no divisible entre 2 y 3")
end
```

Es com√∫n utilizar la sintaxis en Julia (short circuit) para control de flujo:
```{julia}
a = 9

println(a % 2 == 0 && "es divisible entre dos")  # <1>
println(a % 3 == 0 && "es divisible entre tres") # <2>
```
1. El resultado de la condici√≥n es falso, por lo que no se ejecutar√° la siguiente expresi√≥n.
2. El resultado es verdadero, por lo que se ejecutar√° la segunda expresi√≥n.

Fnalmente, existe una condicional de tres vias `expresion ? expr-verdadero : expr-falso`

```{julia}
a = 9

println(a % 2 == 0 ? "es divisible entre dos" : "no es divisible entre dos")
println(a % 3 == 0 ? "es divisible entre tres" : "no es divisible entre tres")
```

#### Ciclos

Los ciclos son expresiones de control de flujo que nos permiten iterar sobre una colecci√≥n o repetir un c√≥digo hasta que se cumpla alguna condici√≥n. En Julia existen dos expresiones de ciclos: 

- `for x in colecci√≥n ...expresiones... end` y
- `while condici√≥n ...expresioens... end`

En el caso de `for`, la idea es iterar sobre una colecci√≥n, esta colecci√≥n puede ser un rango, i.e., `inicio:fin`, `inicio:paso:fin`, o una colecci√≥n como las tuplas, los arreglos, o cualquiera que cumpla con la interfaz de colecci√≥n iterable del lenguaje. 

```{julia}
for i in 1:5
    println("1er ciclo: ", i => i^2)
end

for i in [10, 20, 30, 40, 50]
    println("2do ciclo: ", i => i/10)
end
```

Al igual que en otros lenguajes modernos, se define la variante completa o _comprehensive for_ que se utiliza para transformar la colecci√≥n de entrada en otra colecci√≥n cuya sintaxis se ejemplifica a continuaci√≥n:

```{julia}
a = [i => i^2 for i in 1:5]
println(a)
```

Tambi√©n es posible definir un generador, esto es, un c√≥digo que puede generar los datos, pero que no los generar√° hasta que se les solicite.
```{julia}
a = (i => i^2 for i in 1:5)
println(a)
println(collect(a)) 
```

Otra forma de hacer ciclos de intrucciones es repetir mientras se cumpla una condici√≥n:
```{julia}
i = 0
while i < 5
    i += 1
    println(i)
end

i
```

### Tuplas y arreglos en Julia
Una tupla es un conjunto ordenado de datos que no se puede modificar y que se desea esten contiguos en memoria, la sintaxis en memoria es como sigue:
```{julia}
a = (2, 3, 5, 7)    # <1>
b = (10, 20.0, 30f0)   # <1>
c = 100 => 200 # <1>
println(typeof(a))  # <2>
println(typeof(b))  # <2>
println(typeof(c))  # <2>
a[1], a[end], b[3], c.first, c.second  # <3>
```

1. Define las tuplas.
2. Imprime los tipos de las tuplas.
3. Muestra como se accede a los elementos de las tuplas. Julia indexa comenzando desde 1, y el t√©rmino `end` tambi√©n se utiliza para indicar el √∫ltimo elemento en una colecci√≥n ordenada.

La misma sintaxis puede generar diferentes tipos de tuplas. En el caso `NTuple{4, Int4}` nos indica que el tipo maneja cuatro elementos de enteros de 64 bits, los argumentos entre `{}` son parametros que especifican los tipos en cuesti√≥n.  En el caso de `Tuple` se pueden tener diferentes tipos de elementos. La tupla `Pair` es especial ya que solo puede contener dos elementos y es b√°sicamente para _embellecer_ o _simplificar_ las expresiones; incluso se crea con la sintaxis `key => value` y sus elementos pueden accederse mediante dos campos nombrados.

Los _arreglos_ son datos del mismo tipo contiguos en memoria, a diferencia de las tuplas, los elementos se pueden modificar, incluso pueden crecer o reducirse. Esto puede implicar que se alojan en zonas de memoria diferente (las tuplas se colocan en el _stack_ y los arreglos en el _heap_, ver la siguiente unidad para m√°s informaci√≥n). Desde un alto nivel, los arreglos en Julia suelen estar asociados con vectores, matrices y tensores, y un arsenal de funciones relacionadas se encuentran definidas en el paquete `LinearAlgebra`, lo cual esta m√°s all√° del alcance de este curso. 

```{julia}
a = [2, 3, 5, 7]   # <1>
b = [10, 20.0, 30f0]   # <1>
println(typeof(a))  # <2>
println(typeof(b))  # <2>
a[1], a[end], b[3], b[2:3]  # <3>
```
1. Define los arreglos `a` y `b`.
2. Muestra los tipos de los arreglos, note como los tipos se promueven al tipo m√°s g√©nerico que contiene la definici√≥n de los datos.
3. El acceso es muy similar a las tuplas para arreglos unidimensionales, note que es posible acceder rangos de elementos con la sintaxis `ini:fin`.

```{julia}
a = [2 3;
     5 7]    # <1>
display(a)  # <2>
display(a[:, 1]) # <3>
display(a[1, :]) # <4>
```
1. Definici√≥n de un arreglo bidimensional, note como se ignora la coma `,` en favor de la escritura por filas separadas por `;`.
2. La variable `a` es una matriz de 2x2.
3. Es posible acceder una columna completa usando el s√≠mbolo `:` para indicar todos los elementos.
4. De igual forma, es posible acceder una fila completa.

### Diccionarios y conjuntos en Julia
Un diccionario es un arreglo asociativo, i.e., guarda pares llave-valor. Permite acceder de manera eficiciente al valor por medio de la llave, as√≠ como tambi√©n verificar si hay una entrada dentro del diccionario con una llave dada. La sintaxis es como sigue:

```{julia}
a = Dict(:a => 1, :b => 2, :c => 3) # <1>
a[:b] = 20 # <2>
println(a)
a[:d] = 4  # <3>
println(a)
delete!(a, :a) # <4>
a
```
1. Definici√≥n del diccionario `a` que mapea simbolos a enteros.
2. Cambia el valor de `:b` por 20.
3. A√±ade `:d => 4` al diccionario `a`.
4. Borra el par con llave `:a`.

Es posible utilizar diferentes tipos siempre y cuando el tipo en cuesti√≥n defina de manera correcta la funci√≥n `hash` sobre la llave y la verificaci√≥n de igualdad `==`.

Un conjunto se representa con el tipo `Set`, se implementa de manera muy similar al diccionario pero solo necesita el elemento (e.g., la llave). Como conjunto implementa las operaciones clasificaci√≥n de operaciones de conjuntos
```{julia}
a = Set([10, 20, 30, 40]) # <1>
println(20 in a)          # <2>
push!(a, 50)              # <3>
println(a)
delete!(a, 10)            # <4>
println(a)
println(intersect(a, [20, 35])) # <5>
union!(a, [100, 200]) # <6>
println(a)
```
1. Definici√≥n del conjunto de n√∫meros enteros.
2. Verificaci√≥n de membresia al conjunto `a`.
3. A√±ade 50 al conjunto.
4. Se borra el elemento 10 del conjunto.
5. Intersecci√≥n de `a` con una colecci√≥n, no se modifica el conjunto `a`.
6. Uni√≥n con otra colecci√≥n, se modifica `a`.

## El flujo de compilaci√≥n de Julia

Basta con escribir una linea de c√≥digo en el REPL de Julia y esta se compilar√° y ejecutar√° en el contexto actual, usando el √°mbito de variables. Esto es conveniente para comenzar a trabajar, sin embargo, es importante conocer el flujo de compilaci√≥n para tenerlo en cuenta mientras se c√≥difica, y as√≠ generar c√≥digo eficiente. En particular, la creaci√≥n de funciones y evitar la _inestabilidad_  de los tipos de las variables es un paso hacia la generaci√≥n de c√≥digo eficiente. Tambi√©n es importante evitar el alojamiento de memoria din√°mica siempre que sea posible. A continuaci√≥n se mostrar√° el an√°lisis de un c√≥digo simple a diferentes niveles, mostrando que el lenguaje nos permite observar la generaci√≥n de c√≥digo, que √∫ltimadamente nos da cierto control y nos permite verificar que lo que se esta implementando es lo que se espec√≠fica en el c√≥digo. Esto no es posible en lenguajes como Python.


```{julia}
#| code-line-numbers: true
let
    e = 1.1
    println(e*e)
    @code_typed e*e
end
```

En este c√≥digo, se utiliza la estructa de agrupaci√≥n de expresiones `let...end`. Cada expresi√≥n puede estar compuesta de otras expresiones, y casi todo es una expresi√≥n en Julia. La mayoria de las expresiones ser√°n finalizadas por un salto de linea, pero las compuestas como `let`, `begin`, `function`, `if`, `while`, `for`, `do`, `module` estar√°n finalizadas con `end`. La indentaci√≥n no importa la indentaci√≥n como en Python, pero es aconsejable para mantener la legibilidad del c√≥digo. La linea 2 define e inicializa la variable `e`; la linea 3 llama a la funci√≥n `println`, que imprimir√° el resultado de `e*e` en la consola. La funci√≥n `println` esta dentro de la biblioteca est√°ndar de Julia y siempre esta _visible_. La linea 4 es un tanto diferente, es una macro que toma la expresi√≥n `e*e` y realiza algo sobre la expresi√≥n misma, en particular `@code_type` muestra como se reescribe la expresi√≥n para ser ejecutada. Note como se har√° una llamada a la funci√≥n `Base.mul_float` que recibe dos argumentos y que regresar√° un valor `Float64`. Esta informaci√≥n es necesaria para que Julia pueda generar un c√≥digo veloz, el flujo de compilaci√≥n llevar√≠a esta informaci√≥n a generar un c√≥digo intermedio de _Low Level Virtual Machine_ (LLVM), que es el compilador empotrado en Julia, el cual estar√≠a generando el siguiente c√≥digo LLVM (usando la macro `@code_llvm`):

```{julia}
#| echo: false
let
    e = 1.1
    @code_llvm e*e
end
```

Este c√≥digo ya no es espec√≠fico para Julia, sino para la maquinar√≠a LLVM. Observe la especificidad de los tipos y lo corto del c√≥digo. El flujo de compilaci√≥n requerir√≠a generar el c√≥digo nativo, que puede ser observado a continuaci√≥n mediante la macro `@code_native`:

```{julia}
#| echo: false
let
    e = 1.1
    @code_native e*e
end
```

En este caso podemos observar c√≥digo espec√≠fico para la computadora que esta generando este documento, es posible ver el manejo de registros y el uso de instrucciones del CPU en cuesti√≥n.

Este c√≥digo puede ser eficiente dado que los tipos y las operaciones son conocidos, en el caso que esto no puede ser, la eficiencia esta perdida. Datos no nativos o la imposibilidad de determinar un tipo causar√≠an que se generar√° m√°s c√≥digo nativo que terminar√≠a necesitanto m√°s recursos del procesador. Una situaci√≥n similar ocurre cuando se aloja memoria de manera din√°mica. Siempre estaremos buscando que nuestro c√≥digo pueda determinar el tipo de datos para que el c√≥digo generado sea simple, si es posible usar datos nativos, adem√°s de no manejar o reducir el uso de memor√≠a din√°mica.

## Ejemplos de funciones
Las funciones ser√°n una parte central de nuestros ejemplos, por lo que vale la pena retomarlas y dar ejemplos.



## Recursos para aprender Python y Julia

### Python
- Python, se recomieda utilizar la distribuci√≥n de <https://www.anaconda.com/download/>
- Documentaci√≥n oficial, comenzar por el tutorial <https://docs.python.org/3/>
- Documentaci√≥n oficial <https://docs.julialang.org/en/stable/>


### Julia
- Informaci√≥n sobre como instalar Julia y flujos de trabajo simples (e.g., REPL, editores, etc.) para trabajar con este lenguaje de programaci√≥n: _Modern Julia Workflows_ <https://modernjuliaworkflows.github.io/>.
- Libro sobre julia _Think Julia: How to Think Like a Computer Scientist_ <https://benlauwens.github.io/ThinkJulia.jl/latest/book.html>.
- Curso _Introduction to computational thinking_ <https://computationalthinking.mit.edu/Fall20/>


## Licencia

[![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)

Esta obra est√° bajo una [Licencia Creative Commons Atribuci√≥n-CompartirIgual 4.0 Internacional](http://creativecommons.org/licenses/by-sa/4.0/)
