<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es-MX" xml:lang="es-MX"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>6&nbsp; Algoritmos de intersección y unión de conjuntos en el modelo de comparación – Curso Introductorio al Análisis de Algoritmos con Julia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./refs.html" rel="next">
<link href="./cap5-busqueda.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-a185852c63625fd9ffbdc57047c9a77e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ad99e6f6c147e79e52b73ec7b2aeb1d7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./cap6-intersecciones.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Algoritmos de intersección y unión de conjuntos en el modelo de comparación</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Algoritmos de intersección y unión de conjuntos en el modelo de comparación</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Código</button></div></div>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Curso Introductorio al Análisis de Algoritmos con Julia</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/sadit/ALGO-IR" title="Ejecutar el código" class="quarto-navigation-tool px-1" aria-label="Ejecutar el código"><i class="bi bi-github"></i></a>
    <a href="./Curso-Introductorio-al-Análisis-de-Algoritmos-con-Julia.pdf" title="Descargar PDF" class="quarto-navigation-tool px-1" aria-label="Descargar PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefacio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap1-julia.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Julia como lenguaje de programación para un curso de algoritmos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap2-analisis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introducción al análisis de algoritmos con Julia</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap3-estructuras.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Estructuras de datos elementales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap4-ordenamiento.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Algoritmos de ordenamiento</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap5-busqueda.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Algoritmos de búsqueda en el modelo de comparación</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap6-intersecciones.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Algoritmos de intersección y unión de conjuntos en el modelo de comparación</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./refs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#objetivo" id="toc-objetivo" class="nav-link active" data-scroll-target="#objetivo">Objetivo</a></li>
  <li><a href="#problema" id="toc-problema" class="nav-link" data-scroll-target="#problema"><span class="header-section-number">6.1</span> Problema</a>
  <ul class="collapse">
  <li><a href="#costo-del-problema" id="toc-costo-del-problema" class="nav-link" data-scroll-target="#costo-del-problema"><span class="header-section-number">6.1.1</span> Costo del problema</a></li>
  </ul></li>
  <li><a href="#algoritmos" id="toc-algoritmos" class="nav-link" data-scroll-target="#algoritmos"><span class="header-section-number">6.2</span> Algoritmos</a>
  <ul class="collapse">
  <li><a href="#ejercicio" id="toc-ejercicio" class="nav-link" data-scroll-target="#ejercicio"><span class="header-section-number">6.2.1</span> Ejercicio</a></li>
  </ul></li>
  <li><a href="#algoritmos-para-arreglos-de-tamaño-muy-diferente" id="toc-algoritmos-para-arreglos-de-tamaño-muy-diferente" class="nav-link" data-scroll-target="#algoritmos-para-arreglos-de-tamaño-muy-diferente"><span class="header-section-number">6.3</span> Algoritmos para arreglos de tamaño muy diferente</a>
  <ul class="collapse">
  <li><a href="#algoritmo-de-baeza-yates" id="toc-algoritmo-de-baeza-yates" class="nav-link" data-scroll-target="#algoritmo-de-baeza-yates"><span class="header-section-number">6.3.1</span> Algoritmo de Baeza Yates</a></li>
  <li><a href="#ejercicios" id="toc-ejercicios" class="nav-link" data-scroll-target="#ejercicios"><span class="header-section-number">6.3.2</span> Ejercicios</a></li>
  </ul></li>
  <li><a href="#operaciones-con-tres-o-más-conjuntos" id="toc-operaciones-con-tres-o-más-conjuntos" class="nav-link" data-scroll-target="#operaciones-con-tres-o-más-conjuntos"><span class="header-section-number">6.4</span> Operaciones con tres o más conjuntos</a>
  <ul class="collapse">
  <li><a href="#algoritmo-svs" id="toc-algoritmo-svs" class="nav-link" data-scroll-target="#algoritmo-svs"><span class="header-section-number">6.4.1</span> Algoritmo SvS</a></li>
  <li><a href="#algoritmo-de-barbay-y-kenyon" id="toc-algoritmo-de-barbay-y-kenyon" class="nav-link" data-scroll-target="#algoritmo-de-barbay-y-kenyon"><span class="header-section-number">6.4.2</span> Algoritmo de Barbay y Kenyon</a></li>
  </ul></li>
  <li><a href="#recursos-audio-visuales-de-la-unidad" id="toc-recursos-audio-visuales-de-la-unidad" class="nav-link" data-scroll-target="#recursos-audio-visuales-de-la-unidad"><span class="header-section-number">6.5</span> Recursos audio-visuales de la unidad</a></li>
  <li><a href="#actividades" id="toc-actividades" class="nav-link" data-scroll-target="#actividades"><span class="header-section-number">6.6</span> Actividades</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<section id="objetivo" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="objetivo">Objetivo</h2>
<p>Analizar el rendimiento de algoritmos de unión e intersección de conjuntos representados como listas ordenadas parametrizando los algoritmos con los algoritmos internos de búsqueda, tamaño de los conjuntos y la distribución de los elementos, bajo un enfoque experimental midiendo los costos en términos del tiempo de ejecución y el uso de memoria.</p>
</section>
<section id="problema" class="level2 page-columns page-full" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="problema"><span class="header-section-number">6.1</span> Problema</h2>
<p>Cómo se vió en Capítulos anteriores, un conjunto es una colección de elementos donde no hay repetición. El uso de conjuntos es fundamental para un gran número de problemas. En particular, en este capítulo representaremos conjuntos como arreglos ordenados de números enteros; esto para posicionarlo dentro de un dominio de aplicación objetivo, que es la Recuperación de Información, como parte de la representación de una la matriz dispersa muy grande, llamada <em>índice invertido</em>.</p>
<p>Estaremos resolviendo los problemas de intersección y unión de conjuntos. <span class="citation" data-cites="DLOM2000">Demaine, López-Ortiz, y Munro (<a href="refs.html#ref-DLOM2000" role="doc-biblioref">2000</a>)</span> demuestra que el costo y procedimiento de las intersecciones y uniones de conjuntos representados como arreglos ordenados, es básicamente el mismo; ya que requieren determinar la misma información. Claramente, colectar los datos para la unión y la intersección, requieren diferentes esfuerzos.</p>
<section id="costo-del-problema" class="level3 page-columns page-full" data-number="6.1.1">
<h3 data-number="6.1.1" class="anchored" data-anchor-id="costo-del-problema"><span class="header-section-number">6.1.1</span> Costo del problema</h3>
<p>En general, dados dos conjuntos <span class="math inline">\(A[1..m] = \{a_1 &lt; a_2 &lt; \cdots &lt; a_m \}\)</span> y <span class="math inline">\(B[1..n] = \{b_1 &lt; b_2 &lt; \cdots &lt; b_n \}\)</span>, el costo de unión es <span class="math display">\[\log{m+n \choose m},\]</span> ver <span class="citation" data-cites="hwang1971optimal">Hwang y Lin (<a href="refs.html#ref-hwang1971optimal" role="doc-biblioref">1971</a>)</span>.</p>
<p>De manera más detallada, supongamos que <span class="math inline">\(A \cap B = \emptyset\)</span>, esto es, el conjunto de salida será de tamaño <span class="math inline">\(m+n\)</span>. De manera similar al razonamiento que se utilizó para el problema de ordenamiento, el problema puede verse como todas las posibles instancias de ordenes o permutaciones de tamaño <span class="math inline">\(n+m\)</span>; removiendo la necesidad de los ordenes parciales, esto es <span class="math inline">\({n+m \choose m}\)</span> posibles instancias de tamaño <span class="math inline">\(n+m\)</span>, generadas por dos conjuntos de tamaño <span class="math inline">\(n\)</span> y <span class="math inline">\(m\)</span>. Dado que estamos en un modelo basado en comparaciones, y dado el mejor algoritmo <span class="math inline">\(s\)</span> puede dividir el espacio de posibles ordenes en 2, por tanto, dicho algoritmo necesitará <span class="math display">\[\log_2 {n+m \choose m}\]</span> comparaciones para resolver la unión de cualquier par de conjuntos de tamaño <span class="math inline">\(m\)</span> y <span class="math inline">\(n\)</span>.</p>
<p>Usando la aproximación de Stirling para coefficientes binomiales de <span class="citation" data-cites="mackay2003information">MacKay (<a href="refs.html#ref-mackay2003information" role="doc-biblioref">2003</a>)</span>, el costo se convierte en: <span class="math display">\[\log{m+n \choose m} = n\log{\frac{m+n}{n}} + m \log\frac{n+m}{m} \]</span></p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Recuerde que <span class="math inline">\(\log_2 x = \frac{\log_e x}{\log e}\)</span>.</p>
</div></div></section>
</section>
<section id="algoritmos" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="algoritmos"><span class="header-section-number">6.2</span> Algoritmos</h2>
<p>Se puede observar que si <span class="math inline">\(m \approx n\)</span>, entonces el costo se convierte en <span class="math inline">\(O(m + n)\)</span>, esto es, lo más eficiente sería tomar el siguiente algoritmo:</p>
<div id="4" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="annotated-cell-1"><pre class="sourceCode julia code-annotation-code code-with-copy"><code class="sourceCode julia"><span id="annotated-cell-1-1"><a href="#annotated-cell-1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-2"><a href="#annotated-cell-1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">merge2!</span>(C, A, B)</span>
<span id="annotated-cell-1-3"><a href="#annotated-cell-1-3" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> j <span class="op">=</span> <span class="fl">1</span></span>
<span id="annotated-cell-1-4"><a href="#annotated-cell-1-4" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="fu">length</span>(A), <span class="fu">length</span>(B)</span>
<span id="annotated-cell-1-5"><a href="#annotated-cell-1-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-1-6"><a href="#annotated-cell-1-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@inbounds</span> <span class="cf">while</span> i <span class="op">&lt;=</span> m <span class="op">||</span>  j <span class="op">&lt;=</span> n</span>
<span id="annotated-cell-1-7"><a href="#annotated-cell-1-7" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> A[i], B[j]</span>
<span id="annotated-cell-1-8"><a href="#annotated-cell-1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a <span class="op">==</span> b</span>
<span id="annotated-cell-1-9"><a href="#annotated-cell-1-9" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(C, a)</span>
<span id="annotated-cell-1-10"><a href="#annotated-cell-1-10" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="fl">1</span></span>
<span id="annotated-cell-1-11"><a href="#annotated-cell-1-11" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="fl">1</span></span>
<span id="annotated-cell-1-12"><a href="#annotated-cell-1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elseif</span> a <span class="op">&lt;</span> b</span>
<span id="annotated-cell-1-13"><a href="#annotated-cell-1-13" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(C, a)</span>
<span id="annotated-cell-1-14"><a href="#annotated-cell-1-14" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="fl">1</span></span>
<span id="annotated-cell-1-15"><a href="#annotated-cell-1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="annotated-cell-1-16"><a href="#annotated-cell-1-16" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(C, b)</span>
<span id="annotated-cell-1-17"><a href="#annotated-cell-1-17" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="fl">1</span></span>
<span id="annotated-cell-1-18"><a href="#annotated-cell-1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="annotated-cell-1-19"><a href="#annotated-cell-1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="annotated-cell-1-20"><a href="#annotated-cell-1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-21"><a href="#annotated-cell-1-21" aria-hidden="true" tabindex="-1"></a>    C</span>
<span id="annotated-cell-1-22"><a href="#annotated-cell-1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>merge2! (generic function with 1 method)</code></pre>
</div>
</div>
<section id="ejercicio" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="ejercicio"><span class="header-section-number">6.2.1</span> Ejercicio</h3>
<ul>
<li>Escriba y pruebe el algoritmo de intersección de merge para <span class="math inline">\(n \approx m\)</span>.</li>
</ul>
</section>
</section>
<section id="algoritmos-para-arreglos-de-tamaño-muy-diferente" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="algoritmos-para-arreglos-de-tamaño-muy-diferente"><span class="header-section-number">6.3</span> Algoritmos para arreglos de tamaño muy diferente</h2>
<p>Si <span class="math inline">\(m \ll n\)</span>, el costo tenderá a <span class="math inline">\(O(m \log n)\)</span>, por lo que se pueden realizar <span class="math inline">\(m\)</span> búsquedas binarias <em>directas</em> para localizar la posición de inserción en <span class="math inline">\(B\)</span>.</p>
<div class="cell" data-fig-width="100%" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-interseccion" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-interseccion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 1418.00 212.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(36 176)">
<title>lista</title>
<polygon fill="white" stroke="transparent" points="-36,36 -36,-176 1382,-176 1382,36 -36,36"></polygon>
<g id="clust1" class="cluster">
<title>A</title>
<polygon fill="none" stroke="black" points="8,-8 8,-60 1338,-60 1338,-8 8,-8"></polygon>
</g>
<g id="clust2" class="cluster">
<title>B</title>
<polygon fill="none" stroke="black" points="8,-80 8,-132 1338,-132 1338,-80 8,-80"></polygon>
</g>
<!-- a1 -->
<g id="node1" class="node">
<title>a1</title>
<ellipse fill="none" stroke="black" cx="43" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="43" y="-29.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- a2 -->
<g id="node2" class="node">
<title>a2</title>
<ellipse fill="lightgrey" stroke="black" cx="133" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="133" y="-29.8" font-family="Times,serif" font-size="14.00">2</text>
</g>
<!-- a1&#45;&gt;a2 -->
<!-- a3 -->
<g id="node3" class="node">
<title>a3</title>
<ellipse fill="none" stroke="black" cx="223" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="223" y="-29.8" font-family="Times,serif" font-size="14.00">3</text>
</g>
<!-- a2&#45;&gt;a3 -->
<!-- a4 -->
<g id="node4" class="node">
<title>a4</title>
<ellipse fill="none" stroke="black" cx="313" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="313" y="-29.8" font-family="Times,serif" font-size="14.00">4</text>
</g>
<!-- a3&#45;&gt;a4 -->
<!-- a5 -->
<g id="node5" class="node">
<title>a5</title>
<ellipse fill="lightgrey" stroke="black" cx="403" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="403" y="-29.8" font-family="Times,serif" font-size="14.00">5</text>
</g>
<!-- a4&#45;&gt;a5 -->
<!-- a6 -->
<g id="node6" class="node">
<title>a6</title>
<ellipse fill="none" stroke="black" cx="493" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="493" y="-29.8" font-family="Times,serif" font-size="14.00">6</text>
</g>
<!-- a5&#45;&gt;a6 -->
<!-- a7 -->
<g id="node7" class="node">
<title>a7</title>
<ellipse fill="lightgrey" stroke="black" cx="583" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="583" y="-29.8" font-family="Times,serif" font-size="14.00">7</text>
</g>
<!-- a6&#45;&gt;a7 -->
<!-- a8 -->
<g id="node8" class="node">
<title>a8</title>
<ellipse fill="none" stroke="black" cx="673" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="673" y="-29.8" font-family="Times,serif" font-size="14.00">8</text>
</g>
<!-- a7&#45;&gt;a8 -->
<!-- a9 -->
<g id="node9" class="node">
<title>a9</title>
<ellipse fill="none" stroke="black" cx="763" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="763" y="-29.8" font-family="Times,serif" font-size="14.00">9</text>
</g>
<!-- a8&#45;&gt;a9 -->
<!-- a10 -->
<g id="node10" class="node">
<title>a10</title>
<ellipse fill="none" stroke="black" cx="853" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="853" y="-29.8" font-family="Times,serif" font-size="14.00">10</text>
</g>
<!-- a9&#45;&gt;a10 -->
<!-- a11 -->
<g id="node11" class="node">
<title>a11</title>
<ellipse fill="none" stroke="black" cx="943" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="943" y="-29.8" font-family="Times,serif" font-size="14.00">11</text>
</g>
<!-- a10&#45;&gt;a11 -->
<!-- a12 -->
<g id="node12" class="node">
<title>a12</title>
<ellipse fill="none" stroke="black" cx="1033" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="1033" y="-29.8" font-family="Times,serif" font-size="14.00">12</text>
</g>
<!-- a11&#45;&gt;a12 -->
<!-- a13 -->
<g id="node13" class="node">
<title>a13</title>
<ellipse fill="none" stroke="black" cx="1123" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="1123" y="-29.8" font-family="Times,serif" font-size="14.00">13</text>
</g>
<!-- a12&#45;&gt;a13 -->
<!-- a15 -->
<g id="node14" class="node">
<title>a15</title>
<ellipse fill="lightgrey" stroke="black" cx="1213" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="1213" y="-29.8" font-family="Times,serif" font-size="14.00">15</text>
</g>
<!-- a13&#45;&gt;a15 -->
<!-- a16 -->
<g id="node15" class="node">
<title>a16</title>
<ellipse fill="none" stroke="black" cx="1303" cy="-34" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="1303" y="-29.8" font-family="Times,serif" font-size="14.00">16</text>
</g>
<!-- a15&#45;&gt;a16 -->
<!-- 1 -->
<g id="node16" class="node">
<title>1</title>
<ellipse fill="lightgrey" stroke="black" cx="43" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="43" y="-101.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- 2 -->
<g id="node17" class="node">
<title>2</title>
<ellipse fill="none" stroke="black" cx="133" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="133" y="-101.8" font-family="Times,serif" font-size="14.00">2</text>
</g>
<!-- 1&#45;&gt;2 -->
<!-- 3 -->
<g id="node18" class="node">
<title>3</title>
<ellipse fill="none" stroke="black" cx="223" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="223" y="-101.8" font-family="Times,serif" font-size="14.00">3</text>
</g>
<!-- 2&#45;&gt;3 -->
<!-- 4 -->
<g id="node19" class="node">
<title>4</title>
<ellipse fill="none" stroke="black" cx="313" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="313" y="-101.8" font-family="Times,serif" font-size="14.00">4</text>
</g>
<!-- 3&#45;&gt;4 -->
<!-- 5 -->
<g id="node20" class="node">
<title>5</title>
<ellipse fill="lightgrey" stroke="black" cx="403" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="403" y="-101.8" font-family="Times,serif" font-size="14.00">5</text>
</g>
<!-- 4&#45;&gt;5 -->
<!-- 6 -->
<g id="node21" class="node">
<title>6</title>
<ellipse fill="none" stroke="black" cx="493" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="493" y="-101.8" font-family="Times,serif" font-size="14.00">6</text>
</g>
<!-- 5&#45;&gt;6 -->
<!-- 7 -->
<g id="node22" class="node">
<title>7</title>
<ellipse fill="lightgrey" stroke="black" cx="583" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="583" y="-101.8" font-family="Times,serif" font-size="14.00">7</text>
</g>
<!-- 6&#45;&gt;7 -->
<!-- 8 -->
<g id="node23" class="node">
<title>8</title>
<ellipse fill="none" stroke="black" cx="673" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="673" y="-101.8" font-family="Times,serif" font-size="14.00">8</text>
</g>
<!-- 7&#45;&gt;8 -->
<!-- 9 -->
<g id="node24" class="node">
<title>9</title>
<ellipse fill="none" stroke="black" cx="763" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="763" y="-101.8" font-family="Times,serif" font-size="14.00">9</text>
</g>
<!-- 8&#45;&gt;9 -->
<!-- 10 -->
<g id="node25" class="node">
<title>10</title>
<ellipse fill="lightgrey" stroke="black" cx="853" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="853" y="-101.8" font-family="Times,serif" font-size="14.00">10</text>
</g>
<!-- 9&#45;&gt;10 -->
<!-- 11 -->
<g id="node26" class="node">
<title>11</title>
<ellipse fill="none" stroke="black" cx="943" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="943" y="-101.8" font-family="Times,serif" font-size="14.00">11</text>
</g>
<!-- 10&#45;&gt;11 -->
<!-- 12 -->
<g id="node27" class="node">
<title>12</title>
<ellipse fill="lightgrey" stroke="black" cx="1033" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="1033" y="-101.8" font-family="Times,serif" font-size="14.00">12</text>
</g>
<!-- 11&#45;&gt;12 -->
<!-- 13 -->
<g id="node28" class="node">
<title>13</title>
<ellipse fill="none" stroke="black" cx="1123" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="1123" y="-101.8" font-family="Times,serif" font-size="14.00">13</text>
</g>
<!-- 12&#45;&gt;13 -->
<!-- 15 -->
<g id="node29" class="node">
<title>15</title>
<ellipse fill="lightgrey" stroke="black" cx="1213" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="1213" y="-101.8" font-family="Times,serif" font-size="14.00">15</text>
</g>
<!-- 13&#45;&gt;15 -->
<!-- 16 -->
<g id="node30" class="node">
<title>16</title>
<ellipse fill="none" stroke="black" cx="1303" cy="-106" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="1303" y="-101.8" font-family="Times,serif" font-size="14.00">16</text>
</g>
<!-- 15&#45;&gt;16 -->
</g>
</svg>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-interseccion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;6.1: Dos listas alineadas donde los nodos sombreados son elementos de los conjuntos.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Se hace notar que <span class="math inline">\(A\)</span> y <span class="math inline">\(B\)</span> estan ordenados, y por lo tanto, localizar <span class="math inline">\(A[i]\)</span> en <span class="math inline">\(B[j]\)</span> significa que <span class="math inline">\(B[j-1] &lt; A[i]\)</span>, por lo que intentar localizar <span class="math inline">\(A[i+1]\)</span> puede comenzar en <span class="math inline">\(B[j+1]\)</span>. A continuación se muestra el código de un algoritmo de intersección usando algoritmos de búsqueda con memoria de la posición anterior.</p>
<div id="8" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">intsearch!</span>(C, A, B, algosearch<span class="op">=</span>doublingsearch)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="fu">length</span>(B) <span class="op">&lt;</span> <span class="fu">length</span>(A)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        A, B <span class="op">=</span> B, A</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i, a) <span class="kw">in</span> <span class="fu">enumerate</span>(A)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">algosearch</span>(B, a, p)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        p <span class="op">&gt;</span> <span class="fu">length</span>(B) <span class="op">&amp;&amp;</span> <span class="cf">break</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a <span class="op">==</span> B[p]</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            p <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(C, a)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    C</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><span class="citation" data-cites="hwang1971optimal">Hwang y Lin (<a href="refs.html#ref-hwang1971optimal" role="doc-biblioref">1971</a>)</span> propone otro algoritmo que funciona para casos similares:</p>
<ol type="1">
<li>Divide <span class="math inline">\(B\)</span> en bloques de tamaño <span class="math inline">\(m\)</span>, define un arreglo <em>virtual</em> <span class="math inline">\(B'[1..n/m]\)</span> donde <span class="math inline">\(B'[i] = B[i \cdot m]\)</span></li>
<li>Se búsca la posición de inserción <span class="math inline">\(p\)</span> de cada <span class="math inline">\(a \in A\)</span> en <span class="math inline">\(B'\)</span>, costando <span class="math inline">\(\log n/m\)</span> para cada búsqueda.</li>
<li>Después se localiza dentro del <span class="math inline">\(B\)</span> en el <span class="math inline">\(p\)</span>-ésimo bloque, i.e., <span class="math inline">\(B[(p-1)m + 1 .. p\cdot m]\)</span>, por la posición de inserción del bloque, con un costo de <span class="math inline">\(\log m\)</span>.</li>
</ol>
<p>Entonces, se obtiene un costo de <span class="math inline">\(O(m \log{n/m} + m \log m)\)</span>; esto es equivalente en el peor caso a búsquedas directas, i.e., las posiciones de inserción de <span class="math inline">\(a \in A\)</span> se encuentran distribuidas de manera uniforme en <span class="math inline">\(B\)</span>. Sin embargo, es posible mejorar si se descartan bloques en el paso 1. Esto es, si se hay concentración de elementos de <span class="math inline">\(A\)</span> en bloques de <span class="math inline">\(B\)</span>. Para esto, es necesario un análisis de costo promedio, el cual se muestra en el artículo.</p>
<p>Incluso cuando hay concentración, podemos recordar la <span class="math inline">\((i-1)\)</span> posición de inserción para iniciar la <span class="math inline">\(i\)</span>-ésima búsqueda, y sacar provecho de posiciones esperadas cercanas de la posición inicial de búsqueda, i.e., podemos utilizar algoritmos de búsqueda adaptables para mejorar el desempeño.</p>
<section id="algoritmo-de-baeza-yates" class="level3" data-number="6.3.1">
<h3 data-number="6.3.1" class="anchored" data-anchor-id="algoritmo-de-baeza-yates"><span class="header-section-number">6.3.1</span> Algoritmo de Baeza Yates</h3>
<p><span class="citation" data-cites="BY2004">Baeza-Yates (<a href="refs.html#ref-BY2004" role="doc-biblioref">2004</a>)</span> propone un algoritmo eficiente para intersecciones de dos conjuntos. El algoritmo tiene una estrategía <em>dividir para vencer</em>:</p>
<ol type="1">
<li>Se toma la mediana <span class="math inline">\(M\)</span> de <span class="math inline">\(A\)</span> y se busca en <span class="math inline">\(B\)</span> obteniendo su posición de inserción <span class="math inline">\(p\)</span>.</li>
<li>El problema entonces se divide en 3 subproblemas: <span class="math display">\[\begin{align}
C_&lt; &amp;= \{A[1..M-1] \cap B[1..p-e]\} \\
C_= &amp;= \{A[M]\} \cap \{B[p]\} \\
C_&gt; &amp;= \{A[M+1..m] \cap B[p+e..n]\} \\
\end{align}\]</span> donde <span class="math inline">\(e=1\)</span> si <span class="math inline">\(A[M] = B[p]\)</span> y <span class="math inline">\(e=0\)</span> cuando <span class="math inline">\(A[M] \not= B[p]\)</span>.</li>
<li>La unión de estos tres conjuntos es la solución <span class="math inline">\(C_&lt; \cup C_= \cup C_&gt;\)</span>.</li>
<li>El problema <span class="math inline">\(C_=\)</span> es trivial, y <span class="math inline">\(C_&lt;\)</span> y <span class="math inline">\(C_&gt;\)</span> se implementan recurriendo, ajustando los rangos de trabajo.</li>
</ol>
<p>A continuación se muestra el código en Julia, usando los algoritmos de búsqueda del Cap. 5.</p>
<div id="12" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode julia code-annotation-code code-with-copy code-annotated"><code class="sourceCode julia"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Adaptado de https://github.com/sadit/Intersections.jl</span></span>
<span id="annotated-cell-3-2"><a href="#annotated-cell-3-2" aria-hidden="true" tabindex="-1"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-3-3" class="code-annotation-target"><a href="#annotated-cell-3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">baezayates!</span>(output, A, B, findpos<span class="op">::</span><span class="dt">Function</span>=binarysearch)</span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">baezayates!</span>(output, A, <span class="fl">1</span>, <span class="fu">length</span>(A), B, <span class="fl">1</span>, <span class="fu">length</span>(B), findpos)</span>
<span id="annotated-cell-3-5"><a href="#annotated-cell-3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="annotated-cell-3-6"><a href="#annotated-cell-3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-7"><a href="#annotated-cell-3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">baezayates!</span>(output, A, a_sp<span class="op">::</span><span class="dt">Int</span>, a_ep<span class="op">::</span><span class="dt">Int</span>, B, b_sp<span class="op">::</span><span class="dt">Int</span>, b_ep<span class="op">::</span><span class="dt">Int</span>, findpos<span class="op">::</span><span class="dt">Function</span>)</span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8" aria-hidden="true" tabindex="-1"></a>    (a_ep <span class="op">&lt;</span> a_sp <span class="op">||</span> b_ep <span class="op">&lt;</span> b_sp) <span class="op">&amp;&amp;</span> <span class="cf">return</span> output</span>
<span id="annotated-cell-3-9"><a href="#annotated-cell-3-9" aria-hidden="true" tabindex="-1"></a>    imedian <span class="op">=</span> <span class="fu">ceil</span>(<span class="dt">Int</span>, (a_ep <span class="op">+</span> a_sp) <span class="op">/</span> <span class="fl">2</span>)</span>
<span id="annotated-cell-3-10"><a href="#annotated-cell-3-10" aria-hidden="true" tabindex="-1"></a>    median <span class="op">=</span> A[imedian]</span>
<span id="annotated-cell-3-11"><a href="#annotated-cell-3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">## our findpos returns n + 1 when median is larger than B[end]</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-3-12" class="code-annotation-target"><a href="#annotated-cell-3-12" aria-hidden="true" tabindex="-1"></a>    medpos <span class="op">=</span> <span class="fu">min</span>(<span class="fu">findpos</span>(B, median, b_sp), b_ep)</span>
<span id="annotated-cell-3-13"><a href="#annotated-cell-3-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-3-14"><a href="#annotated-cell-3-14" aria-hidden="true" tabindex="-1"></a>    matches <span class="op">=</span> median <span class="op">==</span> B[medpos] </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-3-15" class="code-annotation-target"><a href="#annotated-cell-3-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">baezayates!</span>(output, A, a_sp, imedian <span class="op">-</span> <span class="fl">1</span>, B, b_sp, medpos <span class="op">-</span> matches, findpos)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-3-16" class="code-annotation-target"><a href="#annotated-cell-3-16" aria-hidden="true" tabindex="-1"></a>    matches <span class="op">&amp;&amp;</span> <span class="fu">push!</span>(output, median)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-3-17" class="code-annotation-target"><a href="#annotated-cell-3-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">baezayates!</span>(output, A, imedian <span class="op">+</span> <span class="fl">1</span>, a_ep, B, medpos <span class="op">+</span> matches, b_ep, findpos)</span>
<span id="annotated-cell-3-18"><a href="#annotated-cell-3-18" aria-hidden="true" tabindex="-1"></a>    output</span>
<span id="annotated-cell-3-19"><a href="#annotated-cell-3-19" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="3" data-code-annotation="1">Punto de entrada.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="12" data-code-annotation="2">Búsqueda de la posición de inserción de la mediana de <span class="math inline">\(A\)</span> en <span class="math inline">\(B\)</span>.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="15" data-code-annotation="3">Recurrencia para el problema <span class="math inline">\(C_&lt;\)</span>.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="16" data-code-annotation="4">Añadir al resultado el valor de la mediana si es que se encontró en <span class="math inline">\(B\)</span>; es importante que este paso este entre las recurrencias para que <em>output</em> sea un arreglo ordenado.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="17" data-code-annotation="5">Recurencia para el problema <span class="math inline">\(C_&gt;\)</span>.</span>
</dd>
</dl>
</div>
</div>
<p>El algoritmo de Baeza Yates es óptimo en el peor caso y es capaz de aprovechar casos donde <span class="math inline">\(C_&lt;\)</span> o <span class="math inline">\(C_&gt;\)</span> se convierten en triviales, lo cual da muy buenos casos en algunas distribuciones.</p>
</section>
<section id="ejercicios" class="level3" data-number="6.3.2">
<h3 data-number="6.3.2" class="anchored" data-anchor-id="ejercicios"><span class="header-section-number">6.3.2</span> Ejercicios</h3>
<ol type="1">
<li>Implemente la unión con el algoritmo de Baeza Yates.</li>
</ol>
</section>
</section>
<section id="operaciones-con-tres-o-más-conjuntos" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="operaciones-con-tres-o-más-conjuntos"><span class="header-section-number">6.4</span> Operaciones con tres o más conjuntos</h2>
<p>Los algoritmos y costos hasta ahora revisados se cumplen para dos conjuntos; se mencionaron diferentes algoritmos, algunos de ellos especializados por características como las proporciones de los conjuntos de entrada.</p>
<p>En particular, es importante hacer notar que ni el problema ni las aplicaciones estan limitadas a dos conjuntos, y por tanto, es importante algoritmos y estrategías para resolver <span class="math inline">\(\bigcup_i A_i\)</span> así como <span class="math inline">\(\bigcap_i A_i\)</span>.</p>
<section id="algoritmo-svs" class="level3" data-number="6.4.1">
<h3 data-number="6.4.1" class="anchored" data-anchor-id="algoritmo-svs"><span class="header-section-number">6.4.1</span> Algoritmo SvS</h3>
<p>Dado <span class="math inline">\(C = A \cap B\)</span> es un hecho que <span class="math inline">\(|C| \leq min \{|A|, |B|\}\)</span>. Recordando, que hay maneras relativamente simples y eficientes de resolver la intersección cuando <span class="math inline">\(m \ll n\)</span>; por tanto, cuando tenemos más de dos conjuntos podemos aplicar la estrategía <em>Small vs Small (SvS)</em>, que consisten en intersectar los <span class="math inline">\(k\)</span> conjuntos por pares intersectando el par de arreglos más pequeños cada vez.</p>
<div id="16" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Adaptado de https://github.com/sadit/Intersections.jl</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">svs</span>(L<span class="op">::</span><span class="dt">Vector{T}</span>, in2<span class="op">::</span><span class="dt">Function</span>=baezayates!) <span class="kw">where</span> T</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    prev, curr <span class="op">=</span> <span class="fu">eltype</span>(T)[], <span class="fu">eltype</span>(T)[]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sort!</span>(L, by<span class="op">=</span>length, rev<span class="op">=</span><span class="cn">true</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    curr <span class="op">=</span> <span class="fu">pop!</span>(L)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="fu">length</span>(L) <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">empty!</span>(prev)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        isize <span class="op">=</span> <span class="fu">in2</span>(prev, curr, <span class="fu">pop!</span>(L))</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        isize <span class="op">==</span> <span class="fl">0</span> <span class="op">&amp;&amp;</span> <span class="cf">return</span> prev</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        prev, curr <span class="op">=</span> curr, prev</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    curr</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="algoritmo-de-barbay-y-kenyon" class="level3" data-number="6.4.2">
<h3 data-number="6.4.2" class="anchored" data-anchor-id="algoritmo-de-barbay-y-kenyon"><span class="header-section-number">6.4.2</span> Algoritmo de Barbay y Kenyon</h3>
<p>Existe otra familia de algoritmos, basados en búsquedas adaptativas que pueden llegar a mejorar el desempeño bajo cierto tipo de entradas. <span class="citation" data-cites="DLOPM2001">Demaine, López-Ortiz, y Ian Munro (<a href="refs.html#ref-DLOPM2001" role="doc-biblioref">2001</a>)</span>, <span class="citation" data-cites="BLOL2006">Barbay, López-Ortiz, y Lu (<a href="refs.html#ref-BLOL2006" role="doc-biblioref">2006</a>)</span>, y <span class="citation" data-cites="BLOLS2010">Barbay et&nbsp;al. (<a href="refs.html#ref-BLOLS2010" role="doc-biblioref">2010</a>)</span> muestran algoritmos de intersección basados en búsqueda adaptables para aprovechar instancias simples. Estos estudios se basan en contribuciones teóricas de los mismos autores: <span class="citation" data-cites="DLOM2000">Demaine, López-Ortiz, y Munro (<a href="refs.html#ref-DLOM2000" role="doc-biblioref">2000</a>)</span>, <span class="citation" data-cites="DLOPM2001">Demaine, López-Ortiz, y Ian Munro (<a href="refs.html#ref-DLOPM2001" role="doc-biblioref">2001</a>)</span>, <span class="citation" data-cites="BK2002">Barbay y Kenyon (<a href="refs.html#ref-BK2002" role="doc-biblioref">2002</a>)</span> y <span class="citation" data-cites="BY2004">Baeza-Yates (<a href="refs.html#ref-BY2004" role="doc-biblioref">2004</a>)</span>.</p>
<p>El algoritmo de <span class="citation" data-cites="BLOL2006">Barbay, López-Ortiz, y Lu (<a href="refs.html#ref-BLOL2006" role="doc-biblioref">2006</a>)</span> trabaja sobre los <span class="math inline">\(k\)</span> conjuntos de entrada, representados como arreglos ordenados de números enteros. Es un algoritmo simple pero poderoso: hace uso de búsquedas adaptivas con memoria para guardar las posiciones donde se avanza, de tal forma que no se recalculen posiciones. Las diferentes estrategias para revisar los conjuntos pueden dar diferentes desempeños, como se valida en <span class="citation" data-cites="BLOLS2010">Barbay et&nbsp;al. (<a href="refs.html#ref-BLOLS2010" role="doc-biblioref">2010</a>)</span>, donde además de hacer una gran variedad de experimentos sobre diferentes algoritmos de búsqueda, se introducen variantes en el orden de acceso de cada conjunto.</p>
<p>A continuacións se muestra el código del algoritmo base:</p>
<div id="20" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="annotated-cell-5"><pre class="sourceCode julia code-annotation-code code-with-copy code-annotated"><code class="sourceCode julia"><span id="annotated-cell-5-1"><a href="#annotated-cell-5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Adaptado de https://github.com/sadit/Intersections.jl</span></span>
<span id="annotated-cell-5-2"><a href="#annotated-cell-5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-3"><a href="#annotated-cell-5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">bk!</span>(output, L<span class="op">::</span><span class="dt">AbstractVector</span>, findpos<span class="op">::</span><span class="dt">Function</span>=doublingsearch)</span>
<span id="annotated-cell-5-4"><a href="#annotated-cell-5-4" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> <span class="fu">ones</span>(<span class="dt">Int</span>, <span class="fu">length</span>(L))</span>
<span id="annotated-cell-5-5"><a href="#annotated-cell-5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">bk!</span>(output, L, P, findpos)</span>
<span id="annotated-cell-5-6"><a href="#annotated-cell-5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="annotated-cell-5-7"><a href="#annotated-cell-5-7" aria-hidden="true" tabindex="-1"></a> </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-5-8" class="code-annotation-target"><a href="#annotated-cell-5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">bk!</span>(output, L, P, findpos<span class="op">::</span><span class="dt">Function</span>=doublingsearch)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-5-9" class="code-annotation-target"><a href="#annotated-cell-5-9" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">length</span>(L)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-5-10" class="code-annotation-target"><a href="#annotated-cell-5-10" aria-hidden="true" tabindex="-1"></a>    el <span class="op">=</span> L[<span class="fl">1</span>][<span class="fl">1</span>]</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-5-11" class="code-annotation-target"><a href="#annotated-cell-5-11" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="fl">0</span></span>
<span id="annotated-cell-5-12"><a href="#annotated-cell-5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-13"><a href="#annotated-cell-5-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@inbounds</span> <span class="cf">while</span> <span class="cn">true</span></span>
<span id="annotated-cell-5-14"><a href="#annotated-cell-5-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="fu">eachindex</span>(P)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-5-15" class="code-annotation-target"><a href="#annotated-cell-5-15" aria-hidden="true" tabindex="-1"></a>            P[i] <span class="op">=</span> <span class="fu">findpos</span>(L[i], el, P[i])</span>
<span id="annotated-cell-5-16"><a href="#annotated-cell-5-16" aria-hidden="true" tabindex="-1"></a>            P[i] <span class="op">&gt;</span> <span class="fu">length</span>(L[i]) <span class="op">&amp;&amp;</span> <span class="cf">return</span> output</span>
<span id="annotated-cell-5-17"><a href="#annotated-cell-5-17" aria-hidden="true" tabindex="-1"></a>            pval <span class="op">=</span> L[i][P[i]]</span>
<span id="annotated-cell-5-18"><a href="#annotated-cell-5-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pval <span class="op">==</span> el</span>
<span id="annotated-cell-5-19"><a href="#annotated-cell-5-19" aria-hidden="true" tabindex="-1"></a>                c <span class="op">+=</span> <span class="fl">1</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="6" onclick="event.preventDefault();">6</a><span id="annotated-cell-5-20" class="code-annotation-target"><a href="#annotated-cell-5-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> c <span class="op">==</span> n</span>
<span id="annotated-cell-5-21"><a href="#annotated-cell-5-21" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">push!</span>(output, el)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="7" onclick="event.preventDefault();">7</a><span id="annotated-cell-5-22" class="code-annotation-target"><a href="#annotated-cell-5-22" aria-hidden="true" tabindex="-1"></a>                    c <span class="op">=</span> <span class="fl">0</span></span>
<span id="annotated-cell-5-23"><a href="#annotated-cell-5-23" aria-hidden="true" tabindex="-1"></a>                    P[i] <span class="op">+=</span> <span class="fl">1</span></span>
<span id="annotated-cell-5-24"><a href="#annotated-cell-5-24" aria-hidden="true" tabindex="-1"></a>                    P[i] <span class="op">&gt;</span> <span class="fu">length</span>(L[i]) <span class="op">&amp;&amp;</span> <span class="cf">return</span> output</span>
<span id="annotated-cell-5-25"><a href="#annotated-cell-5-25" aria-hidden="true" tabindex="-1"></a>                    el <span class="op">=</span> L[i][P[i]]</span>
<span id="annotated-cell-5-26"><a href="#annotated-cell-5-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">end</span></span>
<span id="annotated-cell-5-27"><a href="#annotated-cell-5-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="annotated-cell-5-28"><a href="#annotated-cell-5-28" aria-hidden="true" tabindex="-1"></a>                c <span class="op">=</span> <span class="fl">0</span></span>
<span id="annotated-cell-5-29"><a href="#annotated-cell-5-29" aria-hidden="true" tabindex="-1"></a>                el <span class="op">=</span> pval</span>
<span id="annotated-cell-5-30"><a href="#annotated-cell-5-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="annotated-cell-5-31"><a href="#annotated-cell-5-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="annotated-cell-5-32"><a href="#annotated-cell-5-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="annotated-cell-5-33"><a href="#annotated-cell-5-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-34"><a href="#annotated-cell-5-34" aria-hidden="true" tabindex="-1"></a>    output</span>
<span id="annotated-cell-5-35"><a href="#annotated-cell-5-35" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-5" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="8" data-code-annotation="1">El algoritmo de Barbay &amp; Kenyon recibe: i) <code>output</code> el conjunto de salida. ii) <code>L</code> la lista de conjuntos (representados como arreglos ordenados). iii) <code>P</code> arreglo de posiciones <em>actuales</em> para cada arreglo. iv) findpos` función de búsqueda.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="9" data-code-annotation="2">Número de conjuntos en <code>L</code>.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="10" data-code-annotation="3"><code>el</code> es el elemento siendo búscado en todos los arreglos.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="11" data-code-annotation="4"><code>c</code> número de listas que contienen <code>el</code>.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="15" data-code-annotation="5">Búscando la posición de inserción de <code>el</code> en <code>L[i]</code>, comenzando en <code>P[i]</code>.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="20" data-code-annotation="6">Esta igualdad implica que hay interección.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="22,23,25,28,29" data-code-annotation="7">Reiniciando <code>el</code> y <code>c</code> y actualizando <code>P[i]</code>.</span>
</dd>
</dl>
</div>
</div>
<p>De manera particular, <span class="citation" data-cites="BLOLS2010">Barbay et&nbsp;al. (<a href="refs.html#ref-BLOLS2010" role="doc-biblioref">2010</a>)</span> presentan un estudio experimental sobre los algoritmos presentados en el área durante la decada de 2000 a 2010, dichos algoritmos se parametrizaron de maneras que nos permiten aprender diferentes características de cada uno de ellos, dependiendo de los algoritmos de búsqueda que usan, la arquitectura computacional donde se evalúa, y el número de conjuntos siendo procesados.</p>
</section>
</section>
<section id="recursos-audio-visuales-de-la-unidad" class="level2" data-number="6.5">
<h2 data-number="6.5" class="anchored" data-anchor-id="recursos-audio-visuales-de-la-unidad"><span class="header-section-number">6.5</span> Recursos audio-visuales de la unidad</h2>
<p>Parte 1: Algoritmos de intersección (y unión) de listas ordenadas <iframe width="560" height="315" src="https://www.youtube.com/embed/aDYO39yi-4g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></p>
<p>Parte 2: Algoritmos de intersección y algunas aplicaciones <iframe width="560" height="315" src="https://www.youtube.com/embed/oOd5LoVJcAs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></p>
</section>
<section id="actividades" class="level2" data-number="6.6">
<h2 data-number="6.6" class="anchored" data-anchor-id="actividades"><span class="header-section-number">6.6</span> Actividades</h2>
<p>Implementación y comparación de diferentes algoritmos de intersección de conjuntos.</p>
<p>Lea cuidadosamente las instrucciones y desarrolle las actividades. Entregue el reporte correspondiente en tiempo.</p>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-BY2004" class="csl-entry" role="listitem">
Baeza-Yates, Ricardo. 2004. <span>“A fast set intersection algorithm for sorted sequences”</span>. En <em>Combinatorial Pattern Matching: 15th Annual Symposium, CPM 2004, Istanbul, Turkey, July 5-7, 2004. Proceedings 15</em>, 400–408. Springer.
</div>
<div id="ref-BK2002" class="csl-entry" role="listitem">
Barbay, Jérémy, y Claire Kenyon. 2002. <span>“Adaptive intersection and t-threshold problems”</span>. En <em>Proceedings of the Thirteenth Annual ACM-SIAM Symposium on Discrete Algorithms</em>, 390–99. SODA ’02. USA: Society for Industrial; Applied Mathematics.
</div>
<div id="ref-BLOL2006" class="csl-entry" role="listitem">
Barbay, Jérémy, Alejandro López-Ortiz, y Tyler Lu. 2006. <span>“Faster adaptive set intersections for text searching”</span>. En <em>Experimental Algorithms: 5th International Workshop, WEA 2006, Cala Galdana, Menorca, Spain, May 24-27, 2006. Proceedings 5</em>, 146–57. Springer.
</div>
<div id="ref-BLOLS2010" class="csl-entry" role="listitem">
Barbay, Jérémy, Alejandro López-Ortiz, Tyler Lu, y Alejandro Salinger. 2010. <span>“An experimental investigation of set intersection algorithms for text searching”</span>. <em>Journal of Experimental Algorithmics (JEA)</em> 14: 3–7.
</div>
<div id="ref-DLOPM2001" class="csl-entry" role="listitem">
Demaine, Erik D, Alejandro López-Ortiz, y J Ian Munro. 2001. <span>“Experiments on adaptive set intersections for text retrieval systems”</span>. En <em>Algorithm Engineering and Experimentation: Third International Workshop, ALENEX 2001 Washington, DC, USA, January 5–6, 2001 Revised Papers 3</em>, 91–104. Springer.
</div>
<div id="ref-DLOM2000" class="csl-entry" role="listitem">
Demaine, Erik D, Alejandro López-Ortiz, y J Ian Munro. 2000. <span>“Adaptive set intersections, unions, and differences”</span>. En <em>Proceedings of the eleventh annual ACM-SIAM symposium on Discrete algorithms</em>, 743–52.
</div>
<div id="ref-hwang1971optimal" class="csl-entry" role="listitem">
Hwang, Frank K., y Shen Lin. 1971. <span>“Optimal merging of 2 elements with n elements”</span>. <em>Acta Informatica</em> 1 (2): 145–58.
</div>
<div id="ref-mackay2003information" class="csl-entry" role="listitem">
MacKay, David JC. 2003. <em>Information theory, inference and learning algorithms</em>. Cambridge university press.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/sadit\.github\.io\/ALGO-IR");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./cap5-busqueda.html" class="pagination-link" aria-label="Algoritmos de búsqueda en el modelo de comparación">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Algoritmos de búsqueda en el modelo de comparación</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./refs.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Ejecutar el código</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb4" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Algoritmos de intersección y unión de conjuntos en el modelo de comparación"</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="an">lang:</span><span class="co"> es-MX</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> julia</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="fu">## Objetivo {.unnumbered}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>Analizar el rendimiento de algoritmos de unión e intersección de conjuntos representados como listas ordenadas parametrizando los algoritmos con los algoritmos internos de búsqueda, tamaño de los conjuntos y la distribución de los elementos, bajo un enfoque experimental midiendo los costos en términos del tiempo de ejecución y el uso de memoria.</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="fu">## Problema</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>Cómo se vió en Capítulos anteriores, un conjunto es una colección de elementos donde no hay repetición. El uso de conjuntos es fundamental para un gran número de problemas. En particular, en este capítulo representaremos conjuntos como arreglos ordenados de números enteros; esto para posicionarlo dentro de un dominio de aplicación objetivo, que es la Recuperación de Información, como parte de la representación de una la matriz dispersa muy grande, llamada _índice invertido_. </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>Estaremos resolviendo los problemas de intersección y unión de conjuntos. @DLOM2000 demuestra que el costo y procedimiento de las intersecciones y uniones de conjuntos representados como arreglos ordenados, es básicamente el mismo; ya que requieren determinar la misma información. Claramente, colectar los datos para la unión y la intersección, requieren diferentes esfuerzos.</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="fu">### Costo del problema</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>En general, dados dos conjuntos $A<span class="co">[</span><span class="ot">1..m</span><span class="co">]</span> = <span class="sc">\{</span>a_1 &lt; a_2 &lt; \cdots &lt; a_m <span class="sc">\}</span>$ y $B<span class="co">[</span><span class="ot">1..n</span><span class="co">]</span> = <span class="sc">\{</span>b_1 &lt; b_2 &lt; \cdots &lt; b_n <span class="sc">\}</span>$, el costo de unión es $$\log{m+n \choose m},$$ ver @hwang1971optimal.</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>De manera más detallada, supongamos que $A \cap B = \emptyset$, esto es, el conjunto de salida será de tamaño $m+n$. De manera similar al razonamiento que se utilizó para el problema de ordenamiento, el problema puede verse como todas las posibles instancias de ordenes o permutaciones de tamaño $n+m$; removiendo la necesidad de los ordenes parciales, esto es ${n+m \choose m}$ posibles instancias de tamaño $n+m$, generadas por dos conjuntos de tamaño $n$ y $m$. Dado que estamos en un modelo basado en comparaciones, y dado el mejor algoritmo $s$ puede dividir el espacio de posibles ordenes en 2, por tanto, dicho algoritmo necesitará $$\log_2 {n+m \choose m}$$ comparaciones para resolver la unión de cualquier par de conjuntos de tamaño $m$ y $n$.</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>Usando la aproximación de Stirling para coefficientes binomiales de @mackay2003information, el costo se convierte en:</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>$$\log{m+n \choose m} = n\log{\frac{m+n}{n}} + m \log\frac{n+m}{m} $$</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>Recuerde que $\log_2 x = \frac{\log_e x}{\log e}$.</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="in"># tomados de cap5</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="in">function binarysearch(A, x, sp=1, ep=length(A))</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span class="in">    while sp &lt; ep             # &lt;3&gt;</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="in">        mid = div(sp + ep, 2) # &lt;1&gt;</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a><span class="in">        if x &lt;= A[mid]        # &lt;1&gt;</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a><span class="in">            ep = mid          # &lt;2&gt;</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a><span class="in">        else</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a><span class="in">            sp = mid + 1      # &lt;2&gt;</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="in">        end</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a><span class="in">    x &lt;= A[sp] ? sp : sp + 1 # &lt;4&gt;</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a><span class="in">function doublingsearch(A, x, sp=1)</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a><span class="in">    n = length(A)</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a><span class="in">    p = 0</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a><span class="in">    i = 1</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a><span class="in">    while sp+i &lt;= n &amp;&amp; A[sp+i] &lt; x # &lt;1&gt;</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a><span class="in">        p = i</span></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a><span class="in">        i += i</span></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a><span class="in">    binarysearch(A, x, sp + p, min(n, sp+i)) # &lt;2&gt;</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a><span class="fu">## Algoritmos</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>Se puede observar que si $m \approx n$, entonces el costo se convierte en $O(m + n)$, esto es, lo más eficiente sería tomar el siguiente algoritmo:</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a><span class="in">function merge2!(C, A, B) # &lt;1&gt;</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a><span class="in">    i = j = 1</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a><span class="in">    m, n = length(A), length(B)</span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a><span class="in">    @inbounds while i &lt;= m ||  j &lt;= n # &lt;2&gt;</span></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a><span class="in">        a, b = A[i], B[j]</span></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a><span class="in">        if a == b</span></span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a><span class="in">            push!(C, a)</span></span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a><span class="in">            i += 1</span></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a><span class="in">            j += 1</span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a><span class="in">        elseif a &lt; b</span></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a><span class="in">            push!(C, a)</span></span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a><span class="in">            i += 1</span></span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a><span class="in">        else</span></span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a><span class="in">            push!(C, b)</span></span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a><span class="in">            j += 1</span></span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a><span class="in">        end</span></span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a><span class="in">    C</span></span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a><span class="fu">### Ejercicio</span></span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Escriba y pruebe el algoritmo de intersección de merge para $n \approx m$.</span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:8 == merge2!(Int[], [1, 3, 4, 6, 8], [2, 5, 7])</span></span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 0:9 == merge2!(Int[], [1, 3, 4, 6, 8], [0, 2, 5, 7, 9])</span></span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:10 == merge2!(Int[], 1:5, 6:10)</span></span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a><span class="fu">## Algoritmos para arreglos de tamaño muy diferente</span></span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a>Si $m \ll n$, el costo tenderá a $O(m \log n)$, por lo que se pueden realizar $m$ búsquedas binarias _directas_ para localizar la posición de inserción en $B$. </span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a><span class="in">//| label: fig-interseccion</span></span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a><span class="in">//| echo: false</span></span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-width: 100%</span></span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-cap: |</span></span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a><span class="in">//|   Dos listas alineadas donde los nodos sombreados son elementos de los conjuntos.</span></span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a><span class="in">digraph lista {</span></span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a><span class="in">  //layout=neato;</span></span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a><span class="in">  rankdir=LR;</span></span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a><span class="in">  graph [pad="0.5", nodesep="0.5", ranksep="0.5"];</span></span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a><span class="in">  //{rank=same; a; b; c; nothing;}</span></span>
<span id="cb4-123"><a href="#cb4-123" aria-hidden="true" tabindex="-1"></a><span class="in">  splines="true";</span></span>
<span id="cb4-124"><a href="#cb4-124" aria-hidden="true" tabindex="-1"></a><span class="in">  //node [style="invis"];</span></span>
<span id="cb4-125"><a href="#cb4-125" aria-hidden="true" tabindex="-1"></a><span class="in">  subgraph A {</span></span>
<span id="cb4-126"><a href="#cb4-126" aria-hidden="true" tabindex="-1"></a><span class="in">    cluster=true;</span></span>
<span id="cb4-127"><a href="#cb4-127" aria-hidden="true" tabindex="-1"></a><span class="in">    a1 [label="1"];</span></span>
<span id="cb4-128"><a href="#cb4-128" aria-hidden="true" tabindex="-1"></a><span class="in">    a2 [label="2", style="filled"];</span></span>
<span id="cb4-129"><a href="#cb4-129" aria-hidden="true" tabindex="-1"></a><span class="in">    a3 [label="3"];</span></span>
<span id="cb4-130"><a href="#cb4-130" aria-hidden="true" tabindex="-1"></a><span class="in">    a4 [label="4"];</span></span>
<span id="cb4-131"><a href="#cb4-131" aria-hidden="true" tabindex="-1"></a><span class="in">    a5 [label="5", style="filled"];</span></span>
<span id="cb4-132"><a href="#cb4-132" aria-hidden="true" tabindex="-1"></a><span class="in">    a6 [label="6"];</span></span>
<span id="cb4-133"><a href="#cb4-133" aria-hidden="true" tabindex="-1"></a><span class="in">    a7 [label="7", style="filled"];</span></span>
<span id="cb4-134"><a href="#cb4-134" aria-hidden="true" tabindex="-1"></a><span class="in">    a8 [label="8"];</span></span>
<span id="cb4-135"><a href="#cb4-135" aria-hidden="true" tabindex="-1"></a><span class="in">    a9 [label="9"];</span></span>
<span id="cb4-136"><a href="#cb4-136" aria-hidden="true" tabindex="-1"></a><span class="in">    a10 [label="10"];</span></span>
<span id="cb4-137"><a href="#cb4-137" aria-hidden="true" tabindex="-1"></a><span class="in">    a11 [label="11"];</span></span>
<span id="cb4-138"><a href="#cb4-138" aria-hidden="true" tabindex="-1"></a><span class="in">    a12 [label="12"];</span></span>
<span id="cb4-139"><a href="#cb4-139" aria-hidden="true" tabindex="-1"></a><span class="in">    a13 [label="13"];</span></span>
<span id="cb4-140"><a href="#cb4-140" aria-hidden="true" tabindex="-1"></a><span class="in">    a15 [label="15", style="filled"];</span></span>
<span id="cb4-141"><a href="#cb4-141" aria-hidden="true" tabindex="-1"></a><span class="in">    a16 [label="16"];</span></span>
<span id="cb4-142"><a href="#cb4-142" aria-hidden="true" tabindex="-1"></a><span class="in">  } </span></span>
<span id="cb4-143"><a href="#cb4-143" aria-hidden="true" tabindex="-1"></a><span class="in"> subgraph B {</span></span>
<span id="cb4-144"><a href="#cb4-144" aria-hidden="true" tabindex="-1"></a><span class="in">    cluster=true;</span></span>
<span id="cb4-145"><a href="#cb4-145" aria-hidden="true" tabindex="-1"></a><span class="in">  1 [label="1", style="filled"];</span></span>
<span id="cb4-146"><a href="#cb4-146" aria-hidden="true" tabindex="-1"></a><span class="in">  2 [label="2"];</span></span>
<span id="cb4-147"><a href="#cb4-147" aria-hidden="true" tabindex="-1"></a><span class="in">  3 [label="3"];</span></span>
<span id="cb4-148"><a href="#cb4-148" aria-hidden="true" tabindex="-1"></a><span class="in">  4 [label="4"];</span></span>
<span id="cb4-149"><a href="#cb4-149" aria-hidden="true" tabindex="-1"></a><span class="in">  5 [label="5", style="filled"];</span></span>
<span id="cb4-150"><a href="#cb4-150" aria-hidden="true" tabindex="-1"></a><span class="in">  6 [label="6"];</span></span>
<span id="cb4-151"><a href="#cb4-151" aria-hidden="true" tabindex="-1"></a><span class="in">  7 [label="7", style="filled"];</span></span>
<span id="cb4-152"><a href="#cb4-152" aria-hidden="true" tabindex="-1"></a><span class="in">  8 [label="8"];</span></span>
<span id="cb4-153"><a href="#cb4-153" aria-hidden="true" tabindex="-1"></a><span class="in">  9 [label="9"];</span></span>
<span id="cb4-154"><a href="#cb4-154" aria-hidden="true" tabindex="-1"></a><span class="in">  10 [label="10", style="filled"];</span></span>
<span id="cb4-155"><a href="#cb4-155" aria-hidden="true" tabindex="-1"></a><span class="in">  11 [label="11"];</span></span>
<span id="cb4-156"><a href="#cb4-156" aria-hidden="true" tabindex="-1"></a><span class="in">  12 [label="12", style="filled"];</span></span>
<span id="cb4-157"><a href="#cb4-157" aria-hidden="true" tabindex="-1"></a><span class="in">  13 [label="13"];</span></span>
<span id="cb4-158"><a href="#cb4-158" aria-hidden="true" tabindex="-1"></a><span class="in">  15 [label="15", style="filled"];</span></span>
<span id="cb4-159"><a href="#cb4-159" aria-hidden="true" tabindex="-1"></a><span class="in">  16 [label="16"];</span></span>
<span id="cb4-160"><a href="#cb4-160" aria-hidden="true" tabindex="-1"></a><span class="in"> }</span></span>
<span id="cb4-161"><a href="#cb4-161" aria-hidden="true" tabindex="-1"></a><span class="in">  edge [style="invis"];</span></span>
<span id="cb4-162"><a href="#cb4-162" aria-hidden="true" tabindex="-1"></a><span class="in">  1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 15 -&gt; 16[weight=30];</span></span>
<span id="cb4-163"><a href="#cb4-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-164"><a href="#cb4-164" aria-hidden="true" tabindex="-1"></a><span class="in">  a1 -&gt; a2 -&gt; a3 -&gt; a4 -&gt; a5 -&gt; a6 -&gt; a7 -&gt; a8 -&gt; a9 -&gt; a10 -&gt; a11 -&gt; a12 -&gt; a13 -&gt; a15 -&gt; a16 [weight=30];</span></span>
<span id="cb4-165"><a href="#cb4-165" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb4-166"><a href="#cb4-166" aria-hidden="true" tabindex="-1"></a><span class="in">  //A -&gt; B</span></span>
<span id="cb4-167"><a href="#cb4-167" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb4-168"><a href="#cb4-168" aria-hidden="true" tabindex="-1"></a><span class="in">  //edge [style=""];</span></span>
<span id="cb4-169"><a href="#cb4-169" aria-hidden="true" tabindex="-1"></a><span class="in">  //5 -&gt; a5 [weight=0];</span></span>
<span id="cb4-170"><a href="#cb4-170" aria-hidden="true" tabindex="-1"></a><span class="in">  //7 -&gt; a7 [weight=0];</span></span>
<span id="cb4-171"><a href="#cb4-171" aria-hidden="true" tabindex="-1"></a><span class="in">  //15 -&gt; a15 [weight=0];</span></span>
<span id="cb4-172"><a href="#cb4-172" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb4-173"><a href="#cb4-173" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-174"><a href="#cb4-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-175"><a href="#cb4-175" aria-hidden="true" tabindex="-1"></a>Se hace notar que $A$ y $B$ estan ordenados, y por lo tanto, localizar $A<span class="co">[</span><span class="ot">i</span><span class="co">]</span>$ en $B<span class="co">[</span><span class="ot">j</span><span class="co">]</span>$ significa que $B<span class="co">[</span><span class="ot">j-1</span><span class="co">]</span> &lt; A<span class="co">[</span><span class="ot">i</span><span class="co">]</span>$, por lo que intentar localizar $A<span class="co">[</span><span class="ot">i+1</span><span class="co">]</span>$ puede comenzar en $B<span class="co">[</span><span class="ot">j+1</span><span class="co">]</span>$. A continuación se muestra el código de un algoritmo de intersección usando algoritmos de búsqueda con memoria de la posición anterior.</span>
<span id="cb4-176"><a href="#cb4-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-179"><a href="#cb4-179" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-180"><a href="#cb4-180" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-181"><a href="#cb4-181" aria-hidden="true" tabindex="-1"></a><span class="in">function intsearch!(C, A, B, algosearch=doublingsearch)</span></span>
<span id="cb4-182"><a href="#cb4-182" aria-hidden="true" tabindex="-1"></a><span class="in">    if length(B) &lt; length(A)</span></span>
<span id="cb4-183"><a href="#cb4-183" aria-hidden="true" tabindex="-1"></a><span class="in">        A, B = B, A</span></span>
<span id="cb4-184"><a href="#cb4-184" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb4-185"><a href="#cb4-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-186"><a href="#cb4-186" aria-hidden="true" tabindex="-1"></a><span class="in">    p = 1</span></span>
<span id="cb4-187"><a href="#cb4-187" aria-hidden="true" tabindex="-1"></a><span class="in">    for (i, a) in enumerate(A)</span></span>
<span id="cb4-188"><a href="#cb4-188" aria-hidden="true" tabindex="-1"></a><span class="in">        p = algosearch(B, a, p)</span></span>
<span id="cb4-189"><a href="#cb4-189" aria-hidden="true" tabindex="-1"></a><span class="in">        p &gt; length(B) &amp;&amp; break</span></span>
<span id="cb4-190"><a href="#cb4-190" aria-hidden="true" tabindex="-1"></a><span class="in">        if a == B[p]</span></span>
<span id="cb4-191"><a href="#cb4-191" aria-hidden="true" tabindex="-1"></a><span class="in">            p += 1</span></span>
<span id="cb4-192"><a href="#cb4-192" aria-hidden="true" tabindex="-1"></a><span class="in">            push!(C, a)</span></span>
<span id="cb4-193"><a href="#cb4-193" aria-hidden="true" tabindex="-1"></a><span class="in">        end</span></span>
<span id="cb4-194"><a href="#cb4-194" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb4-195"><a href="#cb4-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-196"><a href="#cb4-196" aria-hidden="true" tabindex="-1"></a><span class="in">    C</span></span>
<span id="cb4-197"><a href="#cb4-197" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb4-198"><a href="#cb4-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-199"><a href="#cb4-199" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-200"><a href="#cb4-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-203"><a href="#cb4-203" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-204"><a href="#cb4-204" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-205"><a href="#cb4-205" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb4-206"><a href="#cb4-206" aria-hidden="true" tabindex="-1"></a><span class="in">@assert [4, 6] == intsearch!(Int[], [1, 3, 4, 6, 8], [2, 4, 5, 6, 7])</span></span>
<span id="cb4-207"><a href="#cb4-207" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:5 == intsearch!(Int[], 1:10, 1:5)</span></span>
<span id="cb4-208"><a href="#cb4-208" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:9 == intsearch!(Int[], 0:10, 1:9)</span></span>
<span id="cb4-209"><a href="#cb4-209" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:2:9 == intsearch!(Int[], 0:10, 1:2:9)</span></span>
<span id="cb4-210"><a href="#cb4-210" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-211"><a href="#cb4-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-212"><a href="#cb4-212" aria-hidden="true" tabindex="-1"></a>@hwang1971optimal propone otro algoritmo que funciona para casos similares:</span>
<span id="cb4-213"><a href="#cb4-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-214"><a href="#cb4-214" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Divide $B$ en bloques de tamaño $m$, define un arreglo _virtual_ $B'<span class="co">[</span><span class="ot">1..n/m</span><span class="co">]</span>$ donde $B'<span class="co">[</span><span class="ot">i</span><span class="co">]</span> = B<span class="co">[</span><span class="ot">i \cdot m</span><span class="co">]</span>$</span>
<span id="cb4-215"><a href="#cb4-215" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Se búsca la posición de inserción $p$ de cada $a \in A$ en $B'$, costando $\log n/m$ para cada búsqueda.</span>
<span id="cb4-216"><a href="#cb4-216" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Después se localiza dentro del $B$ en el $p$-ésimo bloque, i.e., $B<span class="co">[</span><span class="ot">(p-1)m + 1 .. p\cdot m</span><span class="co">]</span>$, por la posición de inserción del bloque, con un costo de $\log m$.</span>
<span id="cb4-217"><a href="#cb4-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-218"><a href="#cb4-218" aria-hidden="true" tabindex="-1"></a>Entonces, se obtiene un costo de $O(m \log{n/m} + m \log m)$; esto es equivalente en el peor caso a búsquedas directas, i.e., las posiciones de inserción de $a \in A$ se encuentran distribuidas de manera uniforme en $B$. Sin embargo, es posible mejorar si se descartan bloques en el paso 1. Esto es, si se hay concentración de elementos de $A$ en bloques de $B$. Para esto, es necesario un análisis de costo promedio, el cual se muestra en el artículo.</span>
<span id="cb4-219"><a href="#cb4-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-220"><a href="#cb4-220" aria-hidden="true" tabindex="-1"></a>Incluso cuando hay concentración, podemos recordar la $(i-1)$ posición de inserción para iniciar la $i$-ésima búsqueda, y sacar provecho de posiciones esperadas cercanas de la posición inicial de búsqueda, i.e., podemos utilizar algoritmos de búsqueda adaptables para mejorar el desempeño.</span>
<span id="cb4-221"><a href="#cb4-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-222"><a href="#cb4-222" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algoritmo de Baeza Yates</span></span>
<span id="cb4-223"><a href="#cb4-223" aria-hidden="true" tabindex="-1"></a>@BY2004 propone un algoritmo eficiente para intersecciones de dos conjuntos. El algoritmo tiene una estrategía _dividir para vencer_:</span>
<span id="cb4-224"><a href="#cb4-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-225"><a href="#cb4-225" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Se toma la mediana $M$ de $A$ y se busca en $B$ obteniendo su posición de inserción $p$.</span>
<span id="cb4-226"><a href="#cb4-226" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>El problema entonces se divide en 3 subproblemas:</span>
<span id="cb4-227"><a href="#cb4-227" aria-hidden="true" tabindex="-1"></a>    \begin{align}</span>
<span id="cb4-228"><a href="#cb4-228" aria-hidden="true" tabindex="-1"></a>    C_&lt; &amp;= <span class="sc">\{</span>A<span class="co">[</span><span class="ot">1..M-1</span><span class="co">]</span> \cap B<span class="co">[</span><span class="ot">1..p-e</span><span class="co">]</span><span class="sc">\}</span> <span class="sc">\\</span></span>
<span id="cb4-229"><a href="#cb4-229" aria-hidden="true" tabindex="-1"></a>    C_= &amp;= <span class="sc">\{</span>A<span class="co">[</span><span class="ot">M</span><span class="co">]</span><span class="sc">\}</span> \cap <span class="sc">\{</span>B<span class="co">[</span><span class="ot">p</span><span class="co">]</span><span class="sc">\}</span> <span class="sc">\\</span> </span>
<span id="cb4-230"><a href="#cb4-230" aria-hidden="true" tabindex="-1"></a>    C_&gt; &amp;= <span class="sc">\{</span>A<span class="co">[</span><span class="ot">M+1..m</span><span class="co">]</span> \cap B<span class="co">[</span><span class="ot">p+e..n</span><span class="co">]</span><span class="sc">\}</span> <span class="sc">\\</span></span>
<span id="cb4-231"><a href="#cb4-231" aria-hidden="true" tabindex="-1"></a>    \end{align}</span>
<span id="cb4-232"><a href="#cb4-232" aria-hidden="true" tabindex="-1"></a>  donde $e=1$ si $A<span class="co">[</span><span class="ot">M</span><span class="co">]</span> = B<span class="co">[</span><span class="ot">p</span><span class="co">]</span>$ y $e=0$ cuando $A<span class="co">[</span><span class="ot">M</span><span class="co">]</span> \not= B<span class="co">[</span><span class="ot">p</span><span class="co">]</span>$.</span>
<span id="cb4-233"><a href="#cb4-233" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>La unión de estos tres conjuntos es la solución $C_&lt; \cup C_= \cup C_&gt;$.</span>
<span id="cb4-234"><a href="#cb4-234" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>El problema $C_=$ es trivial, y $C_&lt;$ y $C_&gt;$ se implementan recurriendo, ajustando los rangos de trabajo.</span>
<span id="cb4-235"><a href="#cb4-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-236"><a href="#cb4-236" aria-hidden="true" tabindex="-1"></a>A continuación se muestra el código en Julia, usando los algoritmos de búsqueda del Cap. 5.</span>
<span id="cb4-237"><a href="#cb4-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-240"><a href="#cb4-240" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-241"><a href="#cb4-241" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-242"><a href="#cb4-242" aria-hidden="true" tabindex="-1"></a><span class="in"># Adaptado de https://github.com/sadit/Intersections.jl</span></span>
<span id="cb4-243"><a href="#cb4-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-244"><a href="#cb4-244" aria-hidden="true" tabindex="-1"></a><span class="in">function baezayates!(output, A, B, findpos::Function=binarysearch) # &lt;1&gt; </span></span>
<span id="cb4-245"><a href="#cb4-245" aria-hidden="true" tabindex="-1"></a><span class="in">    baezayates!(output, A, 1, length(A), B, 1, length(B), findpos)</span></span>
<span id="cb4-246"><a href="#cb4-246" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb4-247"><a href="#cb4-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-248"><a href="#cb4-248" aria-hidden="true" tabindex="-1"></a><span class="in">function baezayates!(output, A, a_sp::Int, a_ep::Int, B, b_sp::Int, b_ep::Int, findpos::Function)</span></span>
<span id="cb4-249"><a href="#cb4-249" aria-hidden="true" tabindex="-1"></a><span class="in">    (a_ep &lt; a_sp || b_ep &lt; b_sp) &amp;&amp; return output</span></span>
<span id="cb4-250"><a href="#cb4-250" aria-hidden="true" tabindex="-1"></a><span class="in">    imedian = ceil(Int, (a_ep + a_sp) / 2)</span></span>
<span id="cb4-251"><a href="#cb4-251" aria-hidden="true" tabindex="-1"></a><span class="in">    median = A[imedian]</span></span>
<span id="cb4-252"><a href="#cb4-252" aria-hidden="true" tabindex="-1"></a><span class="in">    ## our findpos returns n + 1 when median is larger than B[end]</span></span>
<span id="cb4-253"><a href="#cb4-253" aria-hidden="true" tabindex="-1"></a><span class="in">    medpos = min(findpos(B, median, b_sp), b_ep)  # &lt;2&gt;</span></span>
<span id="cb4-254"><a href="#cb4-254" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb4-255"><a href="#cb4-255" aria-hidden="true" tabindex="-1"></a><span class="in">    matches = median == B[medpos] </span></span>
<span id="cb4-256"><a href="#cb4-256" aria-hidden="true" tabindex="-1"></a><span class="in">    baezayates!(output, A, a_sp, imedian - 1, B, b_sp, medpos - matches, findpos) # &lt;3&gt;</span></span>
<span id="cb4-257"><a href="#cb4-257" aria-hidden="true" tabindex="-1"></a><span class="in">    matches &amp;&amp; push!(output, median) # &lt;4&gt;</span></span>
<span id="cb4-258"><a href="#cb4-258" aria-hidden="true" tabindex="-1"></a><span class="in">    baezayates!(output, A, imedian + 1, a_ep, B, medpos + matches, b_ep, findpos) # &lt;5&gt;</span></span>
<span id="cb4-259"><a href="#cb4-259" aria-hidden="true" tabindex="-1"></a><span class="in">    output</span></span>
<span id="cb4-260"><a href="#cb4-260" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb4-261"><a href="#cb4-261" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-262"><a href="#cb4-262" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Punto de entrada.</span>
<span id="cb4-263"><a href="#cb4-263" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Búsqueda de la posición de inserción de la mediana de $A$ en $B$.</span>
<span id="cb4-264"><a href="#cb4-264" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Recurrencia para el problema $C_&lt;$.</span>
<span id="cb4-265"><a href="#cb4-265" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Añadir al resultado el valor de la mediana si es que se encontró en $B$; es importante que este paso este entre las recurrencias para que _output_ sea un arreglo ordenado.</span>
<span id="cb4-266"><a href="#cb4-266" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Recurencia para el problema $C_&gt;$.</span>
<span id="cb4-267"><a href="#cb4-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-268"><a href="#cb4-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-271"><a href="#cb4-271" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-272"><a href="#cb4-272" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-273"><a href="#cb4-273" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb4-274"><a href="#cb4-274" aria-hidden="true" tabindex="-1"></a><span class="in">@assert [4, 6] == baezayates!(Int[], [1, 3, 4, 6, 8], [2, 4, 5, 6, 7])</span></span>
<span id="cb4-275"><a href="#cb4-275" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:5 == baezayates!(Int[], 1:10, 1:5)</span></span>
<span id="cb4-276"><a href="#cb4-276" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:9 == baezayates!(Int[], 0:10, 1:9)</span></span>
<span id="cb4-277"><a href="#cb4-277" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:2:9 == baezayates!(Int[], 0:10, 1:2:9)</span></span>
<span id="cb4-278"><a href="#cb4-278" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-279"><a href="#cb4-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-280"><a href="#cb4-280" aria-hidden="true" tabindex="-1"></a>El algoritmo de Baeza Yates es óptimo en el peor caso y es capaz de aprovechar casos donde $C_&lt;$ o $C_&gt;$ se convierten en triviales, lo cual da muy buenos casos en algunas distribuciones.</span>
<span id="cb4-281"><a href="#cb4-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-282"><a href="#cb4-282" aria-hidden="true" tabindex="-1"></a><span class="fu">### Ejercicios</span></span>
<span id="cb4-283"><a href="#cb4-283" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Implemente la unión con el algoritmo de Baeza Yates.</span>
<span id="cb4-284"><a href="#cb4-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-285"><a href="#cb4-285" aria-hidden="true" tabindex="-1"></a><span class="fu">## Operaciones con tres o más conjuntos</span></span>
<span id="cb4-286"><a href="#cb4-286" aria-hidden="true" tabindex="-1"></a>Los algoritmos y costos hasta ahora revisados se cumplen para dos conjuntos; se mencionaron diferentes algoritmos, algunos de ellos especializados por características como las proporciones de los conjuntos de entrada. </span>
<span id="cb4-287"><a href="#cb4-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-288"><a href="#cb4-288" aria-hidden="true" tabindex="-1"></a>En particular, es importante hacer notar que ni el problema ni las aplicaciones estan limitadas a dos conjuntos, y por tanto, es importante algoritmos y estrategías para resolver $\bigcup_i A_i$ así como $\bigcap_i A_i$.</span>
<span id="cb4-289"><a href="#cb4-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-290"><a href="#cb4-290" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algoritmo SvS</span></span>
<span id="cb4-291"><a href="#cb4-291" aria-hidden="true" tabindex="-1"></a>Dado $C = A \cap B$ es un hecho que $|C| \leq min <span class="sc">\{</span>|A|, |B|<span class="sc">\}</span>$. Recordando, que hay maneras relativamente simples y eficientes de resolver la intersección cuando $m \ll n$; por tanto, cuando tenemos más de dos conjuntos podemos aplicar la estrategía _Small vs Small (SvS)_, que consisten en intersectar los $k$ conjuntos por pares intersectando el par de arreglos más pequeños cada vez.</span>
<span id="cb4-292"><a href="#cb4-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-295"><a href="#cb4-295" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-296"><a href="#cb4-296" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-297"><a href="#cb4-297" aria-hidden="true" tabindex="-1"></a><span class="in"># Adaptado de https://github.com/sadit/Intersections.jl</span></span>
<span id="cb4-298"><a href="#cb4-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-299"><a href="#cb4-299" aria-hidden="true" tabindex="-1"></a><span class="in">function svs(L::Vector{T}, in2::Function=baezayates!) where T</span></span>
<span id="cb4-300"><a href="#cb4-300" aria-hidden="true" tabindex="-1"></a><span class="in">    prev, curr = eltype(T)[], eltype(T)[]</span></span>
<span id="cb4-301"><a href="#cb4-301" aria-hidden="true" tabindex="-1"></a><span class="in">    sort!(L, by=length, rev=true)</span></span>
<span id="cb4-302"><a href="#cb4-302" aria-hidden="true" tabindex="-1"></a><span class="in">    curr = pop!(L)</span></span>
<span id="cb4-303"><a href="#cb4-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-304"><a href="#cb4-304" aria-hidden="true" tabindex="-1"></a><span class="in">    while length(L) &gt; 0</span></span>
<span id="cb4-305"><a href="#cb4-305" aria-hidden="true" tabindex="-1"></a><span class="in">        empty!(prev)</span></span>
<span id="cb4-306"><a href="#cb4-306" aria-hidden="true" tabindex="-1"></a><span class="in">        isize = in2(prev, curr, pop!(L))</span></span>
<span id="cb4-307"><a href="#cb4-307" aria-hidden="true" tabindex="-1"></a><span class="in">        isize == 0 &amp;&amp; return prev</span></span>
<span id="cb4-308"><a href="#cb4-308" aria-hidden="true" tabindex="-1"></a><span class="in">        prev, curr = curr, prev</span></span>
<span id="cb4-309"><a href="#cb4-309" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb4-310"><a href="#cb4-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-311"><a href="#cb4-311" aria-hidden="true" tabindex="-1"></a><span class="in">    curr</span></span>
<span id="cb4-312"><a href="#cb4-312" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb4-313"><a href="#cb4-313" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-314"><a href="#cb4-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-317"><a href="#cb4-317" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-318"><a href="#cb4-318" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-319"><a href="#cb4-319" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb4-320"><a href="#cb4-320" aria-hidden="true" tabindex="-1"></a><span class="in">@assert [4, 6] == svs([[1, 3, 4, 6, 8], [2, 4, 5, 6, 7]])</span></span>
<span id="cb4-321"><a href="#cb4-321" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:5 == svs([1:10, 1:5])</span></span>
<span id="cb4-322"><a href="#cb4-322" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:9 == svs([0:10, 1:9])</span></span>
<span id="cb4-323"><a href="#cb4-323" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:2:9 == svs([0:10, 1:2:9])</span></span>
<span id="cb4-324"><a href="#cb4-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-325"><a href="#cb4-325" aria-hidden="true" tabindex="-1"></a><span class="in">@assert [4, 6] == svs([[1, 3, 4, 6, 8], [2, 4, 5, 6, 7]], intsearch!)</span></span>
<span id="cb4-326"><a href="#cb4-326" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:5 == svs([1:10, 1:5], intsearch!)</span></span>
<span id="cb4-327"><a href="#cb4-327" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:9 == svs([0:10, 1:9], intsearch!)</span></span>
<span id="cb4-328"><a href="#cb4-328" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:2:9 == svs([0:10, 1:2:9], intsearch!)</span></span>
<span id="cb4-329"><a href="#cb4-329" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-330"><a href="#cb4-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-331"><a href="#cb4-331" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algoritmo de Barbay y Kenyon</span></span>
<span id="cb4-332"><a href="#cb4-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-333"><a href="#cb4-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-334"><a href="#cb4-334" aria-hidden="true" tabindex="-1"></a>Existe otra familia de algoritmos, basados en búsquedas adaptativas que pueden llegar a mejorar el desempeño bajo cierto tipo de entradas. @DLOPM2001, @BLOL2006, y @BLOLS2010 muestran algoritmos de intersección basados en búsqueda adaptables para aprovechar instancias simples. Estos estudios se basan en contribuciones teóricas de los mismos autores: @DLOM2000, @DLOPM2001, @BK2002 y @BY2004.</span>
<span id="cb4-335"><a href="#cb4-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-336"><a href="#cb4-336" aria-hidden="true" tabindex="-1"></a>El algoritmo de @BLOL2006 trabaja sobre los $k$ conjuntos de entrada, representados como arreglos ordenados de números enteros. Es un algoritmo simple pero poderoso: hace uso de búsquedas adaptivas con memoria para guardar las posiciones donde se avanza, de tal forma que no se recalculen posiciones. Las diferentes estrategias para revisar los conjuntos pueden dar diferentes desempeños, como se valida en @BLOLS2010, donde además de hacer una gran variedad de experimentos sobre diferentes algoritmos de búsqueda, se introducen variantes en el orden de acceso de cada conjunto.</span>
<span id="cb4-337"><a href="#cb4-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-338"><a href="#cb4-338" aria-hidden="true" tabindex="-1"></a>A continuacións se muestra el código del algoritmo base:</span>
<span id="cb4-339"><a href="#cb4-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-342"><a href="#cb4-342" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-343"><a href="#cb4-343" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-344"><a href="#cb4-344" aria-hidden="true" tabindex="-1"></a><span class="in"># Adaptado de https://github.com/sadit/Intersections.jl</span></span>
<span id="cb4-345"><a href="#cb4-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-346"><a href="#cb4-346" aria-hidden="true" tabindex="-1"></a><span class="in">function bk!(output, L::AbstractVector, findpos::Function=doublingsearch)</span></span>
<span id="cb4-347"><a href="#cb4-347" aria-hidden="true" tabindex="-1"></a><span class="in">    P = ones(Int, length(L))</span></span>
<span id="cb4-348"><a href="#cb4-348" aria-hidden="true" tabindex="-1"></a><span class="in">    bk!(output, L, P, findpos)</span></span>
<span id="cb4-349"><a href="#cb4-349" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb4-350"><a href="#cb4-350" aria-hidden="true" tabindex="-1"></a><span class="in"> </span></span>
<span id="cb4-351"><a href="#cb4-351" aria-hidden="true" tabindex="-1"></a><span class="in">function bk!(output, L, P, findpos::Function=doublingsearch)  # &lt;1&gt;</span></span>
<span id="cb4-352"><a href="#cb4-352" aria-hidden="true" tabindex="-1"></a><span class="in">    n = length(L) # &lt;2&gt;</span></span>
<span id="cb4-353"><a href="#cb4-353" aria-hidden="true" tabindex="-1"></a><span class="in">    el = L[1][1]  # &lt;3&gt;</span></span>
<span id="cb4-354"><a href="#cb4-354" aria-hidden="true" tabindex="-1"></a><span class="in">    c = 0 # &lt;4&gt;</span></span>
<span id="cb4-355"><a href="#cb4-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-356"><a href="#cb4-356" aria-hidden="true" tabindex="-1"></a><span class="in">    @inbounds while true</span></span>
<span id="cb4-357"><a href="#cb4-357" aria-hidden="true" tabindex="-1"></a><span class="in">        for i in eachindex(P)</span></span>
<span id="cb4-358"><a href="#cb4-358" aria-hidden="true" tabindex="-1"></a><span class="in">            P[i] = findpos(L[i], el, P[i])  # &lt;5&gt;</span></span>
<span id="cb4-359"><a href="#cb4-359" aria-hidden="true" tabindex="-1"></a><span class="in">            P[i] &gt; length(L[i]) &amp;&amp; return output</span></span>
<span id="cb4-360"><a href="#cb4-360" aria-hidden="true" tabindex="-1"></a><span class="in">            pval = L[i][P[i]]</span></span>
<span id="cb4-361"><a href="#cb4-361" aria-hidden="true" tabindex="-1"></a><span class="in">            if pval == el</span></span>
<span id="cb4-362"><a href="#cb4-362" aria-hidden="true" tabindex="-1"></a><span class="in">                c += 1</span></span>
<span id="cb4-363"><a href="#cb4-363" aria-hidden="true" tabindex="-1"></a><span class="in">                if c == n # &lt;6&gt;</span></span>
<span id="cb4-364"><a href="#cb4-364" aria-hidden="true" tabindex="-1"></a><span class="in">                    push!(output, el)</span></span>
<span id="cb4-365"><a href="#cb4-365" aria-hidden="true" tabindex="-1"></a><span class="in">                    c = 0  # &lt;7&gt;</span></span>
<span id="cb4-366"><a href="#cb4-366" aria-hidden="true" tabindex="-1"></a><span class="in">                    P[i] += 1 # &lt;7&gt;</span></span>
<span id="cb4-367"><a href="#cb4-367" aria-hidden="true" tabindex="-1"></a><span class="in">                    P[i] &gt; length(L[i]) &amp;&amp; return output</span></span>
<span id="cb4-368"><a href="#cb4-368" aria-hidden="true" tabindex="-1"></a><span class="in">                    el = L[i][P[i]] # &lt;7&gt;</span></span>
<span id="cb4-369"><a href="#cb4-369" aria-hidden="true" tabindex="-1"></a><span class="in">                end</span></span>
<span id="cb4-370"><a href="#cb4-370" aria-hidden="true" tabindex="-1"></a><span class="in">            else</span></span>
<span id="cb4-371"><a href="#cb4-371" aria-hidden="true" tabindex="-1"></a><span class="in">                c = 0 # &lt;7&gt;</span></span>
<span id="cb4-372"><a href="#cb4-372" aria-hidden="true" tabindex="-1"></a><span class="in">                el = pval # &lt;7&gt;</span></span>
<span id="cb4-373"><a href="#cb4-373" aria-hidden="true" tabindex="-1"></a><span class="in">            end</span></span>
<span id="cb4-374"><a href="#cb4-374" aria-hidden="true" tabindex="-1"></a><span class="in">        end</span></span>
<span id="cb4-375"><a href="#cb4-375" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb4-376"><a href="#cb4-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-377"><a href="#cb4-377" aria-hidden="true" tabindex="-1"></a><span class="in">    output</span></span>
<span id="cb4-378"><a href="#cb4-378" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb4-379"><a href="#cb4-379" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-380"><a href="#cb4-380" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>El algoritmo de Barbay &amp; Kenyon recibe: i) <span class="in">`output`</span> el conjunto de salida. ii) <span class="in">`L`</span> la lista de conjuntos (representados como arreglos ordenados). iii) <span class="in">`P`</span> arreglo de posiciones _actuales_ para cada arreglo. iv) findpos` función de búsqueda.</span>
<span id="cb4-381"><a href="#cb4-381" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Número de conjuntos en <span class="in">`L`</span>.</span>
<span id="cb4-382"><a href="#cb4-382" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span><span class="in">`el`</span> es el elemento siendo búscado en todos los arreglos. </span>
<span id="cb4-383"><a href="#cb4-383" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span><span class="in">`c`</span> número de listas que contienen <span class="in">`el`</span>.</span>
<span id="cb4-384"><a href="#cb4-384" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Búscando la posición de inserción de <span class="in">`el`</span> en <span class="in">`L[i]`</span>, comenzando en <span class="in">`P[i]`</span>.</span>
<span id="cb4-385"><a href="#cb4-385" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>Esta igualdad implica que hay interección.</span>
<span id="cb4-386"><a href="#cb4-386" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>Reiniciando <span class="in">`el`</span> y <span class="in">`c`</span> y actualizando <span class="in">`P[i]`</span>.</span>
<span id="cb4-387"><a href="#cb4-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-390"><a href="#cb4-390" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb4-391"><a href="#cb4-391" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb4-392"><a href="#cb4-392" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb4-393"><a href="#cb4-393" aria-hidden="true" tabindex="-1"></a><span class="in">@assert [4, 6] == bk!([], [[1, 3, 4, 6, 8], [2, 4, 5, 6, 7]])</span></span>
<span id="cb4-394"><a href="#cb4-394" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:5 == bk!([], [1:10, 1:5])</span></span>
<span id="cb4-395"><a href="#cb4-395" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:9 == bk!([], [0:10, 1:9])</span></span>
<span id="cb4-396"><a href="#cb4-396" aria-hidden="true" tabindex="-1"></a><span class="in">@assert 1:2:9 == bk!([], [0:10, 1:2:9])</span></span>
<span id="cb4-397"><a href="#cb4-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-398"><a href="#cb4-398" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb4-399"><a href="#cb4-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-400"><a href="#cb4-400" aria-hidden="true" tabindex="-1"></a>De manera particular, @BLOLS2010 presentan un estudio experimental sobre los algoritmos presentados en el área durante la decada de 2000 a 2010, dichos algoritmos se parametrizaron de maneras que nos permiten aprender diferentes características de cada uno de ellos, dependiendo de los algoritmos de búsqueda que usan, la arquitectura computacional donde se evalúa, y el número de conjuntos siendo procesados.</span>
<span id="cb4-401"><a href="#cb4-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-402"><a href="#cb4-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-403"><a href="#cb4-403" aria-hidden="true" tabindex="-1"></a><span class="fu">## Recursos audio-visuales de la unidad</span></span>
<span id="cb4-404"><a href="#cb4-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-405"><a href="#cb4-405" aria-hidden="true" tabindex="-1"></a>Parte 1: Algoritmos de intersección (y unión) de listas ordenadas</span>
<span id="cb4-406"><a href="#cb4-406" aria-hidden="true" tabindex="-1"></a>&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/aDYO39yi-4g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;</span>
<span id="cb4-407"><a href="#cb4-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-408"><a href="#cb4-408" aria-hidden="true" tabindex="-1"></a>Parte 2: Algoritmos de intersección y algunas aplicaciones</span>
<span id="cb4-409"><a href="#cb4-409" aria-hidden="true" tabindex="-1"></a>&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/oOd5LoVJcAs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;</span>
<span id="cb4-410"><a href="#cb4-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-411"><a href="#cb4-411" aria-hidden="true" tabindex="-1"></a><span class="fu">## Actividades</span></span>
<span id="cb4-412"><a href="#cb4-412" aria-hidden="true" tabindex="-1"></a>Implementación y comparación de diferentes algoritmos de intersección de conjuntos.</span>
<span id="cb4-413"><a href="#cb4-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-414"><a href="#cb4-414" aria-hidden="true" tabindex="-1"></a>Lea cuidadosamente las instrucciones y desarrolle las actividades. Entregue el reporte correspondiente en tiempo.</span>
<span id="cb4-415"><a href="#cb4-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-416"><a href="#cb4-416" aria-hidden="true" tabindex="-1"></a></span>
</code><button title="Copiar al portapapeles" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" class="img-fluid"></a> <br> Esta obra está bajo una <a href="http://creativecommons.org/licenses/by-sa/4.0/">Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional</a></p>
</div>
  </div>
</footer>




</body></html>