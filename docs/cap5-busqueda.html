<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es-MX" xml:lang="es-MX"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>5&nbsp; Algoritmos de búsqueda en el modelo de comparación – Curso Introductorio al Análisis de Algoritmos con Julia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./cap6-intersecciones.html" rel="next">
<link href="./cap4-ordenamiento.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-68c8bffd90dad8f2b55c52d7b6410dc0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-aa5541670ca7bdc719d689fd730b675f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No se han encontrado resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./cap5-busqueda.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Algoritmos de búsqueda en el modelo de comparación</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><span id="sec-busqueda" class="quarto-section-identifier"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Algoritmos de búsqueda en el modelo de comparación</span></span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Código</button></div></div>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Curso Introductorio al Análisis de Algoritmos con Julia</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/sadit/ALGO-IR" title="Ejecutar el código" class="quarto-navigation-tool px-1" aria-label="Ejecutar el código"><i class="bi bi-github"></i></a>
    <a href="./Curso-Introductorio-al-Análisis-de-Algoritmos-con-Julia.pdf" title="Descargar PDF" class="quarto-navigation-tool px-1" aria-label="Descargar PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefacio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap1-julia.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Julia como lenguaje de programación para un curso de algoritmos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap2-analisis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introducción al análisis de algoritmos con Julia</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap3-estructuras.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Estructuras de datos elementales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap4-ordenamiento.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Algoritmos de ordenamiento</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap5-busqueda.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Algoritmos de búsqueda en el modelo de comparación</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap6-intersecciones.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Algoritmos de intersección y unión de conjuntos en el modelo de comparación</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./refs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Apéndices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Alternar sección">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./galeria-actividades.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Galería de actividades MCDI</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#objetivo" id="toc-objetivo" class="nav-link active" data-scroll-target="#objetivo">Objetivo</a></li>
  <li><a href="#problema" id="toc-problema" class="nav-link" data-scroll-target="#problema"><span class="header-section-number">5.1</span> Problema</a>
  <ul class="collapse">
  <li><a href="#costo-de-peor-caso" id="toc-costo-de-peor-caso" class="nav-link" data-scroll-target="#costo-de-peor-caso"><span class="header-section-number">5.1.1</span> Costo de peor caso</a></li>
  </ul></li>
  <li><a href="#búsqueda-no-acotada" id="toc-búsqueda-no-acotada" class="nav-link" data-scroll-target="#búsqueda-no-acotada"><span class="header-section-number">5.2</span> Búsqueda <em>no</em> acotada</a>
  <ul class="collapse">
  <li><a href="#algoritmo-b_0-búsqueda-unaría" id="toc-algoritmo-b_0-búsqueda-unaría" class="nav-link" data-scroll-target="#algoritmo-b_0-búsqueda-unaría"><span class="header-section-number">5.2.1</span> Algoritmo <span class="math inline">\(B_0\)</span> (búsqueda unaría)</a></li>
  <li><a href="#algoritmo-b_1-búsqueda-doblada-doubling-searchgalloping" id="toc-algoritmo-b_1-búsqueda-doblada-doubling-searchgalloping" class="nav-link" data-scroll-target="#algoritmo-b_1-búsqueda-doblada-doubling-searchgalloping"><span class="header-section-number">5.2.2</span> Algoritmo <span class="math inline">\(B_1\)</span> (búsqueda doblada: <em>doubling search/galloping</em>)</a></li>
  <li><a href="#algoritmo-b_2-búsqueda-doblemente-doblada-doubling-doubling-search" id="toc-algoritmo-b_2-búsqueda-doblemente-doblada-doubling-doubling-search" class="nav-link" data-scroll-target="#algoritmo-b_2-búsqueda-doblemente-doblada-doubling-doubling-search"><span class="header-section-number">5.2.3</span> Algoritmo <span class="math inline">\(B_2\)</span> (búsqueda doblemente doblada, <em>doubling-doubling search</em>)</a></li>
  <li><a href="#algoritmo-b_k" id="toc-algoritmo-b_k" class="nav-link" data-scroll-target="#algoritmo-b_k"><span class="header-section-number">5.2.4</span> Algoritmo <span class="math inline">\(B_k\)</span></a></li>
  </ul></li>
  <li><a href="#ejercicios" id="toc-ejercicios" class="nav-link" data-scroll-target="#ejercicios"><span class="header-section-number">5.3</span> Ejercicios</a></li>
  <li><a href="#material-audio-visual" id="toc-material-audio-visual" class="nav-link" data-scroll-target="#material-audio-visual"><span class="header-section-number">5.4</span> Material audio-visual</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<section id="objetivo" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="objetivo">Objetivo</h2>
<p>Analizar algoritmos de búsqueda en arreglos ordenados basados en funciones de comparación, con el objetivo de localizar elementos y posiciones específicas, usando técnicas de peor caso y adaptables a la distribución de los datos para una solución eficiente de problemas informáticos.</p>
</section>
<section id="problema" class="level2 page-columns page-full" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="problema"><span class="header-section-number">5.1</span> Problema</h2>
<p>Sea <span class="math inline">\(A[1..n] = a_1, \cdots, a_n\)</span> un arreglo ordenado con <span class="math inline">\(n \geq 1\)</span> y un operador <span class="math inline">\(&lt;\)</span> (menor que); por simplicidad, también usaremos <span class="math inline">\(\leq\)</span> (menor o igual que). Supondremos que no hay elementos duplicados en <span class="math inline">\(A\)</span>, note que esto no implica una perdida de generalidad.</p>
<p>La tarea será: dado el valor <span class="math inline">\(x\)</span> a ser localizado en <span class="math inline">\(A\)</span>, el problema consiste en determinar la posición de inserción <span class="math inline">\(p\)</span> tal que suceda alguna de las siguientes condiciones:</p>
<ul>
<li>si <span class="math inline">\(p = 1\)</span> entonces <span class="math inline">\(x \leq A[p]\)</span>.</li>
<li>si <span class="math inline">\(2 \leq p \leq n\)</span> entonces <span class="math inline">\(A[p-1] &lt; x \leq A[p]\)</span>.</li>
<li>si <span class="math inline">\(p=n+1\)</span> entonces <span class="math inline">\(A[n] &lt; x\)</span>.</li>
</ul>
<section id="costo-de-peor-caso" class="level3 page-columns page-full" data-number="5.1.1">
<h3 data-number="5.1.1" class="anchored" data-anchor-id="costo-de-peor-caso"><span class="header-section-number">5.1.1</span> Costo de peor caso</h3>
<p>Para <span class="math inline">\(A[1..n]\)</span> y el valor <span class="math inline">\(x\)</span> a localizar su posición de inserción, el resultado puede ser cualquiera de las <span class="math inline">\(n+1\)</span> posiciones posibles, i.e., instancias del problema. Un algoritmo naïve utilizaría <span class="math inline">\(n\)</span> comparaciones para resolverlo.</p>
<div id="2" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="st">    seqsearch(A, x, sp=1)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="st">Búsqueda exhaustiva con inicio</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">seqsearch</span>(A, x, sp<span class="op">=</span><span class="fl">1</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">length</span>(A)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> sp <span class="op">&lt;=</span> n <span class="op">&amp;&amp;</span> x <span class="op">&gt;</span> A[sp]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        sp <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    sp</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> S<span class="op">=</span>[<span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">30</span>, <span class="fl">40</span>, <span class="fl">50</span>, <span class="fl">60</span>, <span class="fl">70</span>]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">seqsearch</span>(S, <span class="fl">0</span>), <span class="fu">seqsearch</span>(S, <span class="fl">69</span>), <span class="fu">seqsearch</span>(S, <span class="fl">70</span>), <span class="fu">seqsearch</span>(S, <span class="fl">71</span>))</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>(1, 7, 7, 8)</code></pre>
</div>
</div>
<p>Sin embargo, dado que el arreglo esta ordenado y no hay duplicados, se puede mejorar mucho el tiempo de búsqueda.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Si se permiten duplicados se pueden mejorar muchos los tiempos; sobre todo si podemos preprocesar el arreglo, i.e., para determinar las zonas con duplicados.</p>
</div></div><p>El costo de búsqueda para cualquier instancia es <span class="math inline">\(O(\log n)\)</span>, y viene de la búsqueda binaria:</p>
<div id="4" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-2"><pre class="sourceCode julia code-annotation-code code-with-copy code-annotated"><code class="sourceCode julia"><span id="annotated-cell-2-1"><a href="#annotated-cell-2-1" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="annotated-cell-2-2"><a href="#annotated-cell-2-2" aria-hidden="true" tabindex="-1"></a><span class="st">    binarysearch(A, x, sp=1, ep=length(A))</span></span>
<span id="annotated-cell-2-3"><a href="#annotated-cell-2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-4"><a href="#annotated-cell-2-4" aria-hidden="true" tabindex="-1"></a><span class="st">Encuentra la posición de inserción de `x` en `A` en el rango `sp:ep`</span></span>
<span id="annotated-cell-2-5"><a href="#annotated-cell-2-5" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="annotated-cell-2-6"><a href="#annotated-cell-2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">binarysearch</span>(A, x, sp<span class="op">=</span><span class="fl">1</span>, ep<span class="op">=</span><span class="fu">length</span>(A))</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-2-7" class="code-annotation-target"><a href="#annotated-cell-2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> sp <span class="op">&lt;</span> ep</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-2-8" class="code-annotation-target"><a href="#annotated-cell-2-8" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> <span class="fu">div</span>(sp <span class="op">+</span> ep, <span class="fl">2</span>)</span>
<span id="annotated-cell-2-9"><a href="#annotated-cell-2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">&lt;=</span> A[mid]</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-2-10" class="code-annotation-target"><a href="#annotated-cell-2-10" aria-hidden="true" tabindex="-1"></a>            ep <span class="op">=</span> mid</span>
<span id="annotated-cell-2-11"><a href="#annotated-cell-2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="annotated-cell-2-12"><a href="#annotated-cell-2-12" aria-hidden="true" tabindex="-1"></a>            sp <span class="op">=</span> mid <span class="op">+</span> <span class="fl">1</span></span>
<span id="annotated-cell-2-13"><a href="#annotated-cell-2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="annotated-cell-2-14"><a href="#annotated-cell-2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="annotated-cell-2-15"><a href="#annotated-cell-2-15" aria-hidden="true" tabindex="-1"></a>    </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-2-16" class="code-annotation-target"><a href="#annotated-cell-2-16" aria-hidden="true" tabindex="-1"></a>    x <span class="op">&lt;=</span> A[sp] ? sp <span class="op">:</span> sp <span class="op">+</span> <span class="fl">1</span></span>
<span id="annotated-cell-2-17"><a href="#annotated-cell-2-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="annotated-cell-2-18"><a href="#annotated-cell-2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-19"><a href="#annotated-cell-2-19" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> S<span class="op">=</span>[<span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">30</span>, <span class="fl">40</span>, <span class="fl">50</span>, <span class="fl">60</span>, <span class="fl">70</span>]</span>
<span id="annotated-cell-2-20"><a href="#annotated-cell-2-20" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">binarysearch</span>(S, <span class="fl">0</span>), <span class="fu">binarysearch</span>(S, <span class="fl">69</span>), <span class="fu">binarysearch</span>(S, <span class="fl">70</span>), <span class="fu">binarysearch</span>(S, <span class="fl">71</span>))</span>
<span id="annotated-cell-2-21"><a href="#annotated-cell-2-21" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-2" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="8,9" data-code-annotation="1">Para el rango de búsqueda <span class="math inline">\(sp:ep\)</span> se determina su punto central <span class="math inline">\(mid\)</span> y se compara con <span class="math inline">\(x\)</span>,</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="10,12" data-code-annotation="2">Si el elemento <span class="math inline">\(x\)</span> esta a la izquierda, se ajusta el limite superior <span class="math inline">\(ep,\)</span> o de lo contrario se ajusta <span class="math inline">\(sp\)</span>. Ambos ajustes se hacen tomando en cuenta la posición comparada.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="7" data-code-annotation="3">Se itera mientras no se junten los dos extremos del rango.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="16" data-code-annotation="4">Finalmente, se ajusta para valores fuera del rango.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>(1, 7, 7, 8)</code></pre>
</div>
</div>
<p>Este algoritmo es simple y efectivo, y es capaz de resolver cualquier instancia en tiempo logarítmico, y esto lo hace al dividir el rango siempre a la mitad por cada iteración. El costo de búsqueda binaria es de <span class="math inline">\(C_\text{bin}(n) = \lfloor \log n \rfloor + O(1)\)</span> comparaciones antes de colapsar el rango donde puede estar la posición de inserción.</p>
<p>Es importante hacer notar que la búsqueda binaria es muy eficiente en memoría y tiene un peor caso óptimo, ya que es idéntico al costo del problema, i.e., así lo determinamos. Si fuera posible tener probar varios puntos, i.e., <span class="math inline">\(m\)</span> segmentos en una sola operación, el costo estaría acotado en <span class="math inline">\(\lceil \log_{m} n \rceil\)</span>. Esto tiene sentido para estructuras de datos que trabajan en diferentes niveles de memoría, donde aunque las comparaciones en hardware moderno sean binarias, la diferencia entre velocidades de los diferentes niveles de memoria se puede pensar que el costo dominante es, por ejemplo, acceder a una zona de disco y obtener una decisión entre <span class="math inline">\(m-1\)</span> posibles, que particionan los rangos en <span class="math inline">\(m\)</span> divisiones.</p>
</section>
</section>
<section id="búsqueda-no-acotada" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="búsqueda-no-acotada"><span class="header-section-number">5.2</span> Búsqueda <em>no</em> acotada</h2>
<p>Cuando el tamaño del arreglo es demasiado grande, o la relación entre <span class="math inline">\(p / n\)</span> es significativamente pequeña, la búsqueda acotada no es la mejor opción. Aun cuando en la práctica el límite superior <span class="math inline">\(n\)</span> podría estar determinado, y por lo tanto, se pueden resolver búsquedas en <span class="math inline">\(O(\log n)\)</span>, es posible obtener una cota relativa a <span class="math inline">\(p\)</span>, independiente de <span class="math inline">\(n\)</span>, por lo que los casos de interés se verán beneficiados.</p>
<p>Una estrategia simple y poderosa es la siguiente:</p>
<ol type="1">
<li>Determinar un <em>buen</em> rango que contenga la respuesta.</li>
<li>Aplicar búsqueda binaria en ese rango para obtener la respuesta.</li>
</ol>
<p><span class="citation" data-cites="bentley1976almost">Bentley y Yao (<a href="refs.html#ref-bentley1976almost" role="doc-biblioref">1976</a>)</span> describen a detalle una familia de algoritmos casí óptimos para la búsqueda no acotada siguiendo la estrategía anteriormente mencionada. En particular, poniendo un enfásis importante en la determinación del rango. Lo consigue mediante la definición de algoritmos definidos de manera interesante como sigue en el resto de la sección.</p>
<section id="algoritmo-b_0-búsqueda-unaría" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="algoritmo-b_0-búsqueda-unaría"><span class="header-section-number">5.2.1</span> Algoritmo <span class="math inline">\(B_0\)</span> (búsqueda unaría)</h3>
<p>Es el algoritmo más simple, y ya lo vimos con anterioridad, realiza una búsqueda exhaustiva de la posición de inserción, hacendo pruebas para toda posición <span class="math inline">\(x \leq A[1], x \leq A[2], \cdots, x \leq A[p+1]\)</span>, por lo que su costo será de <span class="math inline">\(p+1\)</span>.</p>
<p>Sea <span class="math inline">\(F_0(n)\)</span> una secuencia de puntos para un arreglo de longitud <span class="math inline">\(n\)</span>, donde se harán comparaciones para determinar el rango que contenga la respuesta para el algoritmo <span class="math inline">\(B_0\)</span> y <span class="math inline">\(C_0(p)\)</span> el costo de búsqueda. Entonces:</p>
<ul>
<li><span class="math inline">\(F_0(n) = 1, 2, \cdots, n, n+1\)</span>.</li>
<li><span class="math inline">\(C_0(p) = p+1\)</span>; no requiere búsqueda binaria.</li>
</ul>
</section>
<section id="algoritmo-b_1-búsqueda-doblada-doubling-searchgalloping" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="algoritmo-b_1-búsqueda-doblada-doubling-searchgalloping"><span class="header-section-number">5.2.2</span> Algoritmo <span class="math inline">\(B_1\)</span> (búsqueda doblada: <em>doubling search/galloping</em>)</h3>
<p>Consiste en comparar las posiciones <span class="math inline">\(2^i\)</span>, i.e., <span class="math inline">\(2^1, 2^2, 2^3, \cdots, 2^{\lfloor \log_2{p+1} \rfloor + 1}\)</span>, tal que <span class="math inline">\(A[2^{\lfloor\log_2{p}\rfloor+1}] \leq  x \leq A[2^{\lfloor\log_2{p+1}\rfloor+1}]\)</span>. De manera similar que para <span class="math inline">\(B_0\)</span> definimos <span class="math inline">\(F_1(n)\)</span> y <span class="math inline">\(C_1\)</span>:</p>
<ul>
<li><span class="math inline">\(F_1(n) = 2^1, 2^2, \cdots, 2^{\log \lfloor n \rfloor + 1};\)</span></li>
<li><span class="math inline">\(C_1(p) = C_\text{bin}{(2^{\log_2{p+1}})} + \log_2{(p+1)} + 1 &lt; 2\log_2 p + O(1).\)</span></li>
</ul>
<p>La explicación viene a continuación. El número de comparaciones para determinar el rango esta determinado por <span class="math inline">\(\lfloor \log_2{p+1} \rfloor + 1\)</span>. Una vez determinado el rango la búsqueda binaria sobre <span class="math display">\[A[2^{\lfloor\log_2{p}\rfloor+1}:2^{\lfloor\log_2{(p+1)}\rfloor+1}],\]</span> lo cual corresponde a <span class="math inline">\(\log_2 2^{\log{(p+1)}+1}/2 = \log_2{(p+1)}\)</span>. El costo <span class="math inline">\(C_1(p)\)</span> puede ser escrito como <span class="math inline">\(2\log_2 p + O(1)\)</span>, con un poco de manipulación algebraica.</p>
<p>Es importante saber cuando usar un algoritmo u otro, por tanto determinar cuando <span class="math inline">\(2\log_2{p} + O(1) &lt; \log_2 n + O(1).\)</span> Para simplificar este análisis ignoraremos algunos detalles de la expresión: <span class="math display">\[\begin{align}
2\log_2{p} &amp; &lt; \log_2 n, \\
2^{\log_2{p^2}} &amp; &lt; 2^{\log_2 n}, \\
p^2              &amp; &lt;  n, \\
p               &amp; &lt;  \sqrt{n}; \\
\end{align}\]</span> esto indica que si <span class="math inline">\(p\)</span> es menor a <span class="math inline">\(\sqrt{n}\)</span> entonces hay una ventaja al usar <span class="math inline">\(B_1\)</span>; lo cual nos dice que para posiciones cercanas al inicio el uso de <span class="math inline">\(B_1\)</span> puede llevar a búsquedas más veloces. Note que en la práctica es necesario tener en cuenta la memoria, interesantemente, para <span class="math inline">\(p\)</span> pequeñas es posible que esto beneficie al algoritmo ya que podría mantener las listas en cache.</p>
<p>El siguiente código implementa <span class="math inline">\(B_1\)</span></p>
<div id="6" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode julia code-annotation-code code-with-copy code-annotated"><code class="sourceCode julia"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">doublingsearch</span>(A, x, sp<span class="op">=</span><span class="fl">1</span>)</span>
<span id="annotated-cell-3-2"><a href="#annotated-cell-3-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">length</span>(A)</span>
<span id="annotated-cell-3-3"><a href="#annotated-cell-3-3" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fl">0</span></span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="fl">1</span></span>
<span id="annotated-cell-3-5"><a href="#annotated-cell-3-5" aria-hidden="true" tabindex="-1"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-3-6" class="code-annotation-target"><a href="#annotated-cell-3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> sp<span class="op">+</span>i <span class="op">&lt;=</span> n <span class="op">&amp;&amp;</span> A[sp<span class="op">+</span>i] <span class="op">&lt;</span> x</span>
<span id="annotated-cell-3-7"><a href="#annotated-cell-3-7" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> i</span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> i</span>
<span id="annotated-cell-3-9"><a href="#annotated-cell-3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="annotated-cell-3-10"><a href="#annotated-cell-3-10" aria-hidden="true" tabindex="-1"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-3-11" class="code-annotation-target"><a href="#annotated-cell-3-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">binarysearch</span>(A, x, sp <span class="op">+</span> p, <span class="fu">min</span>(n, sp<span class="op">+</span>i))</span>
<span id="annotated-cell-3-12"><a href="#annotated-cell-3-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="annotated-cell-3-13"><a href="#annotated-cell-3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-14"><a href="#annotated-cell-3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> S<span class="op">=</span>[<span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">30</span>, <span class="fl">40</span>, <span class="fl">50</span>, <span class="fl">60</span>, <span class="fl">70</span>]</span>
<span id="annotated-cell-3-15"><a href="#annotated-cell-3-15" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">doublingsearch</span>(S, <span class="fl">0</span>), <span class="fu">doublingsearch</span>(S, <span class="fl">69</span>), <span class="fu">doublingsearch</span>(S, <span class="fl">70</span>), <span class="fu">doublingsearch</span>(S, <span class="fl">71</span>))</span>
<span id="annotated-cell-3-16"><a href="#annotated-cell-3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="6" data-code-annotation="1">Determinación del rango.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="11" data-code-annotation="2">Aplicar un algoritmo de búsqueda eficiente en el rango que contiene la respuesta.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>(1, 7, 7, 8)</code></pre>
</div>
</div>
<p>Es cierto que estos algoritmos son oportunistas, pero hay aplicaciones donde esto realmente sucede. En el peor caso, el costo será apenas dos veces el óptimo.</p>
</section>
<section id="algoritmo-b_2-búsqueda-doblemente-doblada-doubling-doubling-search" class="level3" data-number="5.2.3">
<h3 data-number="5.2.3" class="anchored" data-anchor-id="algoritmo-b_2-búsqueda-doblemente-doblada-doubling-doubling-search"><span class="header-section-number">5.2.3</span> Algoritmo <span class="math inline">\(B_2\)</span> (búsqueda doblemente doblada, <em>doubling-doubling search</em>)</h3>
<p>Aquí será más clara la dinámica. <span class="math inline">\(B_2\)</span> consiste en comparar las posiciones <span class="math inline">\(2^{2^i}\)</span>, i.e., <span class="math inline">\(2^{4}, 2^{16}, 2^{256}, \cdots, 2^{2^{\lfloor \log_2{\lfloor\log_2{p+1}\rfloor + 1} \rfloor + 1}}\)</span>, tal que <span class="math display">\[A[2^{2^{\lfloor\log_2{\lfloor\log_2{p}\rfloor+1}\rfloor + 1}}] \leq  x \leq A[2^{2^{\lfloor\log_2{\lfloor\log_2{p+1}\rfloor+1}\rfloor + 1}}];\]</span> La determinación de este rango requiere <span class="math inline">\(\lfloor\log_2{\lfloor\log_2{p+1}\rfloor+1}\rfloor+1\)</span> comparaciones; sin embargo, este rango seguramente será muy grande, por el tamaño de los saltos que se estan dando entre puntos de comparación, por lo que no conviene usar busqueda binaria y podemos aplicar <span class="math inline">\(B_1\)</span> para resolver en ese rango acotado.</p>
<p><span class="math display">\[\begin{align}
F_2(n) &amp;= 2^{2^1}, 2^{2^2}, \cdots, 2^{2^{\lfloor \log_2 {\lfloor \log_2 n \rfloor} + 1 \rfloor + 1}};\\
C_2(p) &amp;= \lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1 + C_1(p') \\
       &amp;&lt; \log_2 p + 2\log_2{\log_2 p} + O(1);\\
\end{align}\]</span> donde <span class="math inline">\(p' = p - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}}\)</span>, es decir, la posición de inserción en el rango ya acotado.</p>
<p>Note como el término de mayor peso es muy similar a <span class="math inline">\(B_1\)</span> pero destaca la inclusión del término <span class="math inline">\(\log\log\)</span> que permite adaptarse a <span class="math inline">\(p\)</span> muy grandes con un pequeño costo adicional, que en términos prácticos se puede ver como una constante.</p>
<p>La idea principal es como sigue: una vez determinado el rango, en lugar de usar búsqueda binaria y tener un costo <span class="math inline">\(\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1 + C_\text{bin}(2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1}} - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}})\)</span> es preferible usar <span class="math inline">\(B_1\)</span> y conseguir un algoritmo que se adapte a la entrada. De manera más precisa, tomar ventaja de <span class="math display">\[C_1(2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1}} - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}}) &lt; C_\text{bin}(2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1}} - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}})\]</span> cuando <span class="math display">\[p' &lt; \sqrt{2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1}} - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}}}\]</span>.</p>
<!--Dado que $p' = p - (2^{2^{F_2(p)-1}})$, el costo de $B_1$ en el rango acotado es $2\log_2{p'} + O(1) \leq 2\log_2{p} + O(1)$.
$$\log_2{p'} = \log_2{(p - 2^{2^{\log_2 \log_2 {p}}})} $$

$$\log_2{p'} = \log_2{(p - 2^{2^{F_2(p)-1}})} <  \log_2{(p - 2^{2^{F_2(p)-1}})}$$
-->
<p>Simplificando las expresiones, la relación que nos describe cuando es mejor usar <span class="math inline">\(B_2\)</span> que la búsqueda binaria es como sigue:</p>
<p><span class="math display">\[\begin{align}
{\log_2{p}} + 2\log_2{\log_2{p}} &amp;&lt; \log_2 n\\
2^{\log_2{p} + \log_2{\log^2_2{p}}} &amp;&lt; 2^{\log_2 {n}}\\
2^{\log_2{(p \log^2_2{p})}} &amp;&lt; 2^{\log_2 {n}}\\
2p \log_2{p} &amp; &lt; n\\
p \log_2{p^2} &amp; &lt; n\\
\end{align}\]</span></p>
<p>Si <span class="math inline">\(p = \sqrt{n}\)</span> entonces <span class="math inline">\(\sqrt{n} \log_2 n\)</span> claramente es menor que <span class="math inline">\(n\)</span> incluso para valores relativamente pequeños de <span class="math inline">\(n\)</span>, por lo que <span class="math inline">\(B_2\)</span> funciona mejor para <span class="math inline">\(p\)</span> relativamente grandes en comparación con <span class="math inline">\(B_1\)</span>.</p>
</section>
<section id="algoritmo-b_k" class="level3" data-number="5.2.4">
<h3 data-number="5.2.4" class="anchored" data-anchor-id="algoritmo-b_k"><span class="header-section-number">5.2.4</span> Algoritmo <span class="math inline">\(B_k\)</span></h3>
<p><span class="citation" data-cites="bentley1976almost">Bentley y Yao (<a href="refs.html#ref-bentley1976almost" role="doc-biblioref">1976</a>)</span> generalizan la estrategía para cualquier <span class="math inline">\(k\)</span>. De manera simplificada:</p>
<ul>
<li><span class="math inline">\(F_k(n) = 2^{\cdot^{\cdot^{\cdot^{2^i}}}}\)</span> (exponenciando <span class="math inline">\(k\)</span> veces) para <span class="math inline">\(i\)</span> desde <span class="math inline">\(1\)</span> a <span class="math inline">\(\log_2^{(k)}{n};\)</span></li>
<li><span class="math inline">\(C_k(p) = \log_2^{(k)}(p) + C_{k-1}(2^{{\cdot^{\cdot^{\cdot^{2^{\log_2^{(k)}(p)}}}}}} - 2^{{\cdot^{\cdot^{\cdot^{2^{\log_2^{(k)}(p)-1}}}}}});\)</span></li>
</ul>
<p>donde <span class="math inline">\(\log_2^{(k)}(n) = \log_2(\lfloor \log_2^{(k-1)}{(n)} \rfloor + 1)\)</span>, con el caso base de <span class="math inline">\(\log_2^{(1)} n = \lfloor \log_2 n \rfloor + 1\)</span>.</p>
<p>La estrategia lleva a que el valor casi óptimo para la búsqueda por comparación se da cuando <span class="math inline">\(k=\log^\star_2{n}\)</span> donde <span class="math inline">\(\log^\star_2\)</span> es el logaritmo iterado, que esta definido como las veces que se debe iterar aplicando el logaritmo para obtener un valor de <span class="math inline">\(1\)</span> o menor que <span class="math inline">\(1\)</span>, i.e., la <span class="math inline">\(k\)</span> más pequeña tal que <span class="math inline">\(\log_2^{(k)}n \leq 1\)</span>.</p>
</section>
</section>
<section id="ejercicios" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="ejercicios"><span class="header-section-number">5.3</span> Ejercicios</h2>
<ul>
<li>Implementar y probar <span class="math inline">\(B_2\)</span>.</li>
<li>Derivar el costo <span class="math inline">\(C_2(p)\)</span>.</li>
<li>¿Cuando <span class="math inline">\(B_1\)</span> es mejor que <span class="math inline">\(B_2\)</span>?</li>
<li>Haga un pseudo-código para <span class="math inline">\(B_k\)</span>.</li>
<li>¿Cuál es el costo <span class="math inline">\(C_k\)</span>?</li>
<li>¿Qué es un árbol binario de búsqueda?</li>
<li>¿Cuál es el costo de búsqueda en un árbol? ¿qué se debe hacer para asegurar los costos?</li>
<li>¿Qué es un finger tree?</li>
<li>¿Cuál es el costo de búsqueda de la <em>skip list</em>?</li>
<li>¿Cómo se puede hacer la <em>skip list</em> adaptativa? ¿qué otra forma podría aplicar?</li>
</ul>
</section>
<section id="material-audio-visual" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="material-audio-visual"><span class="header-section-number">5.4</span> Material audio-visual</h2>
<p>En el siguiente video se adentraran en diferentes estrategías de búsqueda, notoriamente aquellas que llamaremos oportunistas o adaptables (adaptative). Estas técnicas nos permitirán tomar provecho de instancias sencillas de problemas e incrementar el desempeño en ese tipo de instancias.</p>
<p>Tenga en cuenta que, honrando la literatura, usaremos de forma indiscriminada listas ordenadas como sinónimo de arreglos ordenados.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/VZHlcPPKW5A" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">
</iframe>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-bentley1976almost" class="csl-entry" role="listitem">
Bentley, Jon Louis, y Andrew Chi-Chih Yao. 1976. <span>“An almost optimal algorithm for unbounded searching”</span>. <em>Information processing letters</em> 5 (SLAC-PUB-1679).
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiado");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiado");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/sadit\.github\.io\/ALGO-IR");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./cap4-ordenamiento.html" class="pagination-link" aria-label="Algoritmos de ordenamiento">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Algoritmos de ordenamiento</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./cap6-intersecciones.html" class="pagination-link" aria-label="Algoritmos de intersección y unión de conjuntos en el modelo de comparación">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Algoritmos de intersección y unión de conjuntos en el modelo de comparación</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Ejecutar el código</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="an">lang:</span><span class="co"> es-MX</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> julia</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="an">julia:</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">  exeflags: ["+1.12"]</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="fu"># Algoritmos de búsqueda en el modelo de comparación {#sec-busqueda}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## Objetivo {.unnumbered}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>Analizar algoritmos de búsqueda en arreglos ordenados basados en funciones de comparación, con el objetivo de localizar elementos y posiciones específicas, usando técnicas de peor caso y adaptables a la distribución de los datos para una solución eficiente de problemas informáticos.</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="fu">## Problema</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>Sea $A<span class="co">[</span><span class="ot">1..n</span><span class="co">]</span> = a_1, \cdots, a_n$ un arreglo ordenado con $n \geq 1$ y un operador $&lt;$ (menor que); por simplicidad, también usaremos $\leq$ (menor o igual que). Supondremos que no hay elementos duplicados en $A$, note que esto no implica una perdida de generalidad.</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>La tarea será: dado el valor $x$ a ser localizado en $A$, el problema consiste en determinar la posición de inserción $p$ tal que suceda alguna de las siguientes condiciones:</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>si $p = 1$ entonces $x \leq A<span class="co">[</span><span class="ot">p</span><span class="co">]</span>$.</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>si $2 \leq p \leq n$ entonces $A<span class="co">[</span><span class="ot">p-1</span><span class="co">]</span> &lt; x \leq A<span class="co">[</span><span class="ot">p</span><span class="co">]</span>$.</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>si $p=n+1$ entonces $A<span class="co">[</span><span class="ot">n</span><span class="co">]</span> &lt; x$.</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="fu">### Costo de peor caso</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>Para $A<span class="co">[</span><span class="ot">1..n</span><span class="co">]</span>$ y el valor $x$ a localizar su posición de inserción, el resultado puede ser cualquiera de las $n+1$ posiciones posibles, i.e., instancias del problema. Un algoritmo naïve utilizaría $n$ comparaciones para resolverlo.</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="st">    seqsearch(A, x, sp=1)</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="st">Búsqueda exhaustiva con inicio</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">seqsearch</span>(A, x, sp<span class="op">=</span><span class="fl">1</span>)</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">length</span>(A)</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> sp <span class="op">&lt;=</span> n <span class="op">&amp;&amp;</span> x <span class="op">&gt;</span> A[sp]</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>        sp <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>    sp</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> S<span class="op">=</span>[<span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">30</span>, <span class="fl">40</span>, <span class="fl">50</span>, <span class="fl">60</span>, <span class="fl">70</span>]</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">seqsearch</span>(S, <span class="fl">0</span>), <span class="fu">seqsearch</span>(S, <span class="fl">69</span>), <span class="fu">seqsearch</span>(S, <span class="fl">70</span>), <span class="fu">seqsearch</span>(S, <span class="fl">71</span>))</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>Sin embargo, dado que el arreglo esta ordenado y no hay duplicados, se puede mejorar mucho el tiempo de búsqueda.</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>Si se permiten duplicados se pueden mejorar muchos los tiempos; sobre todo si podemos preprocesar el arreglo, i.e., para determinar las zonas con duplicados.</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>El costo de búsqueda para cualquier instancia es $O(\log n)$, y viene de la búsqueda binaria:</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a><span class="st">    binarysearch(A, x, sp=1, ep=length(A))</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a><span class="st">Encuentra la posición de inserción de `x` en `A` en el rango `sp:ep`</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">binarysearch</span>(A, x, sp<span class="op">=</span><span class="fl">1</span>, ep<span class="op">=</span><span class="fu">length</span>(A))</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> sp <span class="op">&lt;</span> ep             <span class="co"># &lt;3&gt;</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> <span class="fu">div</span>(sp <span class="op">+</span> ep, <span class="fl">2</span>) <span class="co"># &lt;1&gt;</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">&lt;=</span> A[mid]        <span class="co"># &lt;1&gt;</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>            ep <span class="op">=</span> mid          <span class="co"># &lt;2&gt;</span></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>            sp <span class="op">=</span> mid <span class="op">+</span> <span class="fl">1</span>      <span class="co"># &lt;2&gt;</span></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>    x <span class="op">&lt;=</span> A[sp] ? sp <span class="op">:</span> sp <span class="op">+</span> <span class="fl">1</span> <span class="co"># &lt;4&gt;</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> S<span class="op">=</span>[<span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">30</span>, <span class="fl">40</span>, <span class="fl">50</span>, <span class="fl">60</span>, <span class="fl">70</span>]</span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">binarysearch</span>(S, <span class="fl">0</span>), <span class="fu">binarysearch</span>(S, <span class="fl">69</span>), <span class="fu">binarysearch</span>(S, <span class="fl">70</span>), <span class="fu">binarysearch</span>(S, <span class="fl">71</span>))</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Para el rango de búsqueda $sp:ep$ se determina su punto central $mid$ y se compara con $x$,</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Si el elemento $x$ esta a la izquierda, se ajusta el limite superior $ep,$ o de lo contrario se ajusta $sp$. Ambos ajustes se hacen tomando en cuenta la posición comparada.</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Se itera mientras no se junten los dos extremos del rango.</span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Finalmente, se ajusta para valores fuera del rango. </span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>Este algoritmo es simple y efectivo, y es capaz de resolver cualquier instancia en tiempo logarítmico, y esto lo hace al dividir el rango siempre a la mitad por cada iteración. El costo de búsqueda binaria es de $C_\text{bin}(n) = \lfloor \log n \rfloor + O(1)$ comparaciones antes de colapsar el rango donde puede estar la posición de inserción. </span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>Es importante hacer notar que la búsqueda binaria es muy eficiente en memoría y tiene un peor caso óptimo, ya que es idéntico al costo del problema, i.e., así lo determinamos. Si fuera posible tener probar varios puntos, i.e., $m$ segmentos en una sola operación, el costo estaría acotado en $\lceil \log_{m} n \rceil$. Esto tiene sentido para estructuras de datos que trabajan en diferentes niveles de memoría, donde aunque las comparaciones en hardware moderno sean binarias, la diferencia entre velocidades de los diferentes niveles de memoria se puede pensar que el costo dominante es, por ejemplo, acceder a una zona de disco y obtener una decisión entre $m-1$ posibles, que particionan los rangos en $m$ divisiones.</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a><span class="fu">## Búsqueda _no_ acotada</span></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>Cuando el tamaño del arreglo es demasiado grande, o la relación entre $p / n$ es significativamente pequeña, la búsqueda acotada no es la mejor opción. Aun cuando en la práctica el límite superior $n$ podría estar determinado, y por lo tanto, se pueden resolver búsquedas en $O(\log n)$, es posible obtener una cota relativa a $p$, independiente de $n$, por lo que los casos de interés se verán beneficiados.</span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>Una estrategia simple y poderosa es la siguiente:</span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Determinar un _buen_ rango que contenga la respuesta.</span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Aplicar búsqueda binaria en ese rango para obtener la respuesta.</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a>@bentley1976almost describen a detalle una familia de algoritmos casí óptimos para la búsqueda no acotada siguiendo la estrategía anteriormente mencionada. En particular, poniendo un enfásis importante en la determinación del rango. Lo consigue mediante la definición de algoritmos definidos de manera interesante como sigue en el resto de la sección.</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algoritmo $B_0$ (búsqueda unaría)</span></span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>Es el algoritmo más simple, y ya lo vimos con anterioridad, realiza una búsqueda exhaustiva de la posición de inserción, hacendo pruebas para toda posición $x \leq A<span class="co">[</span><span class="ot">1</span><span class="co">]</span>, x \leq A<span class="co">[</span><span class="ot">2</span><span class="co">]</span>, \cdots, x \leq A<span class="co">[</span><span class="ot">p+1</span><span class="co">]</span>$, por lo que su costo será de $p+1$.</span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a>Sea $F_0(n)$ una secuencia de puntos para un arreglo de longitud $n$, donde se harán comparaciones para determinar el rango que contenga la respuesta para el algoritmo $B_0$ y $C_0(p)$ el costo de búsqueda. Entonces:</span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$F_0(n) = 1, 2, \cdots, n, n+1$.</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$C_0(p) = p+1$; no requiere búsqueda binaria.</span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algoritmo $B_1$ (búsqueda doblada: _doubling search/galloping_)</span></span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>Consiste en comparar las posiciones $2^i$, i.e., $2^1, 2^2, 2^3, \cdots, 2^{\lfloor \log_2{p+1} \rfloor + 1}$, tal que $A<span class="co">[</span><span class="ot">2^{\lfloor\log_2{p}\rfloor+1}</span><span class="co">]</span> \leq  x \leq A<span class="co">[</span><span class="ot">2^{\lfloor\log_2{p+1}\rfloor+1}</span><span class="co">]</span>$.</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>De manera similar que para $B_0$ definimos $F_1(n)$ y $C_1$:</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$F_1(n) = 2^1, 2^2, \cdots, 2^{\log \lfloor n \rfloor + 1};$</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$C_1(p) = C_\text{bin}{(2^{\log_2{p+1}})} + \log_2{(p+1)} + 1 &lt; 2\log_2 p + O(1).$</span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>La explicación viene a continuación. El número de comparaciones para determinar el rango esta determinado por $\lfloor \log_2{p+1} \rfloor + 1$. Una vez determinado el rango la búsqueda binaria sobre </span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>$$A<span class="co">[</span><span class="ot">2^{\lfloor\log_2{p}\rfloor+1}:2^{\lfloor\log_2{(p+1)}\rfloor+1}</span><span class="co">]</span>,$$ </span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>lo cual corresponde a $\log_2 2^{\log{(p+1)}+1}/2 = \log_2{(p+1)}$. El costo $C_1(p)$ puede ser escrito como $2\log_2 p + O(1)$, con un poco de manipulación algebraica.</span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a>Es importante saber cuando usar un algoritmo u otro, por tanto determinar cuando $2\log_2{p} + O(1) &lt; \log_2 n + O(1).$ Para simplificar este análisis ignoraremos algunos detalles de la expresión:</span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a> 2\log_2{p} &amp; &lt; \log_2 n, <span class="sc">\\</span></span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a> 2^{\log_2{p^2}} &amp; &lt; 2^{\log_2 n}, <span class="sc">\\</span></span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>p^2              &amp; &lt;  n, <span class="sc">\\</span></span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a> p               &amp; &lt;  \sqrt{n}; <span class="sc">\\</span></span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>esto indica que si $p$ es menor a $\sqrt{n}$ entonces hay una ventaja al usar $B_1$; lo cual nos dice que para posiciones cercanas al inicio el uso de $B_1$ puede llevar a búsquedas más veloces. Note que en la práctica es necesario tener en cuenta la memoria, interesantemente, para $p$ pequeñas es posible que esto beneficie al algoritmo ya que podría mantener las listas en cache.</span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a>El siguiente código implementa $B_1$</span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">doublingsearch</span>(A, x, sp<span class="op">=</span><span class="fl">1</span>)</span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">length</span>(A)</span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> sp<span class="op">+</span>i <span class="op">&lt;=</span> n <span class="op">&amp;&amp;</span> A[sp<span class="op">+</span>i] <span class="op">&lt;</span> x <span class="co"># &lt;1&gt;</span></span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> i</span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> i</span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-144"><a href="#cb5-144" aria-hidden="true" tabindex="-1"></a>    <span class="fu">binarysearch</span>(A, x, sp <span class="op">+</span> p, <span class="fu">min</span>(n, sp<span class="op">+</span>i)) <span class="co"># &lt;2&gt;</span></span>
<span id="cb5-145"><a href="#cb5-145" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-146"><a href="#cb5-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-147"><a href="#cb5-147" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> S<span class="op">=</span>[<span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">30</span>, <span class="fl">40</span>, <span class="fl">50</span>, <span class="fl">60</span>, <span class="fl">70</span>]</span>
<span id="cb5-148"><a href="#cb5-148" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">doublingsearch</span>(S, <span class="fl">0</span>), <span class="fu">doublingsearch</span>(S, <span class="fl">69</span>), <span class="fu">doublingsearch</span>(S, <span class="fl">70</span>), <span class="fu">doublingsearch</span>(S, <span class="fl">71</span>))</span>
<span id="cb5-149"><a href="#cb5-149" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-150"><a href="#cb5-150" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-151"><a href="#cb5-151" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Determinación del rango.</span>
<span id="cb5-152"><a href="#cb5-152" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Aplicar un algoritmo de búsqueda eficiente en el rango que contiene la respuesta.</span>
<span id="cb5-153"><a href="#cb5-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-154"><a href="#cb5-154" aria-hidden="true" tabindex="-1"></a>Es cierto que estos algoritmos son oportunistas, pero hay aplicaciones donde esto realmente sucede. En el peor caso, el costo será apenas dos veces el óptimo.</span>
<span id="cb5-155"><a href="#cb5-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-156"><a href="#cb5-156" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algoritmo $B_2$ (búsqueda doblemente doblada, _doubling-doubling search_)</span></span>
<span id="cb5-157"><a href="#cb5-157" aria-hidden="true" tabindex="-1"></a>Aquí será más clara la dinámica. $B_2$ consiste en comparar las posiciones $2^{2^i}$, i.e., $2^{4}, 2^{16}, 2^{256}, \cdots, 2^{2^{\lfloor \log_2{\lfloor\log_2{p+1}\rfloor + 1} \rfloor + 1}}$, tal que </span>
<span id="cb5-158"><a href="#cb5-158" aria-hidden="true" tabindex="-1"></a>$$A<span class="co">[</span><span class="ot">2^{2^{\lfloor\log_2{\lfloor\log_2{p}\rfloor+1}\rfloor + 1}}</span><span class="co">]</span> \leq  x \leq A<span class="co">[</span><span class="ot">2^{2^{\lfloor\log_2{\lfloor\log_2{p+1}\rfloor+1}\rfloor + 1}}</span><span class="co">]</span>;$$</span>
<span id="cb5-159"><a href="#cb5-159" aria-hidden="true" tabindex="-1"></a>La determinación de este rango requiere $\lfloor\log_2{\lfloor\log_2{p+1}\rfloor+1}\rfloor+1$ comparaciones; sin embargo, este rango seguramente será muy grande, por el tamaño de los saltos que se estan dando entre puntos de comparación, por lo que no conviene usar busqueda binaria y podemos aplicar $B_1$ para resolver en ese rango acotado. </span>
<span id="cb5-160"><a href="#cb5-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-161"><a href="#cb5-161" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb5-162"><a href="#cb5-162" aria-hidden="true" tabindex="-1"></a>F_2(n) &amp;= 2^{2^1}, 2^{2^2}, \cdots, 2^{2^{\lfloor \log_2 {\lfloor \log_2 n \rfloor} + 1 \rfloor + 1}};<span class="sc">\\</span></span>
<span id="cb5-163"><a href="#cb5-163" aria-hidden="true" tabindex="-1"></a>C_2(p) &amp;= \lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1 + C_1(p') <span class="sc">\\</span></span>
<span id="cb5-164"><a href="#cb5-164" aria-hidden="true" tabindex="-1"></a>       &amp;&lt; \log_2 p + 2\log_2{\log_2 p} + O(1);<span class="sc">\\</span></span>
<span id="cb5-165"><a href="#cb5-165" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb5-166"><a href="#cb5-166" aria-hidden="true" tabindex="-1"></a>donde $p' = p - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}}$, es decir, la posición de inserción en el rango ya acotado.</span>
<span id="cb5-167"><a href="#cb5-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-168"><a href="#cb5-168" aria-hidden="true" tabindex="-1"></a>Note como el término de mayor peso es muy similar a $B_1$ pero destaca la inclusión del término $\log\log$ que permite adaptarse a $p$ muy grandes con un pequeño costo adicional, que en términos prácticos se puede ver como una constante. </span>
<span id="cb5-169"><a href="#cb5-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-170"><a href="#cb5-170" aria-hidden="true" tabindex="-1"></a>La idea principal es como sigue: una vez determinado el rango, en lugar de usar búsqueda binaria y tener un costo $\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1 + C_\text{bin}(2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1}} - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}})$ es preferible usar $B_1$ y conseguir un algoritmo que se adapte a la entrada. De manera más precisa, tomar ventaja de</span>
<span id="cb5-171"><a href="#cb5-171" aria-hidden="true" tabindex="-1"></a>$$C_1(2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1}} - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}}) &lt; C_\text{bin}(2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1}} - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}})$$ cuando </span>
<span id="cb5-172"><a href="#cb5-172" aria-hidden="true" tabindex="-1"></a>$$p' &lt; \sqrt{2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor + 1}} - 2^{2^{\lfloor \log_2 {\lfloor \log_2 p \rfloor} + 1 \rfloor}}}$$.</span>
<span id="cb5-173"><a href="#cb5-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-174"><a href="#cb5-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-175"><a href="#cb5-175" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--Dado que $p' = p - (2^{2^{F_2(p)-1}})$, el costo de $B_1$ en el rango acotado es $2\log_2{p'} + O(1) \leq 2\log_2{p} + O(1)$.</span></span>
<span id="cb5-176"><a href="#cb5-176" aria-hidden="true" tabindex="-1"></a><span class="co">$$\log_2{p'} = \log_2{(p - 2^{2^{\log_2 \log_2 {p</span><span class="re">}}}</span><span class="co">)} $$</span></span>
<span id="cb5-177"><a href="#cb5-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-178"><a href="#cb5-178" aria-hidden="true" tabindex="-1"></a><span class="co">$$\log_2{p'} = \log_2{(p - 2^{2^{F_2(p)-1}})} &lt;  \log_2{(p - 2^{2^{F_2(p)-1}})}$$</span></span>
<span id="cb5-179"><a href="#cb5-179" aria-hidden="true" tabindex="-1"></a><span class="co">--&gt;</span></span>
<span id="cb5-180"><a href="#cb5-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-181"><a href="#cb5-181" aria-hidden="true" tabindex="-1"></a>Simplificando las expresiones, la relación que nos describe cuando es mejor usar $B_2$ que la búsqueda binaria es como sigue:</span>
<span id="cb5-182"><a href="#cb5-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-183"><a href="#cb5-183" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb5-184"><a href="#cb5-184" aria-hidden="true" tabindex="-1"></a>{\log_2{p}} + 2\log_2{\log_2{p}} &amp;&lt; \log_2 n<span class="sc">\\</span></span>
<span id="cb5-185"><a href="#cb5-185" aria-hidden="true" tabindex="-1"></a>2^{\log_2{p} + \log_2{\log^2_2{p}}} &amp;&lt; 2^{\log_2 {n}}<span class="sc">\\</span></span>
<span id="cb5-186"><a href="#cb5-186" aria-hidden="true" tabindex="-1"></a>2^{\log_2{(p \log^2_2{p})}} &amp;&lt; 2^{\log_2 {n}}<span class="sc">\\</span></span>
<span id="cb5-187"><a href="#cb5-187" aria-hidden="true" tabindex="-1"></a>2p \log_2{p} &amp; &lt; n<span class="sc">\\</span></span>
<span id="cb5-188"><a href="#cb5-188" aria-hidden="true" tabindex="-1"></a>p \log_2{p^2} &amp; &lt; n<span class="sc">\\</span></span>
<span id="cb5-189"><a href="#cb5-189" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb5-190"><a href="#cb5-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-191"><a href="#cb5-191" aria-hidden="true" tabindex="-1"></a>Si $p = \sqrt{n}$ entonces $\sqrt{n} \log_2 n$ claramente es menor que $n$ incluso para valores relativamente pequeños de $n$, por lo que $B_2$ funciona mejor para $p$ relativamente grandes en comparación con $B_1$. </span>
<span id="cb5-192"><a href="#cb5-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-193"><a href="#cb5-193" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algoritmo $B_k$</span></span>
<span id="cb5-194"><a href="#cb5-194" aria-hidden="true" tabindex="-1"></a>@bentley1976almost generalizan la estrategía para cualquier $k$. De manera simplificada:</span>
<span id="cb5-195"><a href="#cb5-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-196"><a href="#cb5-196" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$F_k(n) = 2^{\cdot^{\cdot^{\cdot^{2^i}}}}$ (exponenciando $k$ veces) para $i$ desde $1$ a $\log_2^{(k)}{n};$</span>
<span id="cb5-197"><a href="#cb5-197" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$C_k(p) = \log_2^{(k)}(p) + C_{k-1}(2^{{\cdot^{\cdot^{\cdot^{2^{\log_2^{(k)}(p)}}}}}} - 2^{{\cdot^{\cdot^{\cdot^{2^{\log_2^{(k)}(p)-1}}}}}});$</span>
<span id="cb5-198"><a href="#cb5-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-199"><a href="#cb5-199" aria-hidden="true" tabindex="-1"></a>donde $\log_2^{(k)}(n) = \log_2(\lfloor \log_2^{(k-1)}{(n)} \rfloor + 1)$, con el caso base de $\log_2^{(1)} n = \lfloor \log_2 n \rfloor + 1$.</span>
<span id="cb5-200"><a href="#cb5-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-201"><a href="#cb5-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-202"><a href="#cb5-202" aria-hidden="true" tabindex="-1"></a>La estrategia lleva a que el valor casi óptimo para la búsqueda por comparación se da cuando $k=\log^\star_2{n}$ donde $\log^\star_2$ es el logaritmo iterado, que esta definido como las veces que se debe iterar aplicando el logaritmo para obtener un valor de $1$ o menor que $1$, i.e., la $k$ más pequeña tal que $\log_2^{(k)}n \leq 1$.</span>
<span id="cb5-203"><a href="#cb5-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-204"><a href="#cb5-204" aria-hidden="true" tabindex="-1"></a><span class="fu">## Ejercicios</span></span>
<span id="cb5-205"><a href="#cb5-205" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Implementar y probar $B_2$.</span>
<span id="cb5-206"><a href="#cb5-206" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Derivar el costo $C_2(p)$.</span>
<span id="cb5-207"><a href="#cb5-207" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>¿Cuando $B_1$ es mejor que $B_2$?</span>
<span id="cb5-208"><a href="#cb5-208" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Haga un pseudo-código para $B_k$.</span>
<span id="cb5-209"><a href="#cb5-209" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>¿Cuál es el costo $C_k$?</span>
<span id="cb5-210"><a href="#cb5-210" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>¿Qué es un árbol binario de búsqueda?</span>
<span id="cb5-211"><a href="#cb5-211" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>¿Cuál es el costo de búsqueda en un árbol? ¿qué se debe hacer para asegurar los costos?</span>
<span id="cb5-212"><a href="#cb5-212" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>¿Qué es un finger tree?</span>
<span id="cb5-213"><a href="#cb5-213" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>¿Cuál es el costo de búsqueda de la _skip list_?</span>
<span id="cb5-214"><a href="#cb5-214" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>¿Cómo se puede hacer la _skip list_ adaptativa? ¿qué otra forma podría aplicar?</span>
<span id="cb5-215"><a href="#cb5-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-216"><a href="#cb5-216" aria-hidden="true" tabindex="-1"></a><span class="fu">## Material audio-visual</span></span>
<span id="cb5-217"><a href="#cb5-217" aria-hidden="true" tabindex="-1"></a>En el siguiente video se adentraran en diferentes estrategías de búsqueda, notoriamente aquellas que llamaremos oportunistas o adaptables (adaptative). Estas técnicas nos permitirán tomar provecho de instancias sencillas de problemas e incrementar el desempeño en ese tipo de instancias.</span>
<span id="cb5-218"><a href="#cb5-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-219"><a href="#cb5-219" aria-hidden="true" tabindex="-1"></a>Tenga en cuenta que, honrando la literatura, usaremos de forma indiscriminada listas ordenadas como sinónimo de arreglos ordenados.</span>
<span id="cb5-220"><a href="#cb5-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-221"><a href="#cb5-221" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">iframe</span><span class="ot"> width</span><span class="op">=</span><span class="st">"560"</span><span class="ot"> height</span><span class="op">=</span><span class="st">"315"</span><span class="ot"> src</span><span class="op">=</span><span class="st">"https://www.youtube.com/embed/VZHlcPPKW5A"</span><span class="ot"> frameborder</span><span class="op">=</span><span class="st">"0"</span><span class="ot"> allow</span><span class="op">=</span><span class="st">"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"</span><span class="ot"> allowfullscreen</span><span class="dt">&gt;&lt;/</span><span class="kw">iframe</span><span class="dt">&gt;</span></span>
</code></pre></div><button title="Copiar al portapapeles" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" class="img-fluid"></a> <br> Esta obra está bajo una <a href="http://creativecommons.org/licenses/by-sa/4.0/">Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional</a></p>
</div>
  </div>
</footer>




</body></html>