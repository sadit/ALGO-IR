<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es-MX" xml:lang="es-MX"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Estructuras de datos elementales – Curso Introductorio al Análisis de Algoritmos con Julia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./cap4-ordenamiento.html" rel="next">
<link href="./cap2-analisis.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-a185852c63625fd9ffbdc57047c9a77e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-cf2d42087b478c672072bd1259b5cf1d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./cap3-estructuras.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Estructuras de datos elementales</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><span id="sec-estructuras" class="quarto-section-identifier"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Estructuras de datos elementales</span></span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Código</button></div></div>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Curso Introductorio al Análisis de Algoritmos con Julia</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/sadit/ALGO-IR" title="Ejecutar el código" class="quarto-navigation-tool px-1" aria-label="Ejecutar el código"><i class="bi bi-github"></i></a>
    <a href="./Curso-Introductorio-al-Análisis-de-Algoritmos-con-Julia.pdf" title="Descargar PDF" class="quarto-navigation-tool px-1" aria-label="Descargar PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefacio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap1-julia.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Julia como lenguaje de programación para un curso de algoritmos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap2-analisis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introducción al análisis de algoritmos con Julia</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap3-estructuras.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Estructuras de datos elementales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap4-ordenamiento.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Algoritmos de ordenamiento</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap5-busqueda.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Algoritmos de búsqueda en el modelo de comparación</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cap6-intersecciones.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Algoritmos de intersección y unión de conjuntos en el modelo de comparación</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./refs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Apéndices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Alternar sección">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./galeria-actividades.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Galería de actividades MCDI</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#objetivo" id="toc-objetivo" class="nav-link active" data-scroll-target="#objetivo">Objetivo</a></li>
  <li><a href="#introducción" id="toc-introducción" class="nav-link" data-scroll-target="#introducción"><span class="header-section-number">3.1</span> Introducción</a></li>
  <li><a href="#conjuntos" id="toc-conjuntos" class="nav-link" data-scroll-target="#conjuntos"><span class="header-section-number">3.2</span> Conjuntos</a></li>
  <li><a href="#tuplas-y-estructuras" id="toc-tuplas-y-estructuras" class="nav-link" data-scroll-target="#tuplas-y-estructuras"><span class="header-section-number">3.3</span> Tuplas y estructuras</a></li>
  <li><a href="#arreglos" id="toc-arreglos" class="nav-link" data-scroll-target="#arreglos"><span class="header-section-number">3.4</span> Arreglos</a></li>
  <li><a href="#listas" id="toc-listas" class="nav-link" data-scroll-target="#listas"><span class="header-section-number">3.5</span> Listas</a></li>
  <li><a href="#grafos" id="toc-grafos" class="nav-link" data-scroll-target="#grafos"><span class="header-section-number">3.6</span> Grafos</a></li>
  <li><a href="#actividades" id="toc-actividades" class="nav-link" data-scroll-target="#actividades"><span class="header-section-number">3.7</span> Actividades</a></li>
  <li><a href="#bibliografía" id="toc-bibliografía" class="nav-link" data-scroll-target="#bibliografía"><span class="header-section-number">3.8</span> Bibliografía</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<section id="objetivo" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="objetivo">Objetivo</h2>
<p>Implementar, aplicar y caracterizar el desempeño de algoritmos en peor caso y adaptativos para búsqueda en arreglos ordenados. Se discutirán estructuras de datos básicas que serán de gran utilidad al momento de construir programas y de resolver problemas más complejos; nos enfocaremos en las estructuras de datos.</p>
</section>
<section id="introducción" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="introducción"><span class="header-section-number">3.1</span> Introducción</h2>
<p>En esta unidad se discutirán las propiedades y operaciones básicas de estructuras como conjuntos, listas, pilas, colas, arreglos, vectores, matrices y matrices dispersas. Los ejemplos de código se muestran en el lenguaje de programación Julia, pero que puede ser traducido fácilmente en otros lenguajes de programación.</p>
</section>
<section id="conjuntos" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="conjuntos"><span class="header-section-number">3.2</span> Conjuntos</h2>
<p>Los <em>conjuntos</em> son estructuras abstractas que representan una colección de elementos, en particular, dado las posibles aplicaciones un conjunto puede tener contenido inmutable o mutable. Un conjunto puede estar vacio (<span class="math inline">\(\emptyset\)</span>) o contener elementos, e.g., <span class="math inline">\(\{a, b, c\}\)</span>. La operación <em>unión</em> <span class="math inline">\(\cup\)</span> construye un nuevo conjunto a partir de otros <span class="math inline">\(\{a, b\} \cup \{c\} = \{a, b, c\}\)</span>; la intersección se indica con el operador <span class="math inline">\(\cap\)</span>, e.g.&nbsp;<span class="math inline">\(\{a, b, c\} \cap \{b, d\} = \{b\}\)</span>. El tamaño de una colección lo representamos con barras, e.g., <span class="math inline">\(|\{a, b\}| = 2\)</span>. También es útil consultar por membresia <span class="math inline">\(a \in \{a, b, c\}\)</span> o por su negación, i.e., <span class="math inline">\(d \not\in \{a, b, c\}\)</span>. Es común usar conjuntos mutables en diferentes algoritmos, esto es, que permitan inserciones y borrados sobre la misma estructura; desde el punto de vista de eficiencia, esto puede reducir las operaciones de manipulación de datos así como de la gestión de memoria. Suponga el conjunto <span class="math inline">\(S = \{a, b, c\}\)</span>, la función <span class="math inline">\(pop!(S, b)\)</span> resultaría en <span class="math inline">\(\{a, c\}\)</span>, y la función <span class="math inline">\(push!(S, d)\)</span> resultaría en <span class="math inline">\(\{a, c, d\}\)</span> al encadenar estas operaciones. Note que el símbolo <span class="math inline">\(!\)</span> solo se esta usando en cooncordancia con el lenguaje de programación Julia para indicar que la función cambiaría el argumento de entrada; es una convención, no un operador en sí mismo. Note que estamos usando una sintaxis muy sencilla <span class="math inline">\(fun(arg1, arg2, ...)\)</span> para indicar la aplicación de una función u operación a una serie de argumentos.</p>
<p>Hay múltiples formas de representar conjuntos ya que los requerimientos de los algoritmos son diversos y tener la representación correcta puede ser una diferencia importante en el rendimiento. Las implementaciones y algoritmos alrededor pueden llegar a ser muy sofisticados, dependiendo de las características que se desean, algunas de las cuales serán el centro de estudio de este curso.</p>
</section>
<section id="tuplas-y-estructuras" class="level2 page-columns page-full" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="tuplas-y-estructuras"><span class="header-section-number">3.3</span> Tuplas y estructuras</h2>
<p>Las <em>tuplas</em> son colecciones abstractas ordenadas, donde incluso puede haber repetición, pueden verse como una secuencia de elementos, e.g., <span class="math inline">\(S = (a, b, c)\)</span>; podemos referirnos a la <span class="math inline">\(i\)</span>ésima posición de la forma <span class="math inline">\(S_i\)</span>, o incluso <span class="math inline">\(S[i]\)</span>, si el contexto lo amerita, e.g., pseudo-código que pueda ser transferido a un lenguaje de programación más fácilmente. Es común que cada parte de la tupla pueda contener cierto tipo de dato, e.g., enteros, números de punto flotante, símbolos, cadenas de carácteres, etc. Una tupla es muy amena para ser representada de manera contigua en memoria. En el lenguaje de programación Julia, las tuplas se representan entre paréntesis, e.g., <span class="math inline">\((1, 2, 3)\)</span>.</p>
<div id="cell-codigo-acceso-tupla" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> (<span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">30</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>t[<span class="fl">1</span>] <span class="op">*</span> t[<span class="fl">3</span>] <span class="op">-</span> t[<span class="fl">2</span>]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="codigo-acceso-tupla" class="cell-output cell-output-display" data-execution_count="1">
<pre><code>280</code></pre>
<p>Definición y acceso a los campos de una tupla en Julia</p>
</div>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<p>En algunos lenguajes de programación como Julia, una tupla puede enviarse como <em>valor</em> (copiar) cuando se utiliza en una función; por lo mismo, puede guardarse en el <em>stack</em>, que es la memoria <em>inmediata</em> que se tiene en el contexto de ejecución de una función. En esos casos, se puede optimizar el manejo de memoria (alojar y liberar), lo cuál puede ser muy beneficioso para un algoritmo en la práctico. El otro esquema posible es el <em>heap</em>, que es una zona de memoria que debe gestionarse (memoria dinámica); es más flexible y <em>duradera</em> entre diferentes llamadas de funciones en un programa. Los patrones esperados son dispersos y puede generar fragmentación.</p>
</div></div><p>Una <em>estructura</em> es una tupla con campos nombrados; es muy útilizada en lenguajes de programación, por ejemplo, en Julia la siguiente estructura puede representar un punto en un plano:</p>
<div id="ejemplo-estructura" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  x<span class="op">::</span><span class="dt">Float32</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  y<span class="op">::</span><span class="dt">Float32</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note la especificación de los tipos de datos que en conjunto describirán como dicha estructura se maneja por una computadora, y que en términos prácticos, es determinante para el desempeño. Es común asignar valores satelitales en programas o algoritmos, de tal forma que un elemento simple sea manipulado o utilizado de manera explicita en los algoritmos y tener asociados elementos secundarios que se vean afectados por las operaciones. Los conjuntos, tuplas y las estructuras son excelentes formas de representar datos complejos de una manera sencilla.</p>
<p>En Julia, es posible definir funciones o métodos al rededor del tipo de tuplas y estructuras.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Es importante saber que si algunos de los campos o datos de una tupla o estructura estan en el <em>heap</em> entonces solo una parte estará en el <em>stack</em>; i.e., en el caso extremo solo serán referencias a datos en el <em>heap</em>. Esto puede llegar a complicar el manejo de memoria, pero también puede ser un comportamiento sobre el que se puede razonar y construir.</p>
</div></div><div id="cell-funcion-norma" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="st">  Calcula la norma de un vector representado</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="st">  como un tupla</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">norm</span>(u<span class="op">::</span><span class="dt">Tuple</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> <span class="fl">0f0</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="fu">eachindex</span>(u)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> u[i]<span class="op">^</span><span class="fl">2</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sqrt</span>(s)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="st">  Calcula la norma de un vector de 2 dimensiones</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="st">  representado como una estructura</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">norm</span>(u<span class="op">::</span><span class="dt">Point</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sqrt</span>(u.x<span class="op">^</span><span class="fl">2</span> <span class="op">+</span> u.y<span class="op">^</span><span class="fl">2</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>(<span class="fu">norm</span>((<span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>)), <span class="fu">norm</span>(<span class="fu">Point</span>(<span class="fl">1</span>, <span class="fl">1</span>)))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="funcion-norma" class="cell-output cell-output-display" data-execution_count="1">
<pre><code>(1.0, 1.4142135f0)</code></pre>
<p>Funciones sobre diferentes tipos de datos</p>
</div>
</div>
<p>Note que la función es diferente para cada tipo de entrada; a este comportamiento se le llamada despacho múltiple y será un concepto común este curso. En otros lenguajes de programación se implementa mediante orientación a objetos.</p>
</section>
<section id="arreglos" class="level2 page-columns page-full" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="arreglos"><span class="header-section-number">3.4</span> Arreglos</h2>
<p>Los <em>arreglos</em> son estructuras de datos que mantienen información de un solo tipo, tienen un costo constante <span class="math inline">\(O(1)\)</span> para acceder a cualquier elemento (también llamado acceso aleatorio) y tipicamente se implementan como memoria contigua en una computadora. Al igual que las tuplas, son colecciones ordenadas, las estaremos accediendo a sus elementos con la misma notación. En este curso usaremos arreglos como colecciones representadas en segmentos contiguos de memoria con dimensiones lógicas fijas. A diferencia de las tuplas, es posible reemplazar valores, entonces <span class="math inline">\(S_{ij} \leftarrow a\)</span>, reemplazará el contenido de <span class="math inline">\(S\)</span> en la celda especificada por <span class="math inline">\(a\)</span>.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Julia tiene un soporte para arreglos excepcional, el cual apenas trataremos ya que se enfoca en diferentes áreas del cómputo numérico, y nuestro curso esta orientado a algoritmos. En Python, estructuras similares se encuentra en el paquete <em>Numeric Python</em> o <em>numpy</em>; tenga en cuenta que las afirmaciones sobre el manejo de memoria y representación que estaremos usando se apegan a estos modelos, y no a las <em>listas</em> nativas de Python.</p>
</div></div><p>A diferencia de las tuplas, pueden tener más que una dimensión. La notación para acceder a los elementos se extiende, e.g.&nbsp;para una matriz <span class="math inline">\(S\)</span> (arreglo bidimensional) <span class="math inline">\(S_{ij}\)</span> se refiere a la celda en la fija <span class="math inline">\(i\)</span> columna <span class="math inline">\(j\)</span>, lo mismo que <span class="math inline">\(S[i, j]\)</span>. Si pensamos en datos numéricos, un arreglo unidimensional es útil para modelar un <em>vector</em> de múltiples dimensiones, un arreglo bidimensional para representar una <em>mátriz</em> de tamaño <span class="math inline">\(m \times n\)</span>, y arreglos de dimensión mayor pueden usarse para tensores. Se representan en memoria en segmentos contiguos, y los arreglos de múltiples dimensiones serán representados cuyas partes pueden ser delimitadas mediante aritmética simple, e.g., una matriz de tamaño <span class="math inline">\(m \times n\)</span> necesitará una zona de memoria de <span class="math inline">\(m \times n\)</span> elementos, y se puede acceder a la primera columna mediante en la zona <span class="math inline">\(1,\dots,m\)</span>, la segunda columna en <span class="math inline">\(m+1,\dots,2m\)</span>, y la <span class="math inline">\(i\)</span>ésima en <span class="math inline">\((i-1)m+1,\dots,im\)</span>; esto es, se implementa como el acceso en lotes de tamaño fijo en un gran arreglo unidimensional que es la memoria.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Esta es la manera que en general se manejan los datos en una computadora, y conocerlo de manera explícita nos permite tomar decisiones de diseño e implementación.</p>
</div></div><div class="cell" data-fig-width="100%" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-memoria" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-memoria-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 896.29 83.40" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 79.4)">
<title>lista</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-79.4 892.29,-79.4 892.29,4 -4,4"></polygon>
<!-- RAM -->
<g id="node1" class="node">
<title>RAM</title>
<polygon fill="none" stroke="black" points="0,-0.5 0,-74.9 888.29,-74.9 888.29,-0.5 0,-0.5"></polygon>
<text text-anchor="middle" x="444.15" y="-58.3" font-family="Times,serif" font-size="14.00">memoria RAM</text>
<polyline fill="none" stroke="black" points="0,-50.1 888.29,-50.1 "></polyline>
<text text-anchor="middle" x="22.78" y="-29.5" font-family="Times,serif" font-size="14.00">otros</text>
<text text-anchor="middle" x="22.78" y="-12.7" font-family="Times,serif" font-size="14.00">datos</text>
<polyline fill="none" stroke="black" points="45.55,-0.5 45.55,-50.1 "></polyline>
<text text-anchor="middle" x="145.2" y="-33.5" font-family="Times,serif" font-size="14.00">columna 1 - x[:, 1]</text>
<polyline fill="none" stroke="black" points="45.55,-25.3 244.85,-25.3 "></polyline>
<text text-anchor="middle" x="70.46" y="-8.7" font-family="Times,serif" font-size="14.00">x[1,1]</text>
<polyline fill="none" stroke="black" points="95.38,-0.5 95.38,-25.3 "></polyline>
<text text-anchor="middle" x="120.29" y="-8.7" font-family="Times,serif" font-size="14.00">x[2,1]</text>
<polyline fill="none" stroke="black" points="145.2,-0.5 145.2,-25.3 "></polyline>
<text text-anchor="middle" x="170.11" y="-8.7" font-family="Times,serif" font-size="14.00">x[3,1]</text>
<polyline fill="none" stroke="black" points="195.02,-0.5 195.02,-25.3 "></polyline>
<text text-anchor="middle" x="219.94" y="-8.7" font-family="Times,serif" font-size="14.00">x[4,1]</text>
<polyline fill="none" stroke="black" points="244.85,-0.5 244.85,-50.1 "></polyline>
<text text-anchor="middle" x="344.5" y="-33.5" font-family="Times,serif" font-size="14.00">columna 2 - x[:, 2]</text>
<polyline fill="none" stroke="black" points="244.85,-25.3 444.15,-25.3 "></polyline>
<text text-anchor="middle" x="269.76" y="-8.7" font-family="Times,serif" font-size="14.00">x[1,2]</text>
<polyline fill="none" stroke="black" points="294.67,-0.5 294.67,-25.3 "></polyline>
<text text-anchor="middle" x="319.58" y="-8.7" font-family="Times,serif" font-size="14.00">x[2,2]</text>
<polyline fill="none" stroke="black" points="344.5,-0.5 344.5,-25.3 "></polyline>
<text text-anchor="middle" x="369.41" y="-8.7" font-family="Times,serif" font-size="14.00">x[3,2]</text>
<polyline fill="none" stroke="black" points="394.32,-0.5 394.32,-25.3 "></polyline>
<text text-anchor="middle" x="419.23" y="-8.7" font-family="Times,serif" font-size="14.00">x[4,2]</text>
<polyline fill="none" stroke="black" points="444.15,-0.5 444.15,-50.1 "></polyline>
<text text-anchor="middle" x="543.79" y="-33.5" font-family="Times,serif" font-size="14.00">columna 3 - x[:, 3]</text>
<polyline fill="none" stroke="black" points="444.15,-25.3 643.44,-25.3 "></polyline>
<text text-anchor="middle" x="469.06" y="-8.7" font-family="Times,serif" font-size="14.00">x[1,3]</text>
<polyline fill="none" stroke="black" points="493.97,-0.5 493.97,-25.3 "></polyline>
<text text-anchor="middle" x="518.88" y="-8.7" font-family="Times,serif" font-size="14.00">x[2,3]</text>
<polyline fill="none" stroke="black" points="543.79,-0.5 543.79,-25.3 "></polyline>
<text text-anchor="middle" x="568.71" y="-8.7" font-family="Times,serif" font-size="14.00">x[3,3]</text>
<polyline fill="none" stroke="black" points="593.62,-0.5 593.62,-25.3 "></polyline>
<text text-anchor="middle" x="618.53" y="-8.7" font-family="Times,serif" font-size="14.00">x[4,3]</text>
<polyline fill="none" stroke="black" points="643.44,-0.5 643.44,-50.1 "></polyline>
<text text-anchor="middle" x="743.09" y="-33.5" font-family="Times,serif" font-size="14.00">columna 4 - x[:, 4]</text>
<polyline fill="none" stroke="black" points="643.44,-25.3 842.74,-25.3 "></polyline>
<text text-anchor="middle" x="668.35" y="-8.7" font-family="Times,serif" font-size="14.00">x[1,4]</text>
<polyline fill="none" stroke="black" points="693.27,-0.5 693.27,-25.3 "></polyline>
<text text-anchor="middle" x="718.18" y="-8.7" font-family="Times,serif" font-size="14.00">x[2,4]</text>
<polyline fill="none" stroke="black" points="743.09,-0.5 743.09,-25.3 "></polyline>
<text text-anchor="middle" x="768" y="-8.7" font-family="Times,serif" font-size="14.00">x[3,4]</text>
<polyline fill="none" stroke="black" points="792.92,-0.5 792.92,-25.3 "></polyline>
<text text-anchor="middle" x="817.83" y="-8.7" font-family="Times,serif" font-size="14.00">x[4,4]</text>
<polyline fill="none" stroke="black" points="842.74,-0.5 842.74,-50.1 "></polyline>
<text text-anchor="middle" x="865.52" y="-29.5" font-family="Times,serif" font-size="14.00">otros</text>
<text text-anchor="middle" x="865.52" y="-12.7" font-family="Times,serif" font-size="14.00">datos</text>
</g>
</g>
</svg>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-memoria-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.1: Esquema de una matriz en memoria.
</figcaption>
</figure>
</div>
</div>
</div>
<p>La representación precisa en memoria es significativa en el desempeño de operaciones matriciales como pueden ser el producto entre matrices o la inversión de las mismas. La manera como se acceden los datos es crucial en el diseño de los algoritmos.</p>
<p>El siguiente ejemplo define un vector <span class="math inline">\(u\)</span> de <span class="math inline">\(m\)</span> elementos y una matriz <span class="math inline">\(X\)</span> de tamaño <span class="math inline">\(m \times n\)</span>, ambos en un cubo unitario de 4 dimensiones, y define una función que selecciona el producto punto máximo del vector <span class="math inline">\(u\)</span> a los vectores columna de <span class="math inline">\(X\)</span>:</p>
<div id="cell-fig-getmaxdot" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mydot</span>(u, x)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> <span class="fl">0f0</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="fu">eachindex</span>(u, x)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> u[i] <span class="op">*</span> x[i]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  s</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">getmaxdot</span>(u<span class="op">::</span><span class="dt">Vector</span>, X<span class="op">::</span><span class="dt">Matrix</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  maxpos <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># en la siguiente linea, @view nos permite controlar que</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># no se copien los arreglos, y en su lugar, se usen referencias</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  maxdot <span class="op">=</span> <span class="fu">mydot</span>(u, <span class="pp">@view</span> X[<span class="op">:</span>, <span class="fl">1</span>])</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># obtiene el número de columnas e itera apartir del 2do indice </span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  mfilas, ncols <span class="op">=</span> <span class="fu">size</span>(X)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>ncols</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="fu">mydot</span>(u, <span class="pp">@view</span> X[<span class="op">:</span>, i]) </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> d <span class="op">&gt;</span> maxdot</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>      maxpos <span class="op">=</span> i</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>      maxdot <span class="op">=</span> d</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>  (maxpos, maxdot)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="fu">getmaxdot</span>(<span class="fu">rand</span>(<span class="dt">Float32</span>, <span class="fl">4</span>), <span class="fu">rand</span>(<span class="dt">Float32</span>, <span class="fl">4</span>, <span class="fl">1000</span>))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-getmaxdot" class="cell-output cell-output-display quarto-float quarto-figure quarto-figure-center anchored" data-execution_count="1">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-getmaxdot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-getmaxdot" class="cell-output cell-output-display" data-execution_count="1"><code>(704, 1.6600966f0)</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-getmaxdot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.2: Algoritmos para encotrar el vector columna con mayor producto en <span class="math inline">\(X\)</span> punto contra <span class="math inline">\(u\)</span>.
</figcaption>
</figure>
</div>
</div>
<p>En este código puede verse como se separa el cálculo del producto punto en una función, esto es porque en sí mismo es una operación importante; también podemos aislar de esta forma la manera que se accede (el orden) a los vectores. La idea fue acceder columna a columna, lo cuál asegura el uso apropiado de los accesos a memoria. En la función <span class="math inline">\(getmaxdot\)</span> se resuelve el problema de encontrar el máximo de un arreglo, y se puede observar que sin conocimiento adicional, este requiere <span class="math inline">\(O(n)\)</span> comparaciones, para una mátriz de <span class="math inline">\(n\)</span> columnas. Esto implica que cada producto punto se cuenta como <span class="math inline">\(O(1)\)</span>, lo cual simplifica el razonamiento. Por la función <span class="math inline">\(mydot\)</span> podemos observar que el producto punto tiene un costo de <span class="math inline">\(O(m)\)</span>, por lo que la <span class="math inline">\(getmaxdot\)</span> tiene un costo de <span class="math inline">\(O(mn)\)</span> operaciones lógicas y aritméticas.</p>
<p>El producto entre matrices es un caso paradigmático por su uso en la resolución de problemas prácticos, donde hay una gran cantidad de trabajo al rededor de los costos necesarios para llevarlo a cabo. En particular, el algoritmo naïve, es un algoritmo con costo cúbico, como se puede ver a continuación:</p>
<div id="cell-funcion-producto-matricial" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">myprod</span>(A<span class="op">::</span><span class="dt">Matrix</span>, B<span class="op">::</span><span class="dt">Matrix</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  mA, nA <span class="op">=</span> <span class="fu">size</span>(A)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  mB, nB <span class="op">=</span> <span class="fu">size</span>(B)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="pp">@assert</span> nA <span class="op">==</span> mB</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  C <span class="op">=</span> <span class="fu">Matrix</span><span class="dt">{Float32}</span>(<span class="cn">undef</span>, mA, nB)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>mA</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>mB</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>      rowA <span class="op">=</span> <span class="pp">@view</span> A[i, <span class="op">:</span>]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>      colB <span class="op">=</span> <span class="pp">@view</span> B[<span class="op">:</span>, i]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>      C[i, j] <span class="op">=</span> <span class="fu">mydot</span>(rowA, colB)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  C</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="fu">rand</span>(<span class="dt">Float32</span>, <span class="fl">5</span>, <span class="fl">3</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="fu">rand</span>(<span class="dt">Float32</span>, <span class="fl">3</span>, <span class="fl">5</span>)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> <span class="fu">myprod</span>(A, B)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="fu">display</span>(C)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="funcion-producto-matricial" class="cell-output cell-output-display">
<pre><code>5×5 Matrix{Float32}:
 0.591174  0.591174  0.591174   4.5468f-41   -1.99749f-21
 1.09659   1.09659   1.09659   -1.99746f-21   4.5468f-41
 0.777547  0.777547  0.777547   4.5468f-41   -4.36199f-22
 0.678665  0.678665  0.678665  -1.99748f-21   4.5468f-41
 0.418766  0.418766  0.418766   4.5468f-41    2.36936f-38</code></pre>
<p>Funciones sobre diferentes tipos de datos</p>
</div>
</div>
<p>Se pueden ver dos ciclos iterando a lo largo de filas y columnas, adicionalmente un producto punto, el cual tiene un costo lineal en la dimensión del vector, por lo que el costo es cúbico. Esta implementación es directa con la definición misma del producto matricial. Existen diferentes algoritmos para hacer esta operación más eficiente para diferentes casos o características de las matrices, siendo un área de investigación activa.</p>
</section>
<section id="listas" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="listas"><span class="header-section-number">3.5</span> Listas</h2>
<p>Las <em>listas</em> son estructuras de datos ordenadas lineales, esto es, no se asume que los elementos se guardan de manera contigua y los accesos al <span class="math inline">\(i\)</span>-ésimo elemento cuestan <span class="math inline">\(O(i)\)</span>. Se soportan inserciones y borrados. Por ejemplo, sea <span class="math inline">\(L = [a, b, c, d]\)</span> una lista con cuatro elementos, <span class="math inline">\(L_2 = b\)</span>, <span class="math inline">\(insert!(L, 2, z)\)</span> convertirá <span class="math inline">\(L = [a, z, b, c, d]\)</span> (note que <span class="math inline">\(b\)</span> se desplazó y no se reemplazó como se esperaría en un arreglo). La operación <span class="math inline">\(deleteat!(L, 2)\)</span> regresará la lista a su valor previo a la inserción. Estas operaciones que modifican la lista también tienen diferentes costos dependiendo de la posición, e.g., donde el inicio y final de la secuencia (también llamados <em>head/cabeza</em> y <em>tail/cola</em>) suelen ser más eficientes que accesos aleatorios, ya que se tienen referencias a estas posiciones en memoria. Es de especial importancia la navegación por la lista mediante operaciones de sucesor <span class="math inline">\(succ\)</span> y predecedor <span class="math inline">\(pred\)</span>, que pueden encadenarse para obtener acceso a los elementos. A diferencia de un arreglo, las listas no requieren una notación simple para acceso aleatorio a los elementos; los accesos típicos son a los extremos de la lista (cabeza y cola), sucesor y predecesor.</p>
<div class="cell" data-fig-width="80%" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-lista" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lista-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 513.09 235.14" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(36 199.14)">
<title>lista</title>
<polygon fill="white" stroke="transparent" points="-36,36 -36,-199.14 477.09,-199.14 477.09,36 -36,36"></polygon>
<!-- list -->
<g id="node1" class="node">
<title>list</title>
<polygon fill="none" stroke="black" points="0,-72.57 0,-122.17 54,-122.17 54,-72.57 0,-72.57"></polygon>
<text text-anchor="middle" x="26.71" y="-105.57" font-family="Times,serif" font-size="14.00">head</text>
<polyline fill="none" stroke="black" points="0,-97.37 54,-97.37 "></polyline>
<text text-anchor="middle" x="26.94" y="-80.77" font-family="Times,serif" font-size="14.00">tail</text>
</g>
<!-- a -->
<g id="node2" class="node">
<title>a</title>
<polygon fill="none" stroke="black" points="90,-107.37 90,-143.37 144,-143.37 144,-107.37 90,-107.37"></polygon>
<text text-anchor="middle" x="104.11" y="-121.27" font-family="Times,serif" font-size="14.00">a</text>
<polyline fill="none" stroke="black" points="118.21,-107.57 118.21,-143.37 "></polyline>
<text text-anchor="middle" x="130.96" y="-121.27" font-family="Times,serif" font-size="14.00"> </text>
</g>
<!-- list&#45;&gt;a -->
<g id="edge1" class="edge">
<title>list:n-&gt;a:n</title>
<path fill="none" stroke="black" stroke-dasharray="5,2" d="M27,-123.37C27,-154.96 88.08,-175.07 101.44,-154.04"></path>
<polygon fill="black" stroke="black" points="104.82,-154.93 104,-144.37 98.06,-153.14 104.82,-154.93"></polygon>
</g>
<!-- c -->
<g id="node4" class="node">
<title>c</title>
<polygon fill="none" stroke="black" points="270,-107.37 270,-143.37 324,-143.37 324,-107.37 270,-107.37"></polygon>
<text text-anchor="middle" x="284.11" y="-121.27" font-family="Times,serif" font-size="14.00">c</text>
<polyline fill="none" stroke="black" points="298.21,-107.57 298.21,-143.37 "></polyline>
<text text-anchor="middle" x="310.96" y="-121.27" font-family="Times,serif" font-size="14.00"> </text>
</g>
<!-- list&#45;&gt;c -->
<g id="edge2" class="edge">
<title>list:s-&gt;c:s</title>
<path fill="none" stroke="black" stroke-dasharray="5,2" d="M27,-71.37C27,40.42 268.67,10.89 283.31,-96.12"></path>
<polygon fill="black" stroke="black" points="279.83,-96.63 284,-106.37 286.82,-96.16 279.83,-96.63"></polygon>
</g>
<!-- b -->
<g id="node3" class="node">
<title>b</title>
<polygon fill="none" stroke="black" points="180,-107.37 180,-143.37 234,-143.37 234,-107.37 180,-107.37"></polygon>
<text text-anchor="middle" x="194" y="-121.27" font-family="Times,serif" font-size="14.00">b</text>
<polyline fill="none" stroke="black" points="208,-107.57 208,-143.37 "></polyline>
<text text-anchor="middle" x="220.75" y="-121.27" font-family="Times,serif" font-size="14.00"> </text>
</g>
<!-- a&#45;&gt;b -->
<g id="edge3" class="edge">
<title>a:c-&gt;b:w</title>
<path fill="none" stroke="black" d="M131,-125.37C131,-125.37 150.56,-125.37 169.78,-125.37"></path>
<polygon fill="black" stroke="black" points="170,-128.87 180,-125.37 170,-121.87 170,-128.87"></polygon>
</g>
<!-- b&#45;&gt;c -->
<g id="edge4" class="edge">
<title>b:c-&gt;c:w</title>
<path fill="none" stroke="black" d="M221,-125.37C221,-125.37 240.56,-125.37 259.78,-125.37"></path>
<polygon fill="black" stroke="black" points="260,-128.87 270,-125.37 260,-121.87 260,-128.87"></polygon>
</g>
<!-- nothing -->
<g id="node5" class="node">
<title>nothing</title>
<ellipse fill="none" stroke="black" stroke-dasharray="5,2" cx="400.54" cy="-125.37" rx="40.59" ry="18"></ellipse>
<text text-anchor="middle" x="400.54" y="-121.17" font-family="Times,serif" font-size="14.00">nothing</text>
</g>
<!-- c&#45;&gt;nothing -->
<g id="edge5" class="edge">
<title>c:c-&gt;nothing</title>
<path fill="none" stroke="black" d="M311,-125.37C311,-125.37 329.56,-125.37 349.68,-125.37"></path>
<polygon fill="black" stroke="black" points="349.93,-128.87 359.93,-125.37 349.93,-121.87 349.93,-128.87"></polygon>
</g>
</g>
</svg>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lista-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.3: Una lista ligada simple
</figcaption>
</figure>
</div>
</div>
</div>
<p>La <a href="#fig-lista" class="quarto-xref">Figura&nbsp;<span>3.3</span></a> muestra una lista ligada, que es una implementación de lista que puede crecer fácilmente, funciona en el <em>heap</em> de memoria por lo que cada bloque requiere memoria dinámica. Cada bloque es una estructura; se pueden distinguir dos tipos, la lista que contiene referencias al primer nodo y al último nodo. Los <em>nodos de de datos</em> contienen los elementos de la colección y referencias al siguiente nodo, también llamado <em>sucesor</em>. El nodo <em>nothing</em> es especial y significa que no hay más elementos.</p>
<p>El siguiente código muestra como la definición de lista ligada.</p>
<div id="12" class="cell" data-execution_count="1">
<div id="lst-lista-ligada" class="julia cell-code listing quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-lista-ligada-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listado&nbsp;3.1: Código para una lista ligada simple
</figcaption>
<div aria-describedby="lst-lista-ligada-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode cell-code" id="lst-lista-ligada"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="lst-lista-ligada-1"><a href="#lst-lista-ligada-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node</span>
<span id="lst-lista-ligada-2"><a href="#lst-lista-ligada-2" aria-hidden="true" tabindex="-1"></a>  data<span class="op">::</span><span class="dt">Int</span></span>
<span id="lst-lista-ligada-3"><a href="#lst-lista-ligada-3" aria-hidden="true" tabindex="-1"></a>  next<span class="op">::</span><span class="dt">Union{Node,Nothing}</span></span>
<span id="lst-lista-ligada-4"><a href="#lst-lista-ligada-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="lst-lista-ligada-5"><a href="#lst-lista-ligada-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-lista-ligada-6"><a href="#lst-lista-ligada-6" aria-hidden="true" tabindex="-1"></a>node <span class="op">=</span> <span class="fu">Node</span>(<span class="fl">10</span>, <span class="fu">Node</span>(<span class="fl">20</span>, <span class="fu">Node</span>(<span class="fl">30</span>, <span class="cn">nothing</span>)))</span>
<span id="lst-lista-ligada-7"><a href="#lst-lista-ligada-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-lista-ligada-8"><a href="#lst-lista-ligada-8" aria-hidden="true" tabindex="-1"></a><span class="fu">println</span>(node)</span>
<span id="lst-lista-ligada-9"><a href="#lst-lista-ligada-9" aria-hidden="true" tabindex="-1"></a>(node.data, node.next.data, node.next.next.data)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Node(10, Node(20, Node(30, nothing)))</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>(10, 20, 30)</code></pre>
</div>
</div>
<p>En el <a href="#lst-lista-ligada" class="quarto-xref">Listado&nbsp;<span>3.1</span></a> se ignora la referencia a <em>tail</em> (<em>head</em> se guarda en <em>node</em>), por lo que las operaciones sobre <em>tail</em> requieren recorrer la lista completa, costando <span class="math inline">\(O(n)\)</span> en el peor caso para una lista de <span class="math inline">\(n\)</span> elementos.</p>
<p>Por su manera en la cual son accedidos los datos, se tienen dos tipos de listas muy útiles: las <em>colas</em> y las <em>pilas</em>. Las <em>colas</em> son listas que se acceden solo por sus extremos, y emulan la política de <em>el primero en entrar es el primero en salir</em> (first in - first out, FIFO), y es por eso que se les llama colas haciendo referencia a una cola para realizar un trámite o recibir un servicio. Las <em>pilas</em> o <em>stack</em> son listas con la política <em>el último en entrar es el primero en salir</em> (last in - first out, LIFO). Mientras que cualquier lista puede ser útil para implementarlas, algunas maneras serán mejores que otras dependiendo de los requerimientos de los problemas siendo resueltos; sin embargo, es importante recordar sus políticas de acceso para comprender los algoritmos que las utilicen.</p>
<p>Entre las operaciones comunes tenemos las siguientes:</p>
<ul>
<li><em>push!(L, a)</em>: insertar <span class="math inline">\(a\)</span> al final de la lista <span class="math inline">\(L\)</span>.</li>
<li><em>pop!(L)</em>: remueve el último elemento en <span class="math inline">\(L\)</span>.</li>
<li><em>deleteat!(L, pos)</em>: remueve el elemento en la posición <span class="math inline">\(pos\)</span>, se desplazan los elementos.</li>
<li><em>insert!(L, pos, valor)</em>: inserta <span class="math inline">\(valor\)</span> en la posición <span class="math inline">\(pos\)</span> desplazando los elementos anteriores.</li>
</ul>
<section id="ejercicios" class="level4" data-number="3.5.0.1">
<h4 data-number="3.5.0.1" class="anchored" data-anchor-id="ejercicios"><span class="header-section-number">3.5.0.1</span> Ejercicios</h4>
<ul>
<li>Implemente <em>insert!</em> y <em>deleteat!</em></li>
<li>¿Cuál sería la implementación de <em>succ</em> y <em>pred</em> en una lista ligada?</li>
<li>¿Cuales serían sus costos?</li>
<li>Añadiendo más memoria, como podemos mejorar <em>pred</em>?</li>
</ul>
</section>
</section>
<section id="grafos" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="grafos"><span class="header-section-number">3.6</span> Grafos</h2>
<p>Otras estructuras de datos elementales son los <em>grafos</em>. Un grafo <span class="math inline">\(G = (V, E)\)</span> es una tupla compuesta por un conjunto de vertices <span class="math inline">\(V\)</span> y el conjunto de aristas <span class="math inline">\(E\)</span>. Por ejemplo, el grafo con <span class="math inline">\(A = (\{a, b, c, d\}, \{(a, b), (b, c), (c, d), (d, a)\})\)</span></p>
<div class="cell" data-fig-width="80%" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-grafo" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-grafo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 396.00 145.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(36 109)">
<title>lista</title>
<polygon fill="white" stroke="transparent" points="-36,36 -36,-109 360,-109 360,36 -36,36"></polygon>
<!-- a -->
<g id="node1" class="node">
<title>a</title>
<ellipse fill="none" stroke="black" cx="27" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00">a</text>
</g>
<!-- b -->
<g id="node2" class="node">
<title>b</title>
<ellipse fill="none" stroke="black" cx="117" cy="-55" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="117" y="-50.8" font-family="Times,serif" font-size="14.00">b</text>
</g>
<!-- a&#45;&gt;b -->
<g id="edge1" class="edge">
<title>a-&gt;b</title>
<path fill="none" stroke="black" d="M50.21,-27.34C60.52,-31.67 72.98,-36.91 84.27,-41.66"></path>
<polygon fill="black" stroke="black" points="83.23,-45.02 93.8,-45.67 85.94,-38.56 83.23,-45.02"></polygon>
</g>
<!-- c -->
<g id="node3" class="node">
<title>c</title>
<ellipse fill="none" stroke="black" cx="207" cy="-55" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="207" y="-50.8" font-family="Times,serif" font-size="14.00">c</text>
</g>
<!-- b&#45;&gt;c -->
<g id="edge2" class="edge">
<title>b-&gt;c</title>
<path fill="none" stroke="black" d="M144.4,-55C152.39,-55 161.31,-55 169.82,-55"></path>
<polygon fill="black" stroke="black" points="169.92,-58.5 179.92,-55 169.92,-51.5 169.92,-58.5"></polygon>
</g>
<!-- d -->
<g id="node4" class="node">
<title>d</title>
<ellipse fill="none" stroke="black" cx="297" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="297" y="-13.8" font-family="Times,serif" font-size="14.00">d</text>
</g>
<!-- c&#45;&gt;d -->
<g id="edge3" class="edge">
<title>c-&gt;d</title>
<path fill="none" stroke="black" d="M230.21,-45.66C240.52,-41.33 252.98,-36.09 264.27,-31.34"></path>
<polygon fill="black" stroke="black" points="265.94,-34.44 273.8,-27.33 263.23,-27.98 265.94,-34.44"></polygon>
</g>
<!-- d&#45;&gt;a -->
<g id="edge4" class="edge">
<title>d-&gt;a</title>
<path fill="none" stroke="black" d="M269.71,-18C221.6,-18 119.3,-18 64.48,-18"></path>
<polygon fill="black" stroke="black" points="64.18,-14.5 54.18,-18 64.18,-21.5 64.18,-14.5"></polygon>
</g>
</g>
</svg>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-grafo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.4: Un grafo dirigido simple
</figcaption>
</figure>
</div>
</div>
</div>
<p>Los grafos son herramientas poderosas para representar de manera abstracta problemas que implican relaciones entre elementos. En algunos casos es útil asociar funciones a los vértices y las aristas. Tenga en cuenta los siguientes ejemplos:</p>
<ul>
<li><span class="math inline">\(peso: V \rightarrow \mathbb{R}\)</span>, la cual podría usarse como <span class="math inline">\(peso(a) = 1.5\)</span>.</li>
<li><span class="math inline">\(costo: V \times V \rightarrow \mathbb{R}\)</span>, la cual podría usarse como <span class="math inline">\(costo(a, b) = 2.0\)</span>.</li>
</ul>
<p>La estructura del grafo puede accederse mediante las funciones:</p>
<ul>
<li><span class="math inline">\(in(G, v) = \{ u \mid (u, v) \in E\}\)</span></li>
<li><span class="math inline">\(out(G, u) = \{ v \mid (u, v) \in E\}\)</span></li>
</ul>
<p>así como el número de vertices que entran y salen como:</p>
<ul>
<li><span class="math inline">\(indegree(G, v) = |in(G, v)|\)</span>.</li>
<li><span class="math inline">\(outdegree(G, u) = |out(G, u)|\)</span>.</li>
</ul>
<p>Un grafo puede tener aristas no dirigidas, el grafo con <span class="math inline">\(B=(\{a, b, c, d\}, \{\{a, b\}, \{b, c\}, \{c, d\}, \{d, a\}\})\)</span>, no reconocerá orden en las aristas.</p>
<div class="cell" data-fig-width="60%" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-grafo-nodirigido" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-grafo-nodirigido-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 396.00 145.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(36 109)">
<title>lista</title>
<polygon fill="white" stroke="transparent" points="-36,36 -36,-109 360,-109 360,36 -36,36"></polygon>
<!-- a -->
<g id="node1" class="node">
<title>a</title>
<ellipse fill="none" stroke="black" cx="27" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00">a</text>
</g>
<!-- b -->
<g id="node2" class="node">
<title>b</title>
<ellipse fill="none" stroke="black" cx="117" cy="-55" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="117" y="-50.8" font-family="Times,serif" font-size="14.00">b</text>
</g>
<!-- a&#45;&#45;b -->
<g id="edge1" class="edge">
<title>a--b</title>
<path fill="none" stroke="black" d="M50.21,-27.34C63.55,-32.95 80.46,-40.06 93.8,-45.67"></path>
</g>
<!-- c -->
<g id="node3" class="node">
<title>c</title>
<ellipse fill="none" stroke="black" cx="207" cy="-55" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="207" y="-50.8" font-family="Times,serif" font-size="14.00">c</text>
</g>
<!-- b&#45;&#45;c -->
<g id="edge2" class="edge">
<title>b--c</title>
<path fill="none" stroke="black" d="M144.4,-55C155.64,-55 168.72,-55 179.92,-55"></path>
</g>
<!-- d -->
<g id="node4" class="node">
<title>d</title>
<ellipse fill="none" stroke="black" cx="297" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="297" y="-13.8" font-family="Times,serif" font-size="14.00">d</text>
</g>
<!-- c&#45;&#45;d -->
<g id="edge3" class="edge">
<title>c--d</title>
<path fill="none" stroke="black" d="M230.21,-45.66C243.55,-40.05 260.46,-32.94 273.8,-27.33"></path>
</g>
<!-- d&#45;&#45;a -->
<g id="edge4" class="edge">
<title>d--a</title>
<path fill="none" stroke="black" d="M269.71,-18C218.39,-18 105.42,-18 54.18,-18"></path>
</g>
</g>
</svg>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-grafo-nodirigido-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.5: Un grafo cuyas aristas no estan dirigidas
</figcaption>
</figure>
</div>
</div>
</div>
<p>Por lo tanto, podremos decir que <span class="math inline">\((a, b) \in E_A\)</span> pero <span class="math inline">\((b, a) \not\in E_A\)</span>. Por otro lado tenemos que <span class="math inline">\(\{a, b\} \in E_B\)</span>, y forzando un poco la notación, <span class="math inline">\((a, b) \in E_B\)</span>, <span class="math inline">\((b, a) \in E_B\)</span>; para los conjuntos de aristas de <span class="math inline">\(A\)</span> y <span class="math inline">\(B\)</span>. La estructura puede ser accedida mediante <span class="math inline">\(neighbors(G, u) = \{ v \mid \{u, v\} \in E \}\)</span>.</p>
<p>Un grafo puede estar representado de diferentes maneras, por ejemplo, un arreglo bidimensional (matriz), donde <span class="math inline">\(S_{ij} = 1\)</span> si hay una arista entre los vértices <span class="math inline">\(i\)</span> y <span class="math inline">\(j\)</span>; y <span class="math inline">\(S_{ij} = 0\)</span> si no existe una arista. A esta representación se le llama matriz de adjacencia. Si el grafo tiene pocos <span class="math inline">\(1\)</span>’s vale la pena tener una representación diferente; este es el caso de las listas de adjacencia, donde se representa cada fila o cada columna de la matriz de adjacencia como una lista de los elementos diferentes de cero.</p>
<p>Existen otras representaciones como la lista de coordenadas, <em>coordinate lists</em> (COO), o las representaciones dispersas compimidas, <em>sparse row</em> (CSR) y <em>compressed sparse column</em> (CSC) <span class="citation" data-cites="Scott2023">(<a href="refs.html#ref-Scott2023" role="doc-biblioref">Scott y Tůma 2023</a>)</span>. Todas estas representaciones tratan de disminuir el uso de memoria y aprovechar la gran dispersión para realizar operaciones solo cuando sea estrictamente necesario.</p>
<p>Un <em>árbol</em> es un grafo en el cual no existen ciclos, esto es, no existe forma que en una caminata sobre los vértices, a traves de las aristas y prohibiendo <em>regresarse</em> aristas, es imposible regresar a un vértice antes visto.</p>
<div class="cell" data-fig-width="60%" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-arbol" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-arbol-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 306.00 252.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(36 216)">
<title>lista</title>
<polygon fill="white" stroke="transparent" points="-36,36 -36,-216 270,-216 270,36 -36,36"></polygon>
<!-- a -->
<g id="node1" class="node">
<title>a</title>
<ellipse fill="none" stroke="black" cx="27" cy="-126" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="27" y="-121.8" font-family="Times,serif" font-size="14.00">a</text>
</g>
<!-- b -->
<g id="node2" class="node">
<title>b</title>
<ellipse fill="none" stroke="black" cx="117" cy="-162" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="117" y="-157.8" font-family="Times,serif" font-size="14.00">b</text>
</g>
<!-- a&#45;&#45;b -->
<g id="edge1" class="edge">
<title>a--b</title>
<path fill="none" stroke="black" d="M50.66,-135.27C63.8,-140.65 80.29,-147.39 93.41,-152.76"></path>
</g>
<!-- d -->
<g id="node4" class="node">
<title>d</title>
<ellipse fill="none" stroke="black" cx="117" cy="-90" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="117" y="-85.8" font-family="Times,serif" font-size="14.00">d</text>
</g>
<!-- a&#45;&#45;d -->
<g id="edge3" class="edge">
<title>a--d</title>
<path fill="none" stroke="black" d="M50.66,-116.73C63.8,-111.35 80.29,-104.61 93.41,-99.24"></path>
</g>
<!-- c -->
<g id="node3" class="node">
<title>c</title>
<ellipse fill="none" stroke="black" cx="207" cy="-162" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="207" y="-157.8" font-family="Times,serif" font-size="14.00">c</text>
</g>
<!-- b&#45;&#45;c -->
<g id="edge2" class="edge">
<title>b--c</title>
<path fill="none" stroke="black" d="M144.4,-162C155.64,-162 168.72,-162 179.92,-162"></path>
</g>
<!-- e -->
<g id="node5" class="node">
<title>e</title>
<ellipse fill="none" stroke="black" cx="207" cy="-90" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="207" y="-85.8" font-family="Times,serif" font-size="14.00">e</text>
</g>
<!-- d&#45;&#45;e -->
<g id="edge4" class="edge">
<title>d--e</title>
<path fill="none" stroke="black" d="M144.4,-90C155.64,-90 168.72,-90 179.92,-90"></path>
</g>
<!-- f -->
<g id="node6" class="node">
<title>f</title>
<ellipse fill="none" stroke="black" cx="207" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="207" y="-13.8" font-family="Times,serif" font-size="14.00">f</text>
</g>
<!-- d&#45;&#45;f -->
<g id="edge5" class="edge">
<title>d--f</title>
<path fill="none" stroke="black" d="M134.97,-76.12C150.55,-63.37 173.52,-44.58 189.08,-31.84"></path>
</g>
</g>
</svg>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-arbol-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.6: Árbol con aristas no dirigidas
</figcaption>
</figure>
</div>
</div>
</div>
<p>En algunos casos, es conveniente identificar vértices especiales en un árbol <span class="math inline">\(T=(V, E)\)</span>. Un vértice es la <em>raíz</em> del árbol, <span class="math inline">\(root(T)\)</span>, es especial ya que seguramente se utilizará como acceso al árbol y por tanto contiene un camino a cada uno vértices en <span class="math inline">\(V\)</span>. Cada vértice puede tener, o no, <em>hijos</em> <span class="math inline">\(children(T, u) = \{ v \mid (u, v) \in E \}\)</span>. Se dice que <span class="math inline">\(u\)</span> es un <em>hoja</em> (leaf) si <span class="math inline">\(children(T, u) = \emptyset\)</span>, e <em>interno</em> (inner) si no es ni raíz ni hoja.</p>
<div class="cell" data-fig-width="60%" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-arbol-dirigido" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-arbol-dirigido-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 306.00 252.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(36 216)">
<title>lista</title>
<polygon fill="white" stroke="transparent" points="-36,36 -36,-216 270,-216 270,36 -36,36"></polygon>
<!-- a -->
<g id="node1" class="node">
<title>a</title>
<ellipse fill="none" stroke="black" cx="27" cy="-126" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="27" y="-121.8" font-family="Times,serif" font-size="14.00">a</text>
</g>
<!-- b -->
<g id="node2" class="node">
<title>b</title>
<ellipse fill="none" stroke="black" cx="117" cy="-162" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="117" y="-157.8" font-family="Times,serif" font-size="14.00">b</text>
</g>
<!-- a&#45;&gt;b -->
<g id="edge1" class="edge">
<title>a-&gt;b</title>
<path fill="none" stroke="black" d="M50.66,-135.27C60.82,-139.43 72.99,-144.4 84.05,-148.93"></path>
<polygon fill="black" stroke="black" points="82.83,-152.21 93.41,-152.76 85.48,-145.73 82.83,-152.21"></polygon>
</g>
<!-- d -->
<g id="node4" class="node">
<title>d</title>
<ellipse fill="none" stroke="black" cx="117" cy="-90" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="117" y="-85.8" font-family="Times,serif" font-size="14.00">d</text>
</g>
<!-- a&#45;&gt;d -->
<g id="edge3" class="edge">
<title>a-&gt;d</title>
<path fill="none" stroke="black" d="M50.66,-116.73C60.82,-112.57 72.99,-107.6 84.05,-103.07"></path>
<polygon fill="black" stroke="black" points="85.48,-106.27 93.41,-99.24 82.83,-99.79 85.48,-106.27"></polygon>
</g>
<!-- c -->
<g id="node3" class="node">
<title>c</title>
<ellipse fill="none" stroke="black" cx="207" cy="-162" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="207" y="-157.8" font-family="Times,serif" font-size="14.00">c</text>
</g>
<!-- b&#45;&gt;c -->
<g id="edge2" class="edge">
<title>b-&gt;c</title>
<path fill="none" stroke="black" d="M144.4,-162C152.39,-162 161.31,-162 169.82,-162"></path>
<polygon fill="black" stroke="black" points="169.92,-165.5 179.92,-162 169.92,-158.5 169.92,-165.5"></polygon>
</g>
<!-- e -->
<g id="node5" class="node">
<title>e</title>
<ellipse fill="none" stroke="black" cx="207" cy="-90" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="207" y="-85.8" font-family="Times,serif" font-size="14.00">e</text>
</g>
<!-- d&#45;&gt;e -->
<g id="edge4" class="edge">
<title>d-&gt;e</title>
<path fill="none" stroke="black" d="M144.4,-90C152.39,-90 161.31,-90 169.82,-90"></path>
<polygon fill="black" stroke="black" points="169.92,-93.5 179.92,-90 169.92,-86.5 169.92,-93.5"></polygon>
</g>
<!-- f -->
<g id="node6" class="node">
<title>f</title>
<ellipse fill="none" stroke="black" cx="207" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="207" y="-13.8" font-family="Times,serif" font-size="14.00">f</text>
</g>
<!-- d&#45;&gt;f -->
<g id="edge5" class="edge">
<title>d-&gt;f</title>
<path fill="none" stroke="black" d="M134.97,-76.12C148.12,-65.36 166.52,-50.3 181.3,-38.21"></path>
<polygon fill="black" stroke="black" points="183.56,-40.88 189.08,-31.84 179.13,-35.46 183.56,-40.88"></polygon>
</g>
</g>
</svg>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-arbol-dirigido-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.7: Árbol con aristas dirigidas, note que es fácil saber si hay un vértice o nodo que se distinga como raíz, o nodos que sean hojas.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Al igual que en los grafos más generales, en los árboles es útil definir funciones sobre vértices y aristas, así como marcar tipos de vértices, e.g., posición u color, que simplifiquen el razonamiento para con los algoritmos asociados.</p>
<p>Los nodos y las aristas de un grafo pueden <em>recorrerse</em> de diferentes maneras, donde se aprovechan las relaciones representadas. En un grafo general podría ser importante solo visitar una vez cada vértice, o guiarse en el recorrido por alguna heurística o función asociada a vértices o aristas.</p>
<p>El recorrido <em>primero a lo profundo</em>, Depth First Search (DFS), comienza en un nodo dado y de manera <em>voraz</em> avanzará recordando orden de visita y avanzando al ver un nuevo nodo repitiendo el procedimiento hasta que todos los vértices alcanzables sean visitados. El siguiente pseudo-código lo implementa:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#| lst-label: lst-dfs</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">#| lst-cap: Psudo-código DFS</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">operación!</span>(vértice)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#... operaciones sobre el vértice siendo visitado ...</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">DFS</span>(grafo, vértice, visitados)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">operación!</span>(vértice)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">push!</span>(visitados, vértice)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> v <span class="kw">in</span> <span class="fu">neighbors</span>(grafo, vértice)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="op">∉</span> visitados</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>      <span class="fu">operación!</span>(v)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">push!</span>(visitados, v)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>      <span class="fu">DFS</span>(grafo, v, visitados)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co"># ... código de preparación del grafo</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>visitados <span class="op">=</span> <span class="fu">Set</span>()</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="fu">DFS</span>((vértices, aristas), vérticeinicial, visitados)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co"># ... código posterior a la visita DFS</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Las llamadas recursivas a DFS tienen el efecto de <em>memorizar</em> el orden de visita anterior y <em>recordarlo</em> cuando se sale de una visita anidada. Entonces, hay una memoria implicita utilizada, implementanda por el <em>stack</em> de llamadas. La función <em>operación!</em> es una abstracción de cualquier cosa que deba hacerse sobre los nodos siendo visitados.</p>
<p>El <em>recorrido a lo ancho</em>, Breadth First Search (BSF), visita los vértices locales primero que los alejados contrarío al avance voraz utilizado por DFS.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">#| lst-label: lst-bfs</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">#| lst-cap: Psudo-código BFS</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">BFS</span>(grafo, vértice, visitados, cola)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">operación!</span>(vértice)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">push!</span>(visitados, vértice)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">push!</span>(cola, vértice)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="fu">length</span>(cola) <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> <span class="fu">popfirst!</span>(cola)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> <span class="fu">neighbors</span>(grafo, u)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> v <span class="op">∉</span> visitados</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="fu">operación!</span>(v)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">push!</span>(visitados, v)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">push!</span>(cola, v)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="co"># ... código de preparación del grafo</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>visitados <span class="op">=</span> <span class="fu">Set</span>()</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="fu">BFS</span>((vértices, aristas), vérticeinicial, visitados)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="co"># ... código posterior a la visita BFS</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>El BFS hace uso explícito de la memoria para guardar el orden en que se visitarán los vértices (<em>cola</em>); se utiliza un conjunto para marcar vértices ya visitados (<em>visitados</em>) con la finalidad de evitar un recorrido infinito.</p>
<section id="ejercicios-1" class="level4" data-number="3.6.0.1">
<h4 data-number="3.6.0.1" class="anchored" data-anchor-id="ejercicios-1"><span class="header-section-number">3.6.0.1</span> Ejercicios</h4>
<ul>
<li>Implemente un grafo dirigido mediante listas de adyacencia.</li>
<li>Implemente un grafo no dirigido mediante lista de adyacencia.</li>
<li>Implemente el algoritmo de recorrido DFS y BFS con implementaciones de grafos.</li>
</ul>
</section>
</section>
<section id="actividades" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="actividades"><span class="header-section-number">3.7</span> Actividades</h2>
<p>Implementar los siguientes algoritmos sobre matrices. - Multiplicación de matrices - Eliminación gaussiana / Gauss-Jordan Compare los desempeños de ambos algoritmos contando el número de operaciones y el tiempo real para matrices aleatorias de tamaño ( n n ) para ( n= 100, 300, 1000). Maneje de manera separada los datos de conteo de operaciones (multiplicaciones y sumas escalares) y las de tiempo real. Discuta sus resultados experimentales; ¿qué puede concluir? ¿Cuál es el impacto de acceder los elementos contiguos en memoria de una matriz? ¿Qué cambiaría si utiliza matrices dispersas? ¿Cuáles serían los costos?</p>
<p><strong>Entregable</strong></p>
<p>Su trabajo se entregará en PDF y con el notebook fuente; deberá estar plenamente documentado, con una estructura que permita a un lector interesado entender el problema, sus experimentos y metodología, así como sus conclusiones. Tenga en cuenta que los notebooks pueden alternar celdas de texto y código.</p>
<p>No olvide estructurar su reporte, en particular el reporte debe cubrir los siguientes puntos:</p>
<ul>
<li>Título del reporte, su nombre.</li>
<li>Introducción.</li>
<li>Código cercano a la presentación de resultados.</li>
<li>Figuras y tablas</li>
<li>Análisis de los resultados</li>
<li>Conclusión, discusiones de las preguntas</li>
<li>Lista de referencias. Nota, una lista de referencias que no fueron utilizadas en el cuerpo del texto será interpretada como una lista vacía.</li>
</ul>
</section>
<section id="bibliografía" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="bibliografía"><span class="header-section-number">3.8</span> Bibliografía</h2>
<p>Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2022). Introduction to Algorithms (2nd ed.). MIT Press.</p>
<ul>
<li>Parte III: Cap 10 Elementary Data Structures.</li>
<li>Parte VI: Cap 22 Elementary Graph Algorithms.</li>
<li>Parte VII: Cap 28 Matrix Operations.</li>
</ul>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-Scott2023" class="csl-entry" role="listitem">
Scott, Jennifer, y Miroslav Tůma. 2023. <span>“An Introduction to Sparse Matrices”</span>. En <em>Algorithms for Sparse Linear Systems</em>, 1–18. Cham: Springer International Publishing. <a href="https://doi.org/10.1007/978-3-031-25820-6_1">https://doi.org/10.1007/978-3-031-25820-6_1</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/sadit\.github\.io\/ALGO-IR");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./cap2-analisis.html" class="pagination-link" aria-label="Introducción al análisis de algoritmos con Julia">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introducción al análisis de algoritmos con Julia</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./cap4-ordenamiento.html" class="pagination-link" aria-label="Algoritmos de ordenamiento">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Algoritmos de ordenamiento</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Ejecutar el código</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb13" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> julia</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="an">lang:</span><span class="co"> es-MX</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="fu"># Estructuras de datos elementales {#sec-estructuras}</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="fu">## Objetivo {.unnumbered}</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>Implementar, aplicar y caracterizar el desempeño de algoritmos en peor caso y adaptativos para búsqueda en arreglos ordenados. Se discutirán estructuras de datos básicas que serán de gran utilidad al momento de construir programas y de resolver problemas más complejos; nos enfocaremos en las estructuras de datos.</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introducción</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>En esta unidad se discutirán las propiedades y operaciones básicas de estructuras como conjuntos, listas, pilas, colas, arreglos, vectores, matrices y matrices dispersas. Los ejemplos de código se muestran en el lenguaje de programación Julia, pero que puede ser traducido fácilmente en otros lenguajes de programación. </span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conjuntos</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>Los _conjuntos_ son estructuras abstractas que representan una colección de elementos, en particular, dado las posibles aplicaciones un conjunto puede tener contenido inmutable o mutable. Un conjunto puede estar vacio ($\emptyset$) o contener elementos, e.g., $\{a, b, c\}$. La operación _unión_ $\cup$ construye un nuevo conjunto a partir de otros $<span class="sc">\{</span>a, b<span class="sc">\}</span> \cup <span class="sc">\{</span>c<span class="sc">\}</span> = <span class="sc">\{</span>a, b, c<span class="sc">\}</span>$; la intersección se indica con el operador $\cap$, e.g. $<span class="sc">\{</span>a, b, c<span class="sc">\}</span> \cap <span class="sc">\{</span>b, d<span class="sc">\}</span> = <span class="sc">\{</span>b<span class="sc">\}</span>$. El tamaño de una colección lo representamos con barras, e.g., $|<span class="sc">\{</span>a, b<span class="sc">\}</span>| = 2$. También es útil consultar por membresia $a \in <span class="sc">\{</span>a, b, c<span class="sc">\}</span>$ o por su negación, i.e., $d \not\in <span class="sc">\{</span>a, b, c<span class="sc">\}</span>$. Es común usar conjuntos mutables en diferentes algoritmos, esto es, que permitan inserciones y borrados sobre la misma estructura; desde el punto de vista de eficiencia, esto puede reducir las operaciones de manipulación de datos así como de la gestión de memoria. Suponga el conjunto $S = <span class="sc">\{</span>a, b, c<span class="sc">\}</span>$, la función $pop!(S, b)$ resultaría en $<span class="sc">\{</span>a, c<span class="sc">\}</span>$, y la función $push!(S, d)$ resultaría en $<span class="sc">\{</span>a, c, d<span class="sc">\}</span>$ al encadenar estas operaciones. Note que el símbolo $!$ solo se esta usando en cooncordancia con el lenguaje de programación Julia para indicar que la función cambiaría el argumento de entrada; es una convención, no un operador en sí mismo. Note que estamos usando una sintaxis muy sencilla $fun(arg1, arg2, ...)$ para indicar la aplicación de una función u operación a una serie de argumentos.</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>Hay múltiples formas de representar conjuntos ya que los requerimientos de los algoritmos son diversos y tener la representación correcta puede ser una diferencia importante en el rendimiento. Las implementaciones y algoritmos alrededor pueden llegar a ser muy sofisticados, dependiendo de las características que se desean, algunas de las cuales serán el centro de estudio de este curso.</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="fu">## Tuplas y estructuras</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>Las _tuplas_ son colecciones abstractas ordenadas, donde incluso puede haber repetición, pueden verse como una secuencia de elementos, e.g., $S = (a, b, c)$; podemos referirnos a la $i$ésima posición de la forma $S_i$, o incluso $S<span class="co">[</span><span class="ot">i</span><span class="co">]</span>$, si el contexto lo amerita, e.g., pseudo-código que pueda ser transferido a un lenguaje de programación más fácilmente. Es común que cada parte de la tupla pueda contener cierto tipo de dato, e.g., enteros, números de punto flotante, símbolos, cadenas de carácteres, etc. Una tupla es muy amena para ser representada de manera contigua en memoria. En el lenguaje de programación Julia, las tuplas se representan entre paréntesis, e.g., $(1, 2, 3)$.</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: codigo-acceso-tupla</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: |</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a><span class="in">#|   Definición y acceso a los campos de una tupla en Julia</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a><span class="in">t = (10, 20, 30)</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a><span class="in">t[1] * t[3] - t[2]</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>En algunos lenguajes de programación como Julia, una tupla puede enviarse como _valor_ (copiar) cuando se utiliza en una función; por lo mismo, puede guardarse en el _stack_, que es la memoria _inmediata_ que se tiene en el contexto de ejecución de una función. En esos casos, se puede optimizar el manejo de memoria (alojar y liberar), lo cuál puede ser muy beneficioso para un algoritmo en la práctico. El otro esquema posible es el _heap_, que es una zona de memoria que debe gestionarse (memoria dinámica); es más flexible y _duradera_ entre diferentes llamadas de funciones en un programa. Los patrones esperados son dispersos y puede generar fragmentación.</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>::: </span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>Una _estructura_ es una tupla con campos nombrados; es muy útilizada en lenguajes de programación, por ejemplo, en Julia la siguiente estructura puede representar un punto en un plano:</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: ejemplo-estructura</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: |</span></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a><span class="in">#|   Ejemplo de estructura en Julia</span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a><span class="in">struct Point</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a><span class="in">  x::Float32</span></span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a><span class="in">  y::Float32</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>Note la especificación de los tipos de datos que en conjunto describirán como dicha estructura se maneja por una computadora, y que en términos prácticos, es determinante para el desempeño. Es común asignar valores satelitales en programas o algoritmos, de tal forma que un elemento simple sea manipulado o utilizado de manera explicita en los algoritmos y tener asociados elementos secundarios que se vean afectados por las operaciones. Los conjuntos, tuplas y las estructuras son excelentes formas de representar datos complejos de una manera sencilla.</span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>En Julia, es posible definir funciones o métodos al rededor del tipo de tuplas y estructuras.</span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a>Es importante saber que si algunos de los campos o datos de una tupla o estructura estan en el _heap_ entonces solo una parte estará en el _stack_; i.e., en el caso extremo solo serán referencias a datos en el _heap_. Esto puede llegar a complicar el manejo de memoria, pero también puede ser un comportamiento sobre el que se puede razonar y construir.</span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: funcion-norma</span></span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: |</span></span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true" tabindex="-1"></a><span class="in">#|   Funciones sobre diferentes tipos de datos</span></span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true" tabindex="-1"></a><span class="in">"""</span></span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true" tabindex="-1"></a><span class="in">  Calcula la norma de un vector representado</span></span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true" tabindex="-1"></a><span class="in">  como un tupla</span></span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true" tabindex="-1"></a><span class="in">"""</span></span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true" tabindex="-1"></a><span class="in">function norm(u::Tuple)</span></span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true" tabindex="-1"></a><span class="in">  s = 0f0</span></span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true" tabindex="-1"></a><span class="in">  for i in eachindex(u)</span></span>
<span id="cb13-80"><a href="#cb13-80" aria-hidden="true" tabindex="-1"></a><span class="in">    s = u[i]^2</span></span>
<span id="cb13-81"><a href="#cb13-81" aria-hidden="true" tabindex="-1"></a><span class="in">  end</span></span>
<span id="cb13-82"><a href="#cb13-82" aria-hidden="true" tabindex="-1"></a><span class="in">  sqrt(s)</span></span>
<span id="cb13-83"><a href="#cb13-83" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-84"><a href="#cb13-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-85"><a href="#cb13-85" aria-hidden="true" tabindex="-1"></a><span class="in">"""</span></span>
<span id="cb13-86"><a href="#cb13-86" aria-hidden="true" tabindex="-1"></a><span class="in">  Calcula la norma de un vector de 2 dimensiones</span></span>
<span id="cb13-87"><a href="#cb13-87" aria-hidden="true" tabindex="-1"></a><span class="in">  representado como una estructura</span></span>
<span id="cb13-88"><a href="#cb13-88" aria-hidden="true" tabindex="-1"></a><span class="in">"""</span></span>
<span id="cb13-89"><a href="#cb13-89" aria-hidden="true" tabindex="-1"></a><span class="in">function norm(u::Point)</span></span>
<span id="cb13-90"><a href="#cb13-90" aria-hidden="true" tabindex="-1"></a><span class="in">  sqrt(u.x^2 + u.y^2)</span></span>
<span id="cb13-91"><a href="#cb13-91" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-92"><a href="#cb13-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-93"><a href="#cb13-93" aria-hidden="true" tabindex="-1"></a><span class="in">(norm((1, 1, 1, 1)), norm(Point(1, 1)))</span></span>
<span id="cb13-94"><a href="#cb13-94" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-95"><a href="#cb13-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-96"><a href="#cb13-96" aria-hidden="true" tabindex="-1"></a>Note que la función es diferente para cada tipo de entrada; a este comportamiento se le llamada despacho múltiple y será un concepto común este curso. En otros lenguajes de programación se implementa mediante orientación a objetos.</span>
<span id="cb13-97"><a href="#cb13-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-98"><a href="#cb13-98" aria-hidden="true" tabindex="-1"></a><span class="fu">## Arreglos</span></span>
<span id="cb13-99"><a href="#cb13-99" aria-hidden="true" tabindex="-1"></a>Los _arreglos_ son estructuras de datos que mantienen información de un solo tipo, tienen un costo constante $O(1)$ para acceder a cualquier elemento (también llamado acceso aleatorio) y tipicamente se implementan como memoria contigua en una computadora. Al igual que las tuplas, son colecciones ordenadas, las estaremos accediendo a sus elementos con la misma notación. En este curso usaremos arreglos como colecciones representadas en segmentos contiguos de memoria con dimensiones lógicas fijas. A diferencia de las tuplas, es posible reemplazar valores, entonces $S_{ij} \leftarrow a$, reemplazará el contenido de $S$ en la celda especificada por $a$.</span>
<span id="cb13-100"><a href="#cb13-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-101"><a href="#cb13-101" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb13-102"><a href="#cb13-102" aria-hidden="true" tabindex="-1"></a>Julia tiene un soporte para arreglos excepcional, el cual apenas trataremos ya que se enfoca en diferentes áreas del cómputo numérico, y nuestro curso esta orientado a algoritmos. En Python, estructuras similares se encuentra en el paquete _Numeric Python_ o _numpy_; tenga en cuenta que las afirmaciones sobre el manejo de memoria y representación que estaremos usando se apegan a estos modelos, y no a las _listas_ nativas de Python.</span>
<span id="cb13-103"><a href="#cb13-103" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb13-104"><a href="#cb13-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-105"><a href="#cb13-105" aria-hidden="true" tabindex="-1"></a>A diferencia de las tuplas, pueden tener más que una dimensión. La notación para acceder a los elementos se extiende, e.g. para una matriz $S$ (arreglo bidimensional) $S_{ij}$ se refiere a la celda en la fija $i$ columna $j$, lo mismo que $S<span class="co">[</span><span class="ot">i, j</span><span class="co">]</span>$. </span>
<span id="cb13-106"><a href="#cb13-106" aria-hidden="true" tabindex="-1"></a>Si pensamos en datos numéricos, un arreglo unidimensional es útil para modelar un _vector_ de múltiples dimensiones, un arreglo bidimensional para representar una _mátriz_ de tamaño $m \times n$, y arreglos de dimensión mayor pueden usarse para tensores. Se representan en memoria en segmentos contiguos, y los arreglos de múltiples dimensiones serán representados cuyas partes pueden ser delimitadas mediante aritmética simple, e.g., una matriz de tamaño $m \times n$ necesitará una zona de memoria de $m \times n$ elementos, y se puede acceder a la primera columna mediante en la zona $1,\dots,m$, la segunda columna en $m+1,\dots,2m$, y la $i$ésima en $(i-1)m+1,\dots,im$; esto es, se implementa como el acceso en lotes de tamaño fijo en un gran arreglo unidimensional que es la memoria.</span>
<span id="cb13-107"><a href="#cb13-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-108"><a href="#cb13-108" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb13-109"><a href="#cb13-109" aria-hidden="true" tabindex="-1"></a>Esta es la manera que en general se manejan los datos en una computadora, y conocerlo de manera explícita nos permite tomar decisiones de diseño e implementación.</span>
<span id="cb13-110"><a href="#cb13-110" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb13-111"><a href="#cb13-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-112"><a href="#cb13-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-115"><a href="#cb13-115" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb13-116"><a href="#cb13-116" aria-hidden="true" tabindex="-1"></a><span class="in">//| label: fig-memoria</span></span>
<span id="cb13-117"><a href="#cb13-117" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-width: 100%</span></span>
<span id="cb13-118"><a href="#cb13-118" aria-hidden="true" tabindex="-1"></a><span class="in">//| echo: false</span></span>
<span id="cb13-119"><a href="#cb13-119" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-cap: |</span></span>
<span id="cb13-120"><a href="#cb13-120" aria-hidden="true" tabindex="-1"></a><span class="in">//|   Esquema de una matriz en memoria.</span></span>
<span id="cb13-121"><a href="#cb13-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-122"><a href="#cb13-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-123"><a href="#cb13-123" aria-hidden="true" tabindex="-1"></a><span class="in">digraph lista {</span></span>
<span id="cb13-124"><a href="#cb13-124" aria-hidden="true" tabindex="-1"></a><span class="in">  graph[rankir=LR]</span></span>
<span id="cb13-125"><a href="#cb13-125" aria-hidden="true" tabindex="-1"></a><span class="in">  //graph [pad="0.5", nodesep="0.5", ranksep="0.5"];</span></span>
<span id="cb13-126"><a href="#cb13-126" aria-hidden="true" tabindex="-1"></a><span class="in">  node [shape=record]</span></span>
<span id="cb13-127"><a href="#cb13-127" aria-hidden="true" tabindex="-1"></a><span class="in">  RAM [label="{ memoria RAM | { otros\ndatos |</span></span>
<span id="cb13-128"><a href="#cb13-128" aria-hidden="true" tabindex="-1"></a><span class="in">  {columna 1 - x[:, 1] | {x[1,1] | x[2,1] | x[3,1] | x[4,1]}} |</span></span>
<span id="cb13-129"><a href="#cb13-129" aria-hidden="true" tabindex="-1"></a><span class="in">  {columna 2 - x[:, 2] | {x[1,2] | x[2,2] | x[3,2] | x[4,2]}} |</span></span>
<span id="cb13-130"><a href="#cb13-130" aria-hidden="true" tabindex="-1"></a><span class="in">  {columna 3 - x[:, 3] | {x[1,3] | x[2,3] | x[3,3] | x[4,3]}} |</span></span>
<span id="cb13-131"><a href="#cb13-131" aria-hidden="true" tabindex="-1"></a><span class="in">  {columna 4 - x[:, 4] | {x[1,4] | x[2,4] | x[3,4] | x[4,4]}}</span></span>
<span id="cb13-132"><a href="#cb13-132" aria-hidden="true" tabindex="-1"></a><span class="in">  | otros\ndatos}}"];</span></span>
<span id="cb13-133"><a href="#cb13-133" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-134"><a href="#cb13-134" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb13-135"><a href="#cb13-135" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-136"><a href="#cb13-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-137"><a href="#cb13-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-138"><a href="#cb13-138" aria-hidden="true" tabindex="-1"></a>La representación precisa en memoria es significativa en el desempeño de operaciones matriciales como pueden ser el producto entre matrices o la inversión de las mismas. La manera como se acceden los datos es crucial en el diseño de los algoritmos.</span>
<span id="cb13-139"><a href="#cb13-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-140"><a href="#cb13-140" aria-hidden="true" tabindex="-1"></a>El siguiente ejemplo define un vector $u$ de $m$ elementos y una matriz $X$ de tamaño $m \times n$, ambos en un cubo unitario de 4 dimensiones, y define una función que selecciona el producto punto máximo del vector $u$ a los vectores columna de $X$:</span>
<span id="cb13-143"><a href="#cb13-143" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb13-144"><a href="#cb13-144" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-getmaxdot</span></span>
<span id="cb13-145"><a href="#cb13-145" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: |</span></span>
<span id="cb13-146"><a href="#cb13-146" aria-hidden="true" tabindex="-1"></a><span class="in">#|   Algoritmos para encotrar el vector columna con mayor producto en $X$ punto contra $u$.</span></span>
<span id="cb13-147"><a href="#cb13-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-148"><a href="#cb13-148" aria-hidden="true" tabindex="-1"></a><span class="in">function mydot(u, x)</span></span>
<span id="cb13-149"><a href="#cb13-149" aria-hidden="true" tabindex="-1"></a><span class="in">  s = 0f0</span></span>
<span id="cb13-150"><a href="#cb13-150" aria-hidden="true" tabindex="-1"></a><span class="in">  for i in eachindex(u, x)</span></span>
<span id="cb13-151"><a href="#cb13-151" aria-hidden="true" tabindex="-1"></a><span class="in">    s += u[i] * x[i]</span></span>
<span id="cb13-152"><a href="#cb13-152" aria-hidden="true" tabindex="-1"></a><span class="in">  end</span></span>
<span id="cb13-153"><a href="#cb13-153" aria-hidden="true" tabindex="-1"></a><span class="in">  s</span></span>
<span id="cb13-154"><a href="#cb13-154" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-155"><a href="#cb13-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-156"><a href="#cb13-156" aria-hidden="true" tabindex="-1"></a><span class="in">function getmaxdot(u::Vector, X::Matrix)</span></span>
<span id="cb13-157"><a href="#cb13-157" aria-hidden="true" tabindex="-1"></a><span class="in">  maxpos = 1</span></span>
<span id="cb13-158"><a href="#cb13-158" aria-hidden="true" tabindex="-1"></a><span class="in">  # en la siguiente linea, @view nos permite controlar que</span></span>
<span id="cb13-159"><a href="#cb13-159" aria-hidden="true" tabindex="-1"></a><span class="in">  # no se copien los arreglos, y en su lugar, se usen referencias</span></span>
<span id="cb13-160"><a href="#cb13-160" aria-hidden="true" tabindex="-1"></a><span class="in">  maxdot = mydot(u, @view X[:, 1])</span></span>
<span id="cb13-161"><a href="#cb13-161" aria-hidden="true" tabindex="-1"></a><span class="in">  # obtiene el número de columnas e itera apartir del 2do indice </span></span>
<span id="cb13-162"><a href="#cb13-162" aria-hidden="true" tabindex="-1"></a><span class="in">  mfilas, ncols = size(X)</span></span>
<span id="cb13-163"><a href="#cb13-163" aria-hidden="true" tabindex="-1"></a><span class="in">  for i in 2:ncols</span></span>
<span id="cb13-164"><a href="#cb13-164" aria-hidden="true" tabindex="-1"></a><span class="in">    d = mydot(u, @view X[:, i]) </span></span>
<span id="cb13-165"><a href="#cb13-165" aria-hidden="true" tabindex="-1"></a><span class="in">    if d &gt; maxdot</span></span>
<span id="cb13-166"><a href="#cb13-166" aria-hidden="true" tabindex="-1"></a><span class="in">      maxpos = i</span></span>
<span id="cb13-167"><a href="#cb13-167" aria-hidden="true" tabindex="-1"></a><span class="in">      maxdot = d</span></span>
<span id="cb13-168"><a href="#cb13-168" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb13-169"><a href="#cb13-169" aria-hidden="true" tabindex="-1"></a><span class="in">  end</span></span>
<span id="cb13-170"><a href="#cb13-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-171"><a href="#cb13-171" aria-hidden="true" tabindex="-1"></a><span class="in">  (maxpos, maxdot)</span></span>
<span id="cb13-172"><a href="#cb13-172" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-173"><a href="#cb13-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-174"><a href="#cb13-174" aria-hidden="true" tabindex="-1"></a><span class="in">getmaxdot(rand(Float32, 4), rand(Float32, 4, 1000))</span></span>
<span id="cb13-175"><a href="#cb13-175" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-176"><a href="#cb13-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-177"><a href="#cb13-177" aria-hidden="true" tabindex="-1"></a>En este código puede verse como se separa el cálculo del producto punto en una función, </span>
<span id="cb13-178"><a href="#cb13-178" aria-hidden="true" tabindex="-1"></a>esto es porque en sí mismo es una operación importante; también podemos aislar de esta forma la manera que se accede (el orden) a los vectores. La idea fue acceder columna a columna, lo cuál asegura el uso apropiado de los accesos a memoria. En la función $getmaxdot$ se resuelve el problema de encontrar el máximo de un arreglo, y se puede observar que sin conocimiento adicional, este requiere $O(n)$ comparaciones, para una mátriz de $n$ columnas. Esto implica que cada producto punto se cuenta como $O(1)$, lo cual simplifica el razonamiento. Por la función $mydot$ podemos observar que el producto punto tiene un costo de $O(m)$, por lo que la $getmaxdot$ tiene un costo de $O(mn)$ operaciones lógicas y aritméticas.</span>
<span id="cb13-179"><a href="#cb13-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-180"><a href="#cb13-180" aria-hidden="true" tabindex="-1"></a>El producto entre matrices es un caso paradigmático por su uso en la resolución de problemas prácticos, donde hay una gran cantidad de trabajo al rededor de los costos necesarios para llevarlo a cabo. En particular, el algoritmo naïve, es un algoritmo con costo cúbico, como se puede ver a continuación:</span>
<span id="cb13-181"><a href="#cb13-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-184"><a href="#cb13-184" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb13-185"><a href="#cb13-185" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: funcion-producto-matricial</span></span>
<span id="cb13-186"><a href="#cb13-186" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: |</span></span>
<span id="cb13-187"><a href="#cb13-187" aria-hidden="true" tabindex="-1"></a><span class="in">#|   Funciones sobre diferentes tipos de datos</span></span>
<span id="cb13-188"><a href="#cb13-188" aria-hidden="true" tabindex="-1"></a><span class="in">function myprod(A::Matrix, B::Matrix)</span></span>
<span id="cb13-189"><a href="#cb13-189" aria-hidden="true" tabindex="-1"></a><span class="in">  mA, nA = size(A)</span></span>
<span id="cb13-190"><a href="#cb13-190" aria-hidden="true" tabindex="-1"></a><span class="in">  mB, nB = size(B)</span></span>
<span id="cb13-191"><a href="#cb13-191" aria-hidden="true" tabindex="-1"></a><span class="in">  @assert nA == mB</span></span>
<span id="cb13-192"><a href="#cb13-192" aria-hidden="true" tabindex="-1"></a><span class="in">  C = Matrix{Float32}(undef, mA, nB)</span></span>
<span id="cb13-193"><a href="#cb13-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-194"><a href="#cb13-194" aria-hidden="true" tabindex="-1"></a><span class="in">  for i in 1:mA</span></span>
<span id="cb13-195"><a href="#cb13-195" aria-hidden="true" tabindex="-1"></a><span class="in">    for j in 1:mB</span></span>
<span id="cb13-196"><a href="#cb13-196" aria-hidden="true" tabindex="-1"></a><span class="in">      rowA = @view A[i, :]</span></span>
<span id="cb13-197"><a href="#cb13-197" aria-hidden="true" tabindex="-1"></a><span class="in">      colB = @view B[:, i]</span></span>
<span id="cb13-198"><a href="#cb13-198" aria-hidden="true" tabindex="-1"></a><span class="in">      C[i, j] = mydot(rowA, colB)</span></span>
<span id="cb13-199"><a href="#cb13-199" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb13-200"><a href="#cb13-200" aria-hidden="true" tabindex="-1"></a><span class="in">  end</span></span>
<span id="cb13-201"><a href="#cb13-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-202"><a href="#cb13-202" aria-hidden="true" tabindex="-1"></a><span class="in">  C</span></span>
<span id="cb13-203"><a href="#cb13-203" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-204"><a href="#cb13-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-205"><a href="#cb13-205" aria-hidden="true" tabindex="-1"></a><span class="in">A = rand(Float32, 5, 3)</span></span>
<span id="cb13-206"><a href="#cb13-206" aria-hidden="true" tabindex="-1"></a><span class="in">B = rand(Float32, 3, 5)</span></span>
<span id="cb13-207"><a href="#cb13-207" aria-hidden="true" tabindex="-1"></a><span class="in">C = myprod(A, B)</span></span>
<span id="cb13-208"><a href="#cb13-208" aria-hidden="true" tabindex="-1"></a><span class="in">display(C)</span></span>
<span id="cb13-209"><a href="#cb13-209" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-210"><a href="#cb13-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-211"><a href="#cb13-211" aria-hidden="true" tabindex="-1"></a>Se pueden ver dos ciclos iterando a lo largo de filas y columnas, adicionalmente un producto punto, el cual tiene un costo lineal en la dimensión del vector, por lo que el costo es cúbico. Esta implementación es directa con la definición misma del producto matricial. Existen diferentes algoritmos para hacer esta operación más eficiente para diferentes casos o características de las matrices, siendo un área de investigación activa.</span>
<span id="cb13-212"><a href="#cb13-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-213"><a href="#cb13-213" aria-hidden="true" tabindex="-1"></a><span class="fu">## Listas</span></span>
<span id="cb13-214"><a href="#cb13-214" aria-hidden="true" tabindex="-1"></a>Las _listas_ son estructuras de datos ordenadas lineales, esto es, no se asume que los elementos se guardan de manera contigua y los accesos al $i$-ésimo elemento cuestan $O(i)$. Se soportan inserciones y borrados. Por ejemplo, sea $L = [a, b, c, d]$ una lista con cuatro elementos, $L_2 = b$, $insert!(L, 2, z)$ convertirá $L = [a, z, b, c, d]$ (note que $b$ se desplazó y no se reemplazó como se esperaría en un arreglo). La operación $deleteat!(L, 2)$ regresará la lista a su valor previo a la inserción. Estas operaciones que modifican la lista también tienen diferentes costos dependiendo de la posición, e.g., donde el inicio y final de la secuencia (también llamados _head/cabeza_ y _tail/cola_) suelen ser más eficientes que accesos aleatorios, ya que se tienen referencias a estas posiciones en memoria. Es de especial importancia la navegación por la lista mediante operaciones de sucesor $succ$ y predecedor $pred$, que pueden encadenarse para obtener acceso a los elementos. A diferencia de un arreglo, las listas no requieren una notación simple para acceso aleatorio a los elementos; los accesos típicos son a los extremos de la lista (cabeza y cola), sucesor y predecesor.</span>
<span id="cb13-215"><a href="#cb13-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-218"><a href="#cb13-218" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb13-219"><a href="#cb13-219" aria-hidden="true" tabindex="-1"></a><span class="in">//| label: fig-lista</span></span>
<span id="cb13-220"><a href="#cb13-220" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-width: 80%</span></span>
<span id="cb13-221"><a href="#cb13-221" aria-hidden="true" tabindex="-1"></a><span class="in">//| echo: false</span></span>
<span id="cb13-222"><a href="#cb13-222" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-cap: |</span></span>
<span id="cb13-223"><a href="#cb13-223" aria-hidden="true" tabindex="-1"></a><span class="in">//|   Una lista ligada simple</span></span>
<span id="cb13-224"><a href="#cb13-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-225"><a href="#cb13-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-226"><a href="#cb13-226" aria-hidden="true" tabindex="-1"></a><span class="in">digraph lista {</span></span>
<span id="cb13-227"><a href="#cb13-227" aria-hidden="true" tabindex="-1"></a><span class="in">  rankdir=LR;</span></span>
<span id="cb13-228"><a href="#cb13-228" aria-hidden="true" tabindex="-1"></a><span class="in">  graph [pad="0.5", nodesep="0.5", ranksep="0.5"];</span></span>
<span id="cb13-229"><a href="#cb13-229" aria-hidden="true" tabindex="-1"></a><span class="in">  node [shape=record];</span></span>
<span id="cb13-230"><a href="#cb13-230" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-231"><a href="#cb13-231" aria-hidden="true" tabindex="-1"></a><span class="in">  //{rank=same; a; b; c; nothing;}</span></span>
<span id="cb13-232"><a href="#cb13-232" aria-hidden="true" tabindex="-1"></a><span class="in">  splines="true";</span></span>
<span id="cb13-233"><a href="#cb13-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-234"><a href="#cb13-234" aria-hidden="true" tabindex="-1"></a><span class="in">  list [label="{&lt;head&gt; head} | {&lt;tail&gt; tail}"];</span></span>
<span id="cb13-235"><a href="#cb13-235" aria-hidden="true" tabindex="-1"></a><span class="in">  a [label="{&lt;dat&gt; a | &lt;succ&gt; }"];</span></span>
<span id="cb13-236"><a href="#cb13-236" aria-hidden="true" tabindex="-1"></a><span class="in">  b [label="{&lt;dat&gt; b | &lt;succ&gt; }"];</span></span>
<span id="cb13-237"><a href="#cb13-237" aria-hidden="true" tabindex="-1"></a><span class="in">  c [label="{&lt;dat&gt; c | &lt;succ&gt; }"];</span></span>
<span id="cb13-238"><a href="#cb13-238" aria-hidden="true" tabindex="-1"></a><span class="in">  nothing [shape=ellipse, label="nothing", style=dashed];</span></span>
<span id="cb13-239"><a href="#cb13-239" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-240"><a href="#cb13-240" aria-hidden="true" tabindex="-1"></a><span class="in">  edge [style=dashed, arrowsize=1, tailclip=false]</span></span>
<span id="cb13-241"><a href="#cb13-241" aria-hidden="true" tabindex="-1"></a><span class="in">  list:head:n -&gt; a:dat:n [weight=0];</span></span>
<span id="cb13-242"><a href="#cb13-242" aria-hidden="true" tabindex="-1"></a><span class="in">  list:tail:s -&gt; c:dat:s [weight=0];</span></span>
<span id="cb13-243"><a href="#cb13-243" aria-hidden="true" tabindex="-1"></a><span class="in">   </span></span>
<span id="cb13-244"><a href="#cb13-244" aria-hidden="true" tabindex="-1"></a><span class="in">  edge [style=""]</span></span>
<span id="cb13-245"><a href="#cb13-245" aria-hidden="true" tabindex="-1"></a><span class="in">  a:succ:c -&gt; b:dat:w [weight=3];</span></span>
<span id="cb13-246"><a href="#cb13-246" aria-hidden="true" tabindex="-1"></a><span class="in">  b:succ:c -&gt; c:dat:w [weight=5];</span></span>
<span id="cb13-247"><a href="#cb13-247" aria-hidden="true" tabindex="-1"></a><span class="in">  c:succ:c -&gt; nothing [weight=10];</span></span>
<span id="cb13-248"><a href="#cb13-248" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-249"><a href="#cb13-249" aria-hidden="true" tabindex="-1"></a><span class="in">  //{rank=same; a; b; c; nothing;}</span></span>
<span id="cb13-250"><a href="#cb13-250" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb13-251"><a href="#cb13-251" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-252"><a href="#cb13-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-253"><a href="#cb13-253" aria-hidden="true" tabindex="-1"></a>La @fig-lista muestra una lista ligada, que es una implementación de lista que puede crecer fácilmente, funciona en el _heap_ de memoria por lo que cada bloque requiere memoria dinámica. Cada bloque es una estructura; se pueden distinguir dos tipos, la lista que contiene referencias al primer nodo y al último nodo. Los _nodos de de datos_ contienen los elementos de la colección y referencias al siguiente nodo, también llamado _sucesor_. El nodo _nothing_ es especial y significa que no hay más elementos.</span>
<span id="cb13-254"><a href="#cb13-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-255"><a href="#cb13-255" aria-hidden="true" tabindex="-1"></a>El siguiente código muestra como la definición de lista ligada.</span>
<span id="cb13-258"><a href="#cb13-258" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb13-259"><a href="#cb13-259" aria-hidden="true" tabindex="-1"></a><span class="in">#| lst-label: lst-lista-ligada</span></span>
<span id="cb13-260"><a href="#cb13-260" aria-hidden="true" tabindex="-1"></a><span class="in">#| lst-cap: Código para una lista ligada simple</span></span>
<span id="cb13-261"><a href="#cb13-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-262"><a href="#cb13-262" aria-hidden="true" tabindex="-1"></a><span class="in">struct Node</span></span>
<span id="cb13-263"><a href="#cb13-263" aria-hidden="true" tabindex="-1"></a><span class="in">  data::Int</span></span>
<span id="cb13-264"><a href="#cb13-264" aria-hidden="true" tabindex="-1"></a><span class="in">  next::Union{Node,Nothing}</span></span>
<span id="cb13-265"><a href="#cb13-265" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-266"><a href="#cb13-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-267"><a href="#cb13-267" aria-hidden="true" tabindex="-1"></a><span class="in">node = Node(10, Node(20, Node(30, nothing)))</span></span>
<span id="cb13-268"><a href="#cb13-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-269"><a href="#cb13-269" aria-hidden="true" tabindex="-1"></a><span class="in">println(node)</span></span>
<span id="cb13-270"><a href="#cb13-270" aria-hidden="true" tabindex="-1"></a><span class="in">(node.data, node.next.data, node.next.next.data)</span></span>
<span id="cb13-271"><a href="#cb13-271" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-272"><a href="#cb13-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-273"><a href="#cb13-273" aria-hidden="true" tabindex="-1"></a>En el @lst-lista-ligada se ignora la referencia a _tail_ (_head_ se guarda en _node_), por lo que las operaciones sobre _tail_ requieren recorrer la lista completa, costando $O(n)$ en el peor caso para una lista de $n$ elementos.</span>
<span id="cb13-274"><a href="#cb13-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-275"><a href="#cb13-275" aria-hidden="true" tabindex="-1"></a>Por su manera en la cual son accedidos los datos, se tienen dos tipos de listas muy útiles: las _colas_ y las _pilas_. Las _colas_ son listas que se acceden solo por sus extremos, y emulan la política de _el primero en entrar es el primero en salir_ (first in - first out, FIFO), y es por eso que se les llama colas haciendo referencia a una cola para realizar un trámite o recibir un servicio. Las _pilas_ o _stack_ son listas con la política _el último en entrar es el primero en salir_ (last in - first out, LIFO). Mientras que cualquier lista puede ser útil para implementarlas, algunas maneras serán mejores que otras dependiendo de los requerimientos de los problemas siendo resueltos; sin embargo, es importante recordar sus políticas de acceso para comprender los algoritmos que las utilicen.</span>
<span id="cb13-276"><a href="#cb13-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-277"><a href="#cb13-277" aria-hidden="true" tabindex="-1"></a>Entre las operaciones comunes tenemos las siguientes:</span>
<span id="cb13-278"><a href="#cb13-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-279"><a href="#cb13-279" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>_push!(L, a)_: insertar $a$ al final de la lista $L$.</span>
<span id="cb13-280"><a href="#cb13-280" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>_pop!(L)_: remueve el último elemento en $L$.</span>
<span id="cb13-281"><a href="#cb13-281" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>_deleteat!(L, pos)_: remueve el elemento en la posición $pos$, se desplazan los elementos.</span>
<span id="cb13-282"><a href="#cb13-282" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>_insert!(L, pos, valor)_: inserta $valor$ en la posición $pos$ desplazando los elementos anteriores.</span>
<span id="cb13-283"><a href="#cb13-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-284"><a href="#cb13-284" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Ejercicios</span></span>
<span id="cb13-285"><a href="#cb13-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-286"><a href="#cb13-286" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Implemente _insert!_ y _deleteat!_</span>
<span id="cb13-287"><a href="#cb13-287" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>¿Cuál sería la implementación de _succ_ y _pred_ en una lista ligada?</span>
<span id="cb13-288"><a href="#cb13-288" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>¿Cuales serían sus costos?</span>
<span id="cb13-289"><a href="#cb13-289" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Añadiendo más memoria, como podemos mejorar _pred_?</span>
<span id="cb13-290"><a href="#cb13-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-291"><a href="#cb13-291" aria-hidden="true" tabindex="-1"></a><span class="fu">## Grafos</span></span>
<span id="cb13-292"><a href="#cb13-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-293"><a href="#cb13-293" aria-hidden="true" tabindex="-1"></a>Otras estructuras de datos elementales son los _grafos_. Un grafo $G = (V, E)$ es una tupla compuesta por un conjunto de vertices $V$ y el conjunto de aristas $E$. Por ejemplo, el grafo con $A = (<span class="sc">\{</span>a, b, c, d<span class="sc">\}</span>, <span class="sc">\{</span>(a, b), (b, c), (c, d), (d, a)<span class="sc">\}</span>)$</span>
<span id="cb13-294"><a href="#cb13-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-297"><a href="#cb13-297" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb13-298"><a href="#cb13-298" aria-hidden="true" tabindex="-1"></a><span class="in">//| label: fig-grafo</span></span>
<span id="cb13-299"><a href="#cb13-299" aria-hidden="true" tabindex="-1"></a><span class="in">//| echo: false</span></span>
<span id="cb13-300"><a href="#cb13-300" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-width: 80%</span></span>
<span id="cb13-301"><a href="#cb13-301" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-cap: |</span></span>
<span id="cb13-302"><a href="#cb13-302" aria-hidden="true" tabindex="-1"></a><span class="in">//|   Un grafo dirigido simple</span></span>
<span id="cb13-303"><a href="#cb13-303" aria-hidden="true" tabindex="-1"></a><span class="in">digraph lista {</span></span>
<span id="cb13-304"><a href="#cb13-304" aria-hidden="true" tabindex="-1"></a><span class="in">  rankdir=LR;</span></span>
<span id="cb13-305"><a href="#cb13-305" aria-hidden="true" tabindex="-1"></a><span class="in">  graph [pad="0.5", nodesep="0.5", ranksep="0.5"];</span></span>
<span id="cb13-306"><a href="#cb13-306" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-307"><a href="#cb13-307" aria-hidden="true" tabindex="-1"></a><span class="in">  //{rank=same; a; b; c; nothing;}</span></span>
<span id="cb13-308"><a href="#cb13-308" aria-hidden="true" tabindex="-1"></a><span class="in">  splines="true";</span></span>
<span id="cb13-309"><a href="#cb13-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-310"><a href="#cb13-310" aria-hidden="true" tabindex="-1"></a><span class="in">  a -&gt; b -&gt; c -&gt; d -&gt; a;  </span></span>
<span id="cb13-311"><a href="#cb13-311" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb13-312"><a href="#cb13-312" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-313"><a href="#cb13-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-314"><a href="#cb13-314" aria-hidden="true" tabindex="-1"></a>Los grafos son herramientas poderosas para representar de manera abstracta problemas que implican relaciones entre elementos.</span>
<span id="cb13-315"><a href="#cb13-315" aria-hidden="true" tabindex="-1"></a>En algunos casos es útil asociar funciones a los vértices y las aristas. Tenga en cuenta los siguientes ejemplos:</span>
<span id="cb13-316"><a href="#cb13-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-317"><a href="#cb13-317" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$peso: V \rightarrow \mathbb{R}$, la cual podría usarse como $peso(a) = 1.5$.</span>
<span id="cb13-318"><a href="#cb13-318" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$costo: V \times V \rightarrow \mathbb{R}$, la cual podría usarse como $costo(a, b) = 2.0$. </span>
<span id="cb13-319"><a href="#cb13-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-320"><a href="#cb13-320" aria-hidden="true" tabindex="-1"></a>La estructura del grafo puede accederse mediante las funciones:</span>
<span id="cb13-321"><a href="#cb13-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-322"><a href="#cb13-322" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$in(G, v) = <span class="sc">\{</span> u \mid (u, v) \in E<span class="sc">\}</span>$</span>
<span id="cb13-323"><a href="#cb13-323" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$out(G, u) = <span class="sc">\{</span> v \mid (u, v) \in E<span class="sc">\}</span>$</span>
<span id="cb13-324"><a href="#cb13-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-325"><a href="#cb13-325" aria-hidden="true" tabindex="-1"></a>así como el número de vertices que entran y salen como:</span>
<span id="cb13-326"><a href="#cb13-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-327"><a href="#cb13-327" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$indegree(G, v) = |in(G, v)|$.</span>
<span id="cb13-328"><a href="#cb13-328" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$outdegree(G, u) = |out(G, u)|$.</span>
<span id="cb13-329"><a href="#cb13-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-330"><a href="#cb13-330" aria-hidden="true" tabindex="-1"></a>Un grafo puede tener aristas no dirigidas, el grafo con $B=(<span class="sc">\{</span>a, b, c, d<span class="sc">\}</span>, <span class="sc">\{\{</span>a, b<span class="sc">\}</span>, <span class="sc">\{</span>b, c<span class="sc">\}</span>, <span class="sc">\{</span>c, d<span class="sc">\}</span>, <span class="sc">\{</span>d, a<span class="sc">\}\}</span>)$, no reconocerá orden en las aristas.</span>
<span id="cb13-331"><a href="#cb13-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-334"><a href="#cb13-334" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb13-335"><a href="#cb13-335" aria-hidden="true" tabindex="-1"></a><span class="in">//| label: fig-grafo-nodirigido</span></span>
<span id="cb13-336"><a href="#cb13-336" aria-hidden="true" tabindex="-1"></a><span class="in">//| echo: false</span></span>
<span id="cb13-337"><a href="#cb13-337" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-width: 60%</span></span>
<span id="cb13-338"><a href="#cb13-338" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-cap: |</span></span>
<span id="cb13-339"><a href="#cb13-339" aria-hidden="true" tabindex="-1"></a><span class="in">//|   Un grafo cuyas aristas no estan dirigidas</span></span>
<span id="cb13-340"><a href="#cb13-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-341"><a href="#cb13-341" aria-hidden="true" tabindex="-1"></a><span class="in">graph lista {</span></span>
<span id="cb13-342"><a href="#cb13-342" aria-hidden="true" tabindex="-1"></a><span class="in">  rankdir=LR;</span></span>
<span id="cb13-343"><a href="#cb13-343" aria-hidden="true" tabindex="-1"></a><span class="in">  graph [pad="0.5", nodesep="0.5", ranksep="0.5"];  </span></span>
<span id="cb13-344"><a href="#cb13-344" aria-hidden="true" tabindex="-1"></a><span class="in">  splines="true";</span></span>
<span id="cb13-345"><a href="#cb13-345" aria-hidden="true" tabindex="-1"></a><span class="in">  a -- b -- c -- d -- a;  </span></span>
<span id="cb13-346"><a href="#cb13-346" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb13-347"><a href="#cb13-347" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-348"><a href="#cb13-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-349"><a href="#cb13-349" aria-hidden="true" tabindex="-1"></a>Por lo tanto, podremos decir que $(a, b) \in E_A$ pero $(b, a) \not\in E_A$. Por otro lado tenemos que $<span class="sc">\{</span>a, b<span class="sc">\}</span> \in E_B$, y forzando un poco la notación, $(a, b) \in E_B$, $(b, a) \in E_B$; para los conjuntos de aristas de $A$ y $B$. La estructura puede ser accedida mediante $neighbors(G, u) = <span class="sc">\{</span> v \mid <span class="sc">\{</span>u, v<span class="sc">\}</span> \in E <span class="sc">\}</span>$.</span>
<span id="cb13-350"><a href="#cb13-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-351"><a href="#cb13-351" aria-hidden="true" tabindex="-1"></a>Un grafo puede estar representado de diferentes maneras, por ejemplo, un arreglo bidimensional (matriz), donde $S_{ij} = 1$ si hay una arista entre los vértices $i$ y $j$; y $S_{ij} = 0$ si no existe una arista. A esta representación se le llama matriz de adjacencia.</span>
<span id="cb13-352"><a href="#cb13-352" aria-hidden="true" tabindex="-1"></a>Si el grafo tiene pocos $1$'s vale la pena tener una representación diferente; este es el caso de las listas de adjacencia, donde se representa cada fila o cada columna de la matriz de adjacencia como una lista de los elementos diferentes de cero. </span>
<span id="cb13-353"><a href="#cb13-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-354"><a href="#cb13-354" aria-hidden="true" tabindex="-1"></a>Existen otras representaciones como la lista de coordenadas, _coordinate lists_ (COO), o las representaciones dispersas compimidas, _sparse row_ (CSR) y _compressed sparse column_ (CSC) <span class="co">[</span><span class="ot">@Scott2023</span><span class="co">]</span>. Todas estas representaciones tratan de disminuir el uso de memoria y aprovechar la gran dispersión para realizar operaciones solo cuando sea estrictamente necesario.</span>
<span id="cb13-355"><a href="#cb13-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-356"><a href="#cb13-356" aria-hidden="true" tabindex="-1"></a>Un _árbol_ es un grafo en el cual no existen ciclos, esto es, no existe forma que en una caminata sobre los vértices, a traves de las aristas y prohibiendo _regresarse_ aristas, es imposible regresar a un vértice antes visto.</span>
<span id="cb13-357"><a href="#cb13-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-360"><a href="#cb13-360" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb13-361"><a href="#cb13-361" aria-hidden="true" tabindex="-1"></a><span class="in">//| label: fig-arbol</span></span>
<span id="cb13-362"><a href="#cb13-362" aria-hidden="true" tabindex="-1"></a><span class="in">//| echo: false</span></span>
<span id="cb13-363"><a href="#cb13-363" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-width: 60%</span></span>
<span id="cb13-364"><a href="#cb13-364" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-cap: |</span></span>
<span id="cb13-365"><a href="#cb13-365" aria-hidden="true" tabindex="-1"></a><span class="in">//|   Árbol con aristas no dirigidas</span></span>
<span id="cb13-366"><a href="#cb13-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-367"><a href="#cb13-367" aria-hidden="true" tabindex="-1"></a><span class="in">graph lista {</span></span>
<span id="cb13-368"><a href="#cb13-368" aria-hidden="true" tabindex="-1"></a><span class="in">  rankdir=LR;</span></span>
<span id="cb13-369"><a href="#cb13-369" aria-hidden="true" tabindex="-1"></a><span class="in">  graph [pad="0.5", nodesep="0.5", ranksep="0.5"];  </span></span>
<span id="cb13-370"><a href="#cb13-370" aria-hidden="true" tabindex="-1"></a><span class="in">  splines="true";</span></span>
<span id="cb13-371"><a href="#cb13-371" aria-hidden="true" tabindex="-1"></a><span class="in">  a -- b -- c;</span></span>
<span id="cb13-372"><a href="#cb13-372" aria-hidden="true" tabindex="-1"></a><span class="in">  a -- d -- {e; f}; </span></span>
<span id="cb13-373"><a href="#cb13-373" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb13-374"><a href="#cb13-374" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-375"><a href="#cb13-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-376"><a href="#cb13-376" aria-hidden="true" tabindex="-1"></a>En algunos casos, es conveniente identificar vértices especiales en un árbol $T=(V, E)$. Un vértice es la _raíz_ del árbol, $root(T)$, es especial ya que seguramente se utilizará como acceso al árbol y por tanto  contiene un camino a cada uno vértices en $V$. Cada vértice puede tener, o no, _hijos_ $children(T, u) = \{ v \mid (u, v) \in E \}$. Se dice que $u$ es un _hoja_ (leaf) si $children(T, u) = \emptyset$, e _interno_ (inner) si no es ni raíz ni hoja.</span>
<span id="cb13-377"><a href="#cb13-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-380"><a href="#cb13-380" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb13-381"><a href="#cb13-381" aria-hidden="true" tabindex="-1"></a><span class="in">//| label: fig-arbol-dirigido</span></span>
<span id="cb13-382"><a href="#cb13-382" aria-hidden="true" tabindex="-1"></a><span class="in">//| echo: false</span></span>
<span id="cb13-383"><a href="#cb13-383" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-width: 60%</span></span>
<span id="cb13-384"><a href="#cb13-384" aria-hidden="true" tabindex="-1"></a><span class="in">//| fig-cap: |</span></span>
<span id="cb13-385"><a href="#cb13-385" aria-hidden="true" tabindex="-1"></a><span class="in">//|   Árbol con aristas dirigidas, note que es fácil saber si hay un vértice o nodo que se distinga como raíz, o nodos que sean hojas.</span></span>
<span id="cb13-386"><a href="#cb13-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-387"><a href="#cb13-387" aria-hidden="true" tabindex="-1"></a><span class="in">digraph lista {</span></span>
<span id="cb13-388"><a href="#cb13-388" aria-hidden="true" tabindex="-1"></a><span class="in">  rankdir=LR;</span></span>
<span id="cb13-389"><a href="#cb13-389" aria-hidden="true" tabindex="-1"></a><span class="in">  graph [pad="0.5", nodesep="0.5", ranksep="0.5"];  </span></span>
<span id="cb13-390"><a href="#cb13-390" aria-hidden="true" tabindex="-1"></a><span class="in">  splines="true";</span></span>
<span id="cb13-391"><a href="#cb13-391" aria-hidden="true" tabindex="-1"></a><span class="in">  a -&gt; b -&gt; c;</span></span>
<span id="cb13-392"><a href="#cb13-392" aria-hidden="true" tabindex="-1"></a><span class="in">  a -&gt; d -&gt; {e; f}; </span></span>
<span id="cb13-393"><a href="#cb13-393" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb13-394"><a href="#cb13-394" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-395"><a href="#cb13-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-396"><a href="#cb13-396" aria-hidden="true" tabindex="-1"></a>Al igual que en los grafos más generales, en los árboles es útil definir funciones sobre vértices y aristas, así como marcar tipos de vértices, e.g., posición u color, que simplifiquen el razonamiento para con los algoritmos asociados.</span>
<span id="cb13-397"><a href="#cb13-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-398"><a href="#cb13-398" aria-hidden="true" tabindex="-1"></a>Los nodos y las aristas de un grafo pueden _recorrerse_ de diferentes maneras, donde se aprovechan las relaciones representadas. En un grafo general podría ser importante solo visitar una vez cada vértice, o guiarse en el recorrido por alguna heurística o función asociada a vértices o aristas. </span>
<span id="cb13-399"><a href="#cb13-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-400"><a href="#cb13-400" aria-hidden="true" tabindex="-1"></a>El recorrido _primero a lo profundo_, Depth First Search (DFS), comienza en un nodo dado y de manera _voraz_ avanzará recordando orden de visita y avanzando al ver un nuevo nodo repitiendo el procedimiento hasta que todos los vértices alcanzables sean visitados. El siguiente pseudo-código lo implementa:</span>
<span id="cb13-401"><a href="#cb13-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-402"><a href="#cb13-402" aria-hidden="true" tabindex="-1"></a><span class="in">```julia</span></span>
<span id="cb13-403"><a href="#cb13-403" aria-hidden="true" tabindex="-1"></a><span class="in">#| lst-label: lst-dfs</span></span>
<span id="cb13-404"><a href="#cb13-404" aria-hidden="true" tabindex="-1"></a><span class="in">#| lst-cap: Psudo-código DFS</span></span>
<span id="cb13-405"><a href="#cb13-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-406"><a href="#cb13-406" aria-hidden="true" tabindex="-1"></a><span class="in">function operación!(vértice)</span></span>
<span id="cb13-407"><a href="#cb13-407" aria-hidden="true" tabindex="-1"></a><span class="in">  #... operaciones sobre el vértice siendo visitado ...</span></span>
<span id="cb13-408"><a href="#cb13-408" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-409"><a href="#cb13-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-410"><a href="#cb13-410" aria-hidden="true" tabindex="-1"></a><span class="in">function DFS(grafo, vértice, visitados)</span></span>
<span id="cb13-411"><a href="#cb13-411" aria-hidden="true" tabindex="-1"></a><span class="in">  operación!(vértice)</span></span>
<span id="cb13-412"><a href="#cb13-412" aria-hidden="true" tabindex="-1"></a><span class="in">  push!(visitados, vértice)</span></span>
<span id="cb13-413"><a href="#cb13-413" aria-hidden="true" tabindex="-1"></a><span class="in">  for v in neighbors(grafo, vértice)</span></span>
<span id="cb13-414"><a href="#cb13-414" aria-hidden="true" tabindex="-1"></a><span class="in">    if v ∉ visitados</span></span>
<span id="cb13-415"><a href="#cb13-415" aria-hidden="true" tabindex="-1"></a><span class="in">      operación!(v)</span></span>
<span id="cb13-416"><a href="#cb13-416" aria-hidden="true" tabindex="-1"></a><span class="in">      push!(visitados, v)</span></span>
<span id="cb13-417"><a href="#cb13-417" aria-hidden="true" tabindex="-1"></a><span class="in">      DFS(grafo, v, visitados)</span></span>
<span id="cb13-418"><a href="#cb13-418" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb13-419"><a href="#cb13-419" aria-hidden="true" tabindex="-1"></a><span class="in">  end</span></span>
<span id="cb13-420"><a href="#cb13-420" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-421"><a href="#cb13-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-422"><a href="#cb13-422" aria-hidden="true" tabindex="-1"></a><span class="in"># ... código de preparación del grafo</span></span>
<span id="cb13-423"><a href="#cb13-423" aria-hidden="true" tabindex="-1"></a><span class="in">visitados = Set()</span></span>
<span id="cb13-424"><a href="#cb13-424" aria-hidden="true" tabindex="-1"></a><span class="in">DFS((vértices, aristas), vérticeinicial, visitados)</span></span>
<span id="cb13-425"><a href="#cb13-425" aria-hidden="true" tabindex="-1"></a><span class="in"># ... código posterior a la visita DFS</span></span>
<span id="cb13-426"><a href="#cb13-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-427"><a href="#cb13-427" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-428"><a href="#cb13-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-429"><a href="#cb13-429" aria-hidden="true" tabindex="-1"></a>Las llamadas recursivas a DFS tienen el efecto de _memorizar_ el orden de visita anterior y _recordarlo_ cuando se sale de una visita anidada. Entonces, hay una memoria implicita utilizada, implementanda por el _stack_ de llamadas. La función _operación!_ es una abstracción de cualquier cosa que deba hacerse sobre los nodos siendo visitados.</span>
<span id="cb13-430"><a href="#cb13-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-431"><a href="#cb13-431" aria-hidden="true" tabindex="-1"></a>El _recorrido a lo ancho_, Breadth First Search (BSF), visita los vértices locales primero que los alejados contrarío al avance voraz utilizado por DFS.</span>
<span id="cb13-432"><a href="#cb13-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-433"><a href="#cb13-433" aria-hidden="true" tabindex="-1"></a><span class="in">```julia</span></span>
<span id="cb13-434"><a href="#cb13-434" aria-hidden="true" tabindex="-1"></a><span class="in">#| lst-label: lst-bfs</span></span>
<span id="cb13-435"><a href="#cb13-435" aria-hidden="true" tabindex="-1"></a><span class="in">#| lst-cap: Psudo-código BFS</span></span>
<span id="cb13-436"><a href="#cb13-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-437"><a href="#cb13-437" aria-hidden="true" tabindex="-1"></a><span class="in">function BFS(grafo, vértice, visitados, cola)</span></span>
<span id="cb13-438"><a href="#cb13-438" aria-hidden="true" tabindex="-1"></a><span class="in">  operación!(vértice)</span></span>
<span id="cb13-439"><a href="#cb13-439" aria-hidden="true" tabindex="-1"></a><span class="in">  push!(visitados, vértice)</span></span>
<span id="cb13-440"><a href="#cb13-440" aria-hidden="true" tabindex="-1"></a><span class="in">  push!(cola, vértice)</span></span>
<span id="cb13-441"><a href="#cb13-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-442"><a href="#cb13-442" aria-hidden="true" tabindex="-1"></a><span class="in">  while length(cola) &gt; 0</span></span>
<span id="cb13-443"><a href="#cb13-443" aria-hidden="true" tabindex="-1"></a><span class="in">    u = popfirst!(cola)</span></span>
<span id="cb13-444"><a href="#cb13-444" aria-hidden="true" tabindex="-1"></a><span class="in">    for v in neighbors(grafo, u)</span></span>
<span id="cb13-445"><a href="#cb13-445" aria-hidden="true" tabindex="-1"></a><span class="in">      if v ∉ visitados</span></span>
<span id="cb13-446"><a href="#cb13-446" aria-hidden="true" tabindex="-1"></a><span class="in">        operación!(v)</span></span>
<span id="cb13-447"><a href="#cb13-447" aria-hidden="true" tabindex="-1"></a><span class="in">        push!(visitados, v)</span></span>
<span id="cb13-448"><a href="#cb13-448" aria-hidden="true" tabindex="-1"></a><span class="in">        push!(cola, v)</span></span>
<span id="cb13-449"><a href="#cb13-449" aria-hidden="true" tabindex="-1"></a><span class="in">      end</span></span>
<span id="cb13-450"><a href="#cb13-450" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb13-451"><a href="#cb13-451" aria-hidden="true" tabindex="-1"></a><span class="in">  end</span></span>
<span id="cb13-452"><a href="#cb13-452" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb13-453"><a href="#cb13-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-454"><a href="#cb13-454" aria-hidden="true" tabindex="-1"></a><span class="in"># ... código de preparación del grafo</span></span>
<span id="cb13-455"><a href="#cb13-455" aria-hidden="true" tabindex="-1"></a><span class="in">visitados = Set()</span></span>
<span id="cb13-456"><a href="#cb13-456" aria-hidden="true" tabindex="-1"></a><span class="in">BFS((vértices, aristas), vérticeinicial, visitados)</span></span>
<span id="cb13-457"><a href="#cb13-457" aria-hidden="true" tabindex="-1"></a><span class="in"># ... código posterior a la visita BFS</span></span>
<span id="cb13-458"><a href="#cb13-458" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-459"><a href="#cb13-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-460"><a href="#cb13-460" aria-hidden="true" tabindex="-1"></a>El BFS hace uso explícito de la memoria para guardar el orden en que se visitarán los vértices (_cola_); se utiliza un conjunto para marcar vértices ya visitados (_visitados_) con la finalidad de evitar un recorrido infinito.</span>
<span id="cb13-461"><a href="#cb13-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-462"><a href="#cb13-462" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Ejercicios</span></span>
<span id="cb13-463"><a href="#cb13-463" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Implemente un grafo dirigido mediante listas de adyacencia.</span>
<span id="cb13-464"><a href="#cb13-464" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Implemente un grafo no dirigido mediante lista de adyacencia.</span>
<span id="cb13-465"><a href="#cb13-465" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Implemente el algoritmo de recorrido DFS y BFS con implementaciones de grafos.</span>
<span id="cb13-466"><a href="#cb13-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-467"><a href="#cb13-467" aria-hidden="true" tabindex="-1"></a><span class="fu">## Actividades</span></span>
<span id="cb13-468"><a href="#cb13-468" aria-hidden="true" tabindex="-1"></a>Implementar los siguientes algoritmos sobre matrices.</span>
<span id="cb13-469"><a href="#cb13-469" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Multiplicación de matrices</span>
<span id="cb13-470"><a href="#cb13-470" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Eliminación gaussiana / Gauss-Jordan</span>
<span id="cb13-471"><a href="#cb13-471" aria-hidden="true" tabindex="-1"></a>Compare los desempeños de ambos algoritmos contando el número de operaciones y el tiempo real para matrices aleatorias de tamaño <span class="sc">\(</span> n \times n <span class="sc">\)</span> para <span class="sc">\(</span> n= 100, 300, 1000<span class="sc">\)</span>.</span>
<span id="cb13-472"><a href="#cb13-472" aria-hidden="true" tabindex="-1"></a>Maneje de manera separada los datos de conteo de operaciones (multiplicaciones y sumas escalares) y las de tiempo real.</span>
<span id="cb13-473"><a href="#cb13-473" aria-hidden="true" tabindex="-1"></a>Discuta sus resultados experimentales; ¿qué puede concluir?</span>
<span id="cb13-474"><a href="#cb13-474" aria-hidden="true" tabindex="-1"></a>¿Cuál es el impacto de acceder los elementos contiguos en memoria de una matriz?</span>
<span id="cb13-475"><a href="#cb13-475" aria-hidden="true" tabindex="-1"></a>¿Qué cambiaría si utiliza matrices dispersas? ¿Cuáles serían los costos?</span>
<span id="cb13-476"><a href="#cb13-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-477"><a href="#cb13-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-478"><a href="#cb13-478" aria-hidden="true" tabindex="-1"></a>**Entregable**</span>
<span id="cb13-479"><a href="#cb13-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-480"><a href="#cb13-480" aria-hidden="true" tabindex="-1"></a>Su trabajo se entregará en PDF y con el notebook fuente; deberá estar plenamente documentado, con una estructura que permita a un lector interesado entender el problema, sus experimentos y metodología, así como sus conclusiones. Tenga en cuenta que los notebooks pueden alternar celdas de texto y código.</span>
<span id="cb13-481"><a href="#cb13-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-482"><a href="#cb13-482" aria-hidden="true" tabindex="-1"></a>No olvide estructurar su reporte, en particular el reporte debe cubrir los siguientes puntos:</span>
<span id="cb13-483"><a href="#cb13-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-484"><a href="#cb13-484" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Título del reporte, su nombre.</span>
<span id="cb13-485"><a href="#cb13-485" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Introducción.</span>
<span id="cb13-486"><a href="#cb13-486" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Código cercano a la presentación de resultados.</span>
<span id="cb13-487"><a href="#cb13-487" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Figuras y tablas</span>
<span id="cb13-488"><a href="#cb13-488" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Análisis de los resultados</span>
<span id="cb13-489"><a href="#cb13-489" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Conclusión, discusiones de las preguntas</span>
<span id="cb13-490"><a href="#cb13-490" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Lista de referencias. Nota, una lista de referencias que no fueron utilizadas en el cuerpo del texto </span>
<span id="cb13-491"><a href="#cb13-491" aria-hidden="true" tabindex="-1"></a>será interpretada como una lista vacía.</span>
<span id="cb13-492"><a href="#cb13-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-493"><a href="#cb13-493" aria-hidden="true" tabindex="-1"></a><span class="fu">## Bibliografía</span></span>
<span id="cb13-494"><a href="#cb13-494" aria-hidden="true" tabindex="-1"></a>Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2022). Introduction to Algorithms (2nd ed.). MIT Press.</span>
<span id="cb13-495"><a href="#cb13-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-496"><a href="#cb13-496" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Parte III: Cap 10 Elementary Data Structures.</span>
<span id="cb13-497"><a href="#cb13-497" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Parte VI: Cap 22 Elementary Graph Algorithms.</span>
<span id="cb13-498"><a href="#cb13-498" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Parte VII: Cap 28 Matrix Operations.</span>
</code><button title="Copiar al portapapeles" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" class="img-fluid"></a> <br> Esta obra está bajo una <a href="http://creativecommons.org/licenses/by-sa/4.0/">Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional</a></p>
</div>
  </div>
</footer>




</body></html>