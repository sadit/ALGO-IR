<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es-MX" xml:lang="es-MX">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Eric S. Téllez" />
  <title>Algoritmos de intersección de conjuntos con representación de listas ordenadas</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Algoritmos de intersección de conjuntos con representación de listas ordenadas</h1>
<p class="author">Eric S. Téllez</p>
</header>
<h2 id="objetivo">Objetivo</h2>
<p>Se implementarán y compararán algoritmos de intersección de conjuntos representados como listas ordenadas, utilizando una variedad de algoritmos de búsqueda que dan diferentes propiedades a los algoritmos de intersección.</p>
<h2 id="introducción">Introducción</h2>
<p>En este tema se conocerán, implementarán y compararán algoritmos de intersección de listas ordenadas. El cálculo de la intersección es un proceso costoso en una máquina de búsqueda, sin embargo, es un procedimiento esencial cuando se trabaja con grandes colecciones de datos.</p>
<p>El índice invertido tal y como lo hemos creado, es capaz de manejar una cantidad razonablemente grande de documentos. Para asegurarnos del escalamiento con la cantidad de documentos, es necesario utilizar algoritmos de intersección que sean eficientes. Entonces, dadas las listas ordenadas <span class="math inline">\(L_1, \cdots, L_k\)</span> (e.g, correspondientes a las listas de posteo en un índice invertido), tomará dichas listas y producirá <span class="math inline">\(L^* = \bigcap_i L_i\)</span>, esto es, si <span class="math inline">\(u\in L^*\)</span> entonces <span class="math inline">\(u \in L_i\)</span> para <span class="math inline">\(1 \leq i \leq k\)</span>.</p>
<p>Existen varios algoritmos prominentes para llevar a cabo esta operación. Uno de los trabajos seminales viene de Hwang &amp; Lin, en su algoritmo de <em>merge</em> entre dos conjuntos <span class="citation" data-cites="HL1971">[@HL1971]</span>. En este trabajo se replantea el costo como encontrar los <em>puntos</em> de unión entre ambos conjuntos, esto se traslada de manera inmediata al problema de intersección. El problema correspondiente para intersectar dos conjuntos cualesquiera representados como conjuntos ordenados es entonces <span class="math inline">\(\log{{n+m} \choose m}\)</span>, que usando la aproximación de Stirling se puede reescribir como <span class="math display">\[n \log \frac{n}{m} + (n-m)\log \frac{n}{n-m},\]</span> donde <span class="math inline">\(n\)</span> y <span class="math inline">\(m\)</span> corresponden a al número de elementos en cada conjunto.</p>
<p>Un algoritmo <em>naïve</em> para realizar la intersección, puede ser buscar todos los elementos del conjunto más pequeño en el más grande. Si para la búsqueda se utiliza <em>búsqueda binaria</em>, tenemos un costo de <span class="math inline">\(m \log n\)</span>.</p>
<p>Esta simple idea puede ser explotada y mejorada para obtener costos más bajos, por ejemplo, si en lugar de buscar sobre la lista más grande directamente, esta se divide en bloques de tamaño <span class="math inline">\(m\)</span> para encontrar el bloque que contiene cada elemento (recuerde que el arreglo esta ordenado), para después buscar dentro del bloque. Haciendo esto, el costo se convierte en <span class="math display">\[ m \log \frac{n}{m} + m \log m\]</span> cuyo costo se ajusta mejor al costo del problema. Este es el algoritmo propuesto, a groso modo, en <span class="citation" data-cites="HL1971">[@HL1971]</span>.</p>
<p>Cuando <span class="math inline">\(k&gt;2\)</span>, la intersección se puede realizar usando las <span class="math inline">\(k\)</span> listas a la vez, o se puede hace por pares. Se puede observar que la intersección de dos conjuntos da como resultado un conjunto igual o más pequeño que el más pequeño de los conjuntos intersectados. Adicionalmente, los conjuntos pequeños son “más faciles” de intersectar con un algoritmo <em>na&quot;ive</em>. Por tanto, una estrategía que funciona bien en el peor caso es intersectar los 2 arreglos más pequeños cada vez. Esta una idea muy popular llamada <em>Small vs Small (SvS)</em>.</p>
<p>Existe otra familia de algoritmos, basados en búsquedas adaptativas que pueden llegar a mejorar el desempeño bajo cierto tipo de entradas. En <span class="citation" data-cites="DLOPM2001">[@DLOPM2001]</span>, <span class="citation" data-cites="BLOL2006">[@BLOL2006]</span>, <span class="citation" data-cites="BLOLS2010">[@BLOLS2010]</span>, y <span class="citation" data-cites="BYS2005">[@BYS2005]</span> se muestran comparaciones experimentales de diversos algoritmos de intersección, entre ellos adaptables, que utilizan de manera creativa algoritmos de búsqueda adaptables para aprovechar instancias simples. Estos estudios se basan en contribuciones teoricas de los mismos autores <span class="citation" data-cites="DLOM2000">[@DLOM2000]</span>, <span class="citation" data-cites="DLOPM2001">[@DLOPM2001]</span>, <span class="citation" data-cites="BK2002">[@BK2002]</span>, <span class="citation" data-cites="BY2004">[@BY2004]</span>.</p>
<h3 id="recursos-audio-visuales-de-la-unidad">Recursos audio-visuales de la unidad</h3>
<p>Parte 1: Algoritmos de intersección (y unión) de listas ordenadas <iframe width="560" height="315" src="https://www.youtube.com/embed/aDYO39yi-4g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<p>Parte 2: Algoritmos de intersección y algunas aplicaciones <iframe width="560" height="315" src="https://www.youtube.com/embed/oOd5LoVJcAs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id="actividades">Actividades</h2>
<p>Implementación y comparación de diferentes algoritmos de intersección de conjuntos.</p>
<p>Lea cuidadosamente las instrucciones y desarrolle las actividades. Entregue el reporte correspondiente en tiempo.</p>
<h3 id="actividad-0-sin-entrega">Actividad 0 [Sin entrega]</h3>
<ol type="1">
<li>Lea y comprenda los artículos relacionados (listados en la introducción).</li>
</ol>
<h3 id="actividad-1-con-reporte">Actividad 1 [Con reporte]</h3>
<ol type="1">
<li>Cargue el archivo <code>listas-posteo-100.json</code> del tema 3. Si lo desea, puede usar listas de posteo generadas con otros conjuntos de datos, usando los scripts de las unidades pasadas. Si es necesario, repase los temas anteriores para recordar la naturaleza y propiedades de las listas.</li>
</ol>
<ul>
<li>Sea <span class="math inline">\(P^{(2)}\)</span> el conjunto de todos los posibles pares de listas entre las 100 listas de posteo. Seleccione de manera aleatoria <span class="math inline">\(A \subset P^{(2)}\)</span>, <span class="math inline">\(|A| = 1000\)</span>.</li>
<li>Sea <span class="math inline">\(P^{(3)}\)</span> el conjunto de todas las posibles combinaciones de tres listas de posteo entre las 100 listas disponibles, Seleccione de manera aleatoria <span class="math inline">\(B \subset P^{(3)}\)</span>, <span class="math inline">\(|B| = 1000\)</span>.</li>
<li>Sea <span class="math inline">\(P^{(4)}\)</span> el conjunto de todas las posibles combinaciones de cuatro listas de posteo entre las 100 listas disponibles. Seleccione de manera aleatoria <span class="math inline">\(C \subset P^{(4)}\)</span>, <span class="math inline">\(|C| = 1000\)</span>.</li>
</ul>
<ol start="2" type="1">
<li><p>Implemente los algoritmos de las secciones 3.1 <em>Melding Algorithms</em> y 3.2 <em>Search algorithms</em> (en especial 3.2.1 y 3.2.2) de <span class="citation" data-cites="BLOLS2010">[@BLOLS2010]</span>.</p></li>
<li>Realice y reporte los siguientes experimentos:</li>
</ol>
<ul>
<li>Intersecte cada par de listas <span class="math inline">\(a, b \in A\)</span>, y reporte de manera acumulada el tiempo en segundos y el número de comparaciones.</li>
<li>Intersecte cada tripleta de listas <span class="math inline">\(a, b, c \in B\)</span>, y reporte de manera acumulada el tiempo en segundos y el número de comparaciones.</li>
<li>Intersecte cada tetrapleta de listas <span class="math inline">\(a, b, c, d \in C\)</span>, y reporte de manera acumulada el tiempo en segundos y el número de comparaciones.</li>
<li>Cree una figura <code>boxplot</code> que describa el tiempo en segundos para los tres experimentos.</li>
<li>Cree una figura <code>boxplot</code> que describa el número de comparaciones para los tres experimentos.</li>
<li>Cree una figura <code>boxplot</code> que describa las longitudes de las intersecciones resultantes para <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>.</li>
</ul>
<h3 id="entregable">Entregable:</h3>
<p>El reporte deberá ser en formato notebook y el PDF del mismo notebook. El notebook debe contener las implementaciones. Recuerde que el reporte debe llevar claramente su nombre, debe incluir una introducción, la explicación de los métodos usados, la explicación de los experimentos realizados, la discusión de los resultados, y finalizar con sus observaciones y conclusiones.</p>
<p><em>Nota sobre la generación del PDF</em>: Jupyter no genera el PDF directamente, a menos que se tengan instalados una gran cantidad de paquetes, entre ellos una instalación completa de LaTeX. En su lugar, para generar el PDF en Jupyter primero guarde el notebook como HTML y luego genere el PDF renderizando e imprimiendo el HTML con su navegador. En lugar de imprimir, seleccione guardar como PDF.</p>
<h1 id="referencias">Referencias</h1>
<ul>
<li><span class="citation" data-cites="BLOLS2010">[@BLOLS2010]</span>: Jérémy Barbay, Alejandro López-Ortiz, Tyler Lu, and Alejandro Salinger. 2010. An experimental investigation of set intersection algorithms for text searching. J. Exp. Algorithmics 14, Article 7 (January 2010), 54 pages. DOI: https://doi.org/10.1145/1498698.1564507 (https://doi.org/10.1145/1498698.1564507)</li>
<li><span class="citation" data-cites="BLOL2006">[@BLOL2006]</span>: Barbay J., López-Ortiz A., Lu T. (2006) Faster Adaptive Set Intersections for Text Searching. In: Àlvarez C., Serna M. (eds) Experimental Algorithms. WEA 2006. Lecture Notes in Computer Science, vol 4007. Springer, Berlin, Heidelberg</li>
<li><span class="citation" data-cites="BYS2005">[@BYS2005]</span>: Baeza-Yates R., Salinger A. (2005) Experimental Analysis of a Fast Intersection Algorithm for Sorted Sequences. In: Consens M., Navarro G. (eds) String Processing and Information Retrieval. SPIRE 2005. Lecture Notes in Computer Science, vol 3772. Springer, Berlin, Heidelberg</li>
<li><span class="citation" data-cites="BY2004">[@BY2004]</span>: Baeza-Yates R. (2004) A Fast Set Intersection Algorithm for Sorted Sequences. In: Sahinalp S.C., Muthukrishnan S., Dogrusoz U. (eds) Combinatorial Pattern Matching. CPM 2004. Lecture Notes in Computer Science, vol 3109. Springer, Berlin, Heidelberg</li>
<li><span class="citation" data-cites="BK2002">[@BK2002]</span>: Jérémy Barbay and Claire Kenyon. 2002. Adaptive intersection and t-threshold problems. In Proceedings of the thirteenth annual ACM-SIAM symposium on Discrete algorithms (SODA ’02). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 390-399.</li>
<li><span class="citation" data-cites="DLOPM2001">[@DLOPM2001]</span> Erik D. Demaine, Alejandro López-Ortiz, and J. Ian Munro. 2001. Experiments on Adaptive Set Intersections for Text Retrieval Systems. In Revised Papers from the Third International Workshop on Algorithm Engineering and Experimentation (ALENEX ’01), Adam L. Buchsbaum and Jack Snoeyink (Eds.). Springer-Verlag, London, UK, UK, 91-104.</li>
<li><span class="citation" data-cites="DLOM2000">[@DLOM2000]</span>: Erik D. Demaine, Alejandro López-Ortiz, and J. Ian Munro. 2000. Adaptive set intersections, unions, and differences. In Proceedings of the eleventh annual ACM-SIAM symposium on Discrete algorithms (SODA ’00). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 743-752</li>
<li><span class="citation" data-cites="HL1971">[@HL1971]</span> Hwang, F. K., &amp; Lin, S. (1971). Optimal merging of 2 elements with n elements. Acta Informatica, 1(2), 145-158.</li>
</ul>
</body>
</html>
