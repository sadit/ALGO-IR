<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es-MX" xml:lang="es-MX">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algoritmos de ordenamiento</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Algoritmos de ordenamiento</h1>
</header>
<h2 id="objetivo">Objetivo</h2>
<p>Implementar, utilizar y caracterizar el desempeño de algoritmos peor caso y adaptativos para ordenamiento de arreglos.</p>
<h1 id="introducción">Introducción</h1>
<p>En este tema se aborda el ordenamiento basado en comparación, esto es, existe una función <span class="math inline">\(\leq\)</span>. Recuerde que se cumplen las siguientes propiedades:</p>
<ul>
<li>si <span class="math inline">\(u \leq v\)</span> y <span class="math inline">\(v \leq w\)</span> entonces <span class="math inline">\(u \leq w\)</span> (transitividad)</li>
<li>tricotomia:
<ul>
<li>si <span class="math inline">\(u \leq v\)</span> y <span class="math inline">\(v \leq u\)</span> entonces <span class="math inline">\(u = v\)</span> (antisimetria)</li>
<li>en otro caso, <span class="math inline">\(u \leq v\)</span> o <span class="math inline">\(v \leq u\)</span></li>
</ul></li>
</ul>
<p>La idea es entonces, dado un arreglo <span class="math inline">\(A[1, n] = a_1, a_2, \cdots, a_n\)</span> obtener una permutación <span class="math inline">\(\pi\)</span> tal que <span class="math inline">\(a_{\pi(1)} \leq a_{\pi(2)} \leq \cdots \leq a_{\pi(n)}\)</span>. Si se asegura que en el arreglo ordenado se preserven el orden original de los indices cuando <span class="math inline">\(u = v\)</span>, entonces se tiene un ordenamiento estable.</p>
<p>En terminos prácticos, la idea es reorganizar <span class="math inline">\(A\)</span>, mediante el cálculo implicito de <span class="math inline">\(\pi\)</span>, de tal forma que después de terminar el proceso de ordenamiento se obtenga que <span class="math inline">\(A\)</span> esta ordenado, i.e., <span class="math inline">\(a_i \leq a_{i+1}\)</span>. En sistemas reales, el alojar memoria para realizar el ordenamiento implica costos adicionales, y es por esto que es común modificar directamente <span class="math inline">\(A\)</span>. Utilizar <span class="math inline">\(\pi\)</span> solo es necesario cuando no es posible modificar <span class="math inline">\(A\)</span>. También es muy común utilizar datos <em>satélite</em> asociados con los valores a comparar, de esta manera es posible ordenar diversos tipos de datos.</p>
<p>En esta unidad se tendrá atención especial a aquellos algoritmos oportunistas que son capaces de obtener ventaja en instancias sencillas.</p>
<h2 id="lecturas">Lecturas</h2>
<p>Las lecturas de este tema corresponden al capítulo 5 de <span class="citation" data-cites="Knuth98">[@Knuth98]</span>, en específico 5.2 <em>Internal sorting</em>. También se recomienda leer y comprender la parte II de <span class="citation" data-cites="Cormen01">[@Cormen01]</span>, que corresponde a <em>Sorting and order statistics</em>, en partícular Cap. 6 y 7, así como el Cap. 8.1. El artículo de wikipedia <span class="citation" data-cites="SortWiki">[@SortWiki]</span> también puede ser consultado con la idea de encontrar una explicación rápida de los algoritmos.</p>
<p>En la práctica, pocos algoritmos son mejores que <em>quicksort</em>. En <span class="citation" data-cites="Loeser74">[@Loeser74]</span> se detalla una serie de experimentos donde se compara quicksort contra otros algoritmos relacionados; por lo que es una lectura recomendable.</p>
<p>La parte adaptable, esto es para algoritmos <em>oportunistas</em> que toman ventaja de instancias simples, esta cubierta por el artículo <span class="citation" data-cites="Estivill90">[@Estivill90]</span>. En especial, es muy necesario comprender las secciones 1.1 y 1.2, el resto del artículo debe ser leído aunque no invierta mucho tiempo en comprender las pruebas expuestas si no le son claras. En especial, en las secciones indicadas se establecen las medidas de desorden contra las cuales se mide la complejidad. En <span class="citation" data-cites="Cook80">[@Cook80]</span> realiza una comparación del desempeño de varios algoritmos para ordenamiento de listas casi ordenadas, esto es, en cierto sentido donde los algoritmos adaptables tienen sentido. Este artículo es anterior a <span class="citation" data-cites="Estivill90">[@Estivill90]</span> pero tiene experimentos que simplifican el entendimiento de los temas.</p>
<h2 id="material-audio-visual-sobre-algoritmos-de-ordenamiento">Material audio-visual sobre algoritmos de ordenamiento</h2>
<iframe width="560" height="315" src="https://www.youtube.com/embed/F9jh0IJsg1w" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
<h1 id="actividades">Actividades</h1>
<h2 id="actividad-0-sin-entrega">Actividad 0 [sin entrega]</h2>
<p>Realizar las actividades de lectura y comprensión. - De preferencia realice los ejercicios de los capítulos y secciones relacionadas.</p>
<h2 id="actividad-1-con-reporte">Actividad 1 [con reporte]</h2>
<ol type="1">
<li><p>Implemente los algoritmos, bubble-sort, insertion-sort, merge-sort y quick-sort. Explíquelos.</p></li>
<li><p>Carge los archivos <code>unsorted-list-p=*.json</code>, los cuales corresponden al archivo <code>listas-posteo-100.json</code> perturbado en cierta proporción: <span class="math inline">\(p=0.01, 0.03, 0.10, 0.30\)</span>.</p></li>
</ol>
<ul>
<li>En el notebook <code>perturbar-listas.ipynb</code> se encuentran el procedimiento que se utilizó para la perturbación.</li>
<li>Nota: puede usar sus propias listas de posteo perturbadas para la actividad siempre y cuando sean comparables en tamaño.</li>
<li>Recuerde que la unidad anterior se dió un notebook con el código para crear índices invertidos y las listas de posteo.</li>
</ul>
<ol start="3" type="1">
<li>Para cada archivo de listas desordenadas con cierta perturbación, realice el siguiente experimento:</li>
</ol>
<ul>
<li>Ordene con los algoritmos implementados para cada valor de <span class="math inline">\(p\)</span> con cada.</li>
<li>Grafique el número de comparaciones necesarias para ordenar las 100 listas.</li>
<li>Grafique el tiempo en segundos necesario para ordenar las 100 listas.</li>
</ul>
<ol start="4" type="1">
<li>Muestre de manera agregada la información de todos los experimentos en una tabla.</li>
</ol>
<ul>
<li>Nota 1: Recuerde copiar o cargar cada lista para evitar ordenar conjuntos completamente ordenados.</li>
<li>Nota 2: Repita varias veces las operaciones de ordenamiento, esto es muy importante sobre para la estabilidad de los tiempos en segundos (vea Nota 1).</li>
<li>Nota 3: En las implementaciones podrá usar cualquier comparación que le convenga, i.e., <span class="math inline">\(&lt;, \leq\)</span>, <span class="math inline">\(cmp \rightarrow \{-1, 0, 1\}\)</span>, etc.</li>
<li>Nota 4: Tome en cuenta que varios lenguajes de programación (Python y Julia) hacen copias de los arreglos cuando se usa <em>slicing</em>, i.e., <code>arr[i:j]</code> creará un nuevo arreglo y eso implica costos adicionales innecesarios:
<ul>
<li>Python: use índices o arreglos de <code>numpy</code>.</li>
<li>Julia: use índices o vistas, i.e., <code>@view</code>.</li>
</ul></li>
</ul>
<h3 id="entregable">Entregable</h3>
<p>El reporte deberá ser en formato notebook y el PDF del mismo notebook. El notebook debe contener las implementaciones de los algoritmos solicitados. Recuerde que el reporte debe llevar claramente su nombre, debe incluir una introducción, la explicación de los experimentos realizados, las observaciones, conclusiones y bibliografía.</p>
<p>Para generar el PDF primero guarde el notebook como HTML y luego genere el PDF renderizando e imprimiendo el HTML con su navegador. En lugar de imprimir, seleccione guardar como PDF.</p>
<h2 id="referencias">Referencias</h2>
<ul>
<li><span class="citation" data-cites="Knuth98">[@Knuth98]</span>: Donald E. Knuth. 1998. The Art of Computer Programming, Volume 3: (2nd Ed.) Sorting and Searching. Addison Wesley Longman Publishing Co., Inc., Redwood City, CA, USA.</li>
<li><span class="citation" data-cites="Cormen01">[@Cormen01]</span>: Cormen et. al. Introduction to algorithms. MIT press 2001. 2nd edition.</li>
<li><span class="citation" data-cites="Sedgewick98">[@Sedgewick98]</span>: Robert Sedgewick. Algorithms in C++ - Parts 1-4: Fundamentals, Data Structures, Sorting, Searching. Addison-Wesley-Longman, 1998. 3rd Edition.</li>
<li><span class="citation" data-cites="Estivill92">[@Estivill92]</span> Vladimir Estivill-Castro, Deric Wood. A Survey of Adaptive Sorting Algorithms. ACM Computmg Surveys, Vol. 24, No. 4, December 1992.</li>
<li><span class="citation" data-cites="Cook80">[@Cook80]</span> Curtis R. Cook, Do Jin Kim. Best Sorting Algorithm for Nearly Sorted Lists. Commun. ACM. Vol 23, number 11.</li>
<li><span class="citation" data-cites="Loeser74">[@Loeser74]</span>: Loeser, Rudolf. 1974. Some Performance Tests of “Quicksort” and Descendants. Commun. ACM. Vol 17, number 3. pp 143-152. http://doi.acm.org/10.1145/360860.360870}.</li>
<li><span class="citation" data-cites="SortWiki">[@SortWiki]</span>: https://en.wikipedia.org/wiki/Sorting_algorithm</li>
</ul>
</body>
</html>
