<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es-MX" xml:lang="es-MX">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Eric S. Téllez" />
  <title>Búsqueda en cadenas de texto</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Búsqueda en cadenas de texto</h1>
<p class="author">Eric S. Téllez</p>
</header>
<h2 id="objetivo">Objetivo</h2>
<p>Se introducirá implementarán y compararán algoritmos de búsqueda de patrones en cadenas de símbolos.</p>
<h2 id="introducción">Introducción</h2>
<p>La presente unidad esta dedicada a los algoritmos de búsqueda de patrones en cadenas de símbolos. Antes de comenzar vamos a definir el problema:</p>
<p>Dado un alfabeto de simbolos <span class="math inline">\(\Sigma = \{a_1, a_2, \cdots, a_\sigma \}\)</span> una cadena de tamaño <span class="math inline">\(T[1,n]\)</span> esta definida como la concatenación de <span class="math inline">\(n\)</span> símbolos, i.e., <span class="math inline">\(T \in \Sigma^n\)</span>. Esto es, si el alfabeto es binario, <span class="math inline">\(\Sigma = \{0, 1\}\)</span>, para <span class="math inline">\(n=3\)</span>, <span class="math inline">\(T\)</span> podría ser cualquiera de las siguientes cadenas de bits: <span class="math inline">\(\{ 000, 001, 010, 011, 100, 101, 110, 111 \}\)</span>.</p>
<p>Por ejemplo, la cadena <span class="math inline">\(T=\texttt{ABRACADABRA}\)</span> esta descrita por el alfabeto <span class="math inline">\(\Sigma = \{A,B,C,D,R\}\)</span>, y podemos acceder a cada uno de los simbolos mediante un subíndice, e.g., <span class="math inline">\(T_1=\texttt{A}, T_2=\texttt{B}, T_3=\texttt{R}\)</span>, etc. También se puede acceder a subcadenas haciendo uso de la notación <span class="math inline">\(T_{i:j}\)</span>, la cual obtendría una subcadena de tamaño <span class="math inline">\(j-i+1\)</span> (concatenando los simbolos de que van de <span class="math inline">\(i\)</span> a <span class="math inline">\(j\)</span> en <span class="math inline">\(T\)</span>). Si <span class="math inline">\(j &lt; i\)</span> entonces se accede a la cadena vacia <span class="math inline">\(\epsilon\)</span>.</p>
<p>Es posible concatenar cadenas para obtener nuevas cadenas, por ejemplo, <span class="math inline">\(A[1,11]=\texttt{ABRACADABRA}\)</span> y <span class="math inline">\(B[1,11] = \texttt{ARBADACARBA}\)</span>, ambas vienen del mismo alfabeto, y pueden ser concatenadas <span class="math inline">\(C[1,22] = A B = \texttt{ABRACADABRAARBADACARBA}\)</span>. De la misma forma es posible crearlas a partir de concatener cadenas y símbolos.</p>
<p>Ahora, hay tres tipos de subcadenas, según su aparición dentro de otra cadena. Sean <span class="math inline">\(A, B, C\)</span> tres cadenas de símbolos; <span class="math inline">\(D = ABC\)</span> sería la concatenación de las tres cadenas, entonces a <span class="math inline">\(A\)</span> se le llama <em>prefijo</em> de <span class="math inline">\(D\)</span>, <span class="math inline">\(C\)</span> es llamado <em>sufijo</em> de <span class="math inline">\(D\)</span> y <span class="math inline">\(B\)</span> sería un <em>factor</em> de <span class="math inline">\(D\)</span>.</p>
<h3 id="el-problema-de-búsqueda-en-cadenas">El problema de búsqueda en cadenas</h3>
<p>Dada una cadena larga <span class="math inline">\(T[1,n]\)</span> y una cadena corta <span class="math inline">\(P[1,m]\)</span>, llamada <em>patrón</em>, el problema consiste en encontrar todas las ocurrencias de <span class="math inline">\(P\)</span> en <span class="math inline">\(T\)</span>, esto es, todos los puntos donde <span class="math inline">\(P\)</span> sea una subcadena en <span class="math inline">\(T\)</span>. Esta operación es llamada <em>búsqueda</em>. Para esto se pueden tener dos variantes típicas:</p>
<ol type="1">
<li><span class="math inline">\(T\)</span> es estático o cambia muy poco, por lo que se puede crear una estructura sobre <span class="math inline">\(T\)</span> para resolver las búsquedas.</li>
<li><span class="math inline">\(T\)</span> varia frecuentemente, o no esta acotado, por lo que la estrategía es apoyarse en una estructura sobre <span class="math inline">\(P\)</span> para resolver consultas de manera eficiente.</li>
</ol>
<p>Existen variaciones de ambos problemas, dónde es posible tener en consideración múltiples patrones, clases de caracteres, e.g., dígitos numéricos, caracteres alfabeticos, puntuaciones, o en general conjuntos de símbolos que se deseen agrupar. Así como soportar cualquier tipo de expresión regular. [Cita]</p>
<h3 id="esquemas-de-búsqueda">Esquemas de búsqueda</h3>
<p>Para el primer problema, se puede crear algún índice tipo índice invertido si el texto ser divido en pequeñas piezas o tokens, e.g., palabras y símbolos de puntuación en texto escrito en lenguaje natural (y con pocas propiedades aglutinantes). De otra forma requerirá índices similares a árboles de sufijos o arreglos de sufijos. Estas últimas estructuras se basan en crear un árbol que contenga todos los sufijos (mediante punteros e índices al texto original). (Ver video)</p>
<p>Para el segundo problema, la idea general es revisar la cadena <span class="math inline">\(T\)</span> en ventanas de tamaño <span class="math inline">\(m\)</span> y calcular una estructura sobre <span class="math inline">\(P\)</span> tal que usando la información de la ventana siendo analizada sea posible avanzar la ventana de manera segura (sin perder información) y rápida (moverla lo más posible). Para esto se usan los prefijos, sufijos y factores de <span class="math inline">\(P\)</span> y la ventana en cuestión.</p>
<p>Durante la actividad nos enfocaremos en el segundo problema. Dicho esto, nos remitiremos a una estructura conocida por muchos que es el <em>autómata finito</em>.</p>
<h3 id="autómatas-finitos">Autómatas Finitos</h3>
<p>Para nuestros propósitos, un autómata finito es una estructura discreta formada por una serie de estados <span class="math inline">\(Q\)</span>, entre los cuales hay dos tipos de estados especiales. El estado inicial <span class="math inline">\(I \in Q\)</span> y los estados terminales <span class="math inline">\(F \subseteq Q\)</span>. Entre cada par de estados puede existir una transición, etiquetada por elementos de un alfabeto <span class="math inline">\(\Sigma \cup \{\epsilon\}\)</span>; estas transiciones son descritas de manera precisa mediante una función especial llamada función de transición <span class="math inline">\(\mathcal{D}(q, \alpha) = \{q_1, \cdots, q_k\}\)</span> esto es, asocia estados <span class="math inline">\(Q\)</span> por medio de un símbolos <span class="math inline">\(\alpha \in \Sigma \cup \{\epsilon\}\)</span>. Un autómata es descrito por estas partes como <span class="math inline">\(A = (Q, \Sigma, I, F, \mathcal{D})\)</span>.</p>
<p>Dependiendo de la función de transición, podemos distinguir dos tipos de autómatas, equivalentes en cuanto a su capacidad de expresión de cadenas, pero muy diferentes en cuanto a la expresividad gráfica. El autómata determinista es aquel donde <span class="math inline">\(\mathcal{D}\)</span> asocia pares de estados, mientras que el no determinista puede asociar diferentes estados usando el mismo cáracter de transición, <span class="math inline">\(\mathcal{D}: Q \times \Sigma \rightarrow \{q_1,\cdots,q_k\}\)</span> para <span class="math inline">\(k&gt;1\)</span>, así como también cuando hay alguna transición definida por la cadena vacia, i.e., <span class="math inline">\(\mathcal{D}(q, \epsilon)\)</span>.</p>
<h3 id="recursos-audio-visuales-de-la-unidad">Recursos audio-visuales de la unidad</h3>
<p>Parte 1: Algoritmos de intersección (y unión) de listas ordenadas <iframe width="560" height="315" src="https://www.youtube.com/embed/aDYO39yi-4g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<p>Parte 2: Algoritmos de intersección y algunas aplicaciones <iframe width="560" height="315" src="https://www.youtube.com/embed/oOd5LoVJcAs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id="actividades">Actividades</h2>
<p>Implementación y comparación de diferentes algoritmos de intersección de conjuntos.</p>
<p>Lea cuidadosamente las instrucciones y desarrolle las actividades. Entregue el reporte correspondiente en tiempo.</p>
<h3 id="actividad-0-sin-entrega">Actividad 0 [Sin entrega]</h3>
<ol type="1">
<li>Lea y comprenda los artículos relacionados (listados en la introducción).</li>
</ol>
<h3 id="actividad-1-con-reporte">Actividad 1 [Con reporte]</h3>
<ol type="1">
<li>Cargue el archivo <code>listas-posteo-100.json</code> del tema 3. Si lo desea, puede usar listas de posteo generadas con otros conjuntos de datos, usando los scripts de las unidades pasadas. Si es necesario, repase los temas anteriores para recordar la naturaleza y propiedades de las listas.</li>
</ol>
<ul>
<li>Sea <span class="math inline">\(P^{(2)}\)</span> el conjunto de todos los posibles pares de listas entre las 100 listas de posteo. Seleccione de manera aleatoria <span class="math inline">\(A \subset P^{(2)}\)</span>, <span class="math inline">\(|A| = 1000\)</span>.</li>
<li>Sea <span class="math inline">\(P^{(3)}\)</span> el conjunto de todas las posibles combinaciones de tres listas de posteo entre las 100 listas disponibles, Seleccione de manera aleatoria <span class="math inline">\(B \subset P^{(3)}\)</span>, <span class="math inline">\(|B| = 1000\)</span>.</li>
<li>Sea <span class="math inline">\(P^{(4)}\)</span> el conjunto de todas las posibles combinaciones de cuatro listas de posteo entre las 100 listas disponibles. Seleccione de manera aleatoria <span class="math inline">\(C \subset P^{(4)}\)</span>, <span class="math inline">\(|C| = 1000\)</span>.</li>
</ul>
<ol start="2" type="1">
<li><p>Implemente los algoritmos de las secciones 3.1 <em>Melding Algorithms</em> y 3.2 <em>Search algorithms</em> (en especial 3.2.1 y 3.2.2) de <span class="citation" data-cites="BLOLS2010">[@BLOLS2010]</span>.</p></li>
<li><p>Realice y reporte los siguientes experimentos:</p></li>
</ol>
<ul>
<li>Intersecte cada par de listas <span class="math inline">\(a, b \in A\)</span>, y reporte de manera acumulada el tiempo en segundos y el número de comparaciones.</li>
<li>Intersecte cada tripleta de listas <span class="math inline">\(a, b, c \in B\)</span>, y reporte de manera acumulada el tiempo en segundos y el número de comparaciones.</li>
<li>Intersecte cada tetrapleta de listas <span class="math inline">\(a, b, c, d \in C\)</span>, y reporte de manera acumulada el tiempo en segundos y el número de comparaciones.</li>
<li>Cree una figura <code>boxplot</code> que describa el tiempo en segundos para los tres experimentos.</li>
<li>Cree una figura <code>boxplot</code> que describa el número de comparaciones para los tres experimentos.</li>
<li>Cree una figura <code>boxplot</code> que describa las longitudes de las intersecciones resultantes para <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>.</li>
</ul>
<h3 id="entregable">Entregable:</h3>
<p>El reporte deberá ser en formato notebook y el PDF del mismo notebook. El notebook debe contener las implementaciones. Recuerde que el reporte debe llevar claramente su nombre, debe incluir una introducción, la explicación de los métodos usados, la explicación de los experimentos realizados, la discusión de los resultados, y finalizar con sus observaciones y conclusiones.</p>
<p><em>Nota sobre la generación del PDF</em>: Jupyter no genera el PDF directamente, a menos que se tengan instalados una gran cantidad de paquetes, entre ellos una instalación completa de LaTeX. En su lugar, para generar el PDF en Jupyter primero guarde el notebook como HTML y luego genere el PDF renderizando e imprimiendo el HTML con su navegador. En lugar de imprimir, seleccione guardar como PDF.</p>
<h1 id="referencias">Referencias</h1>
<ul>
<li><span class="citation" data-cites="BLOLS2010">[@BLOLS2010]</span>: Jérémy Barbay, Alejandro López-Ortiz, Tyler Lu, and Alejandro Salinger. 2010. An experimental investigation of set intersection algorithms for text searching. J. Exp. Algorithmics 14, Article 7 (January 2010), 54 pages. DOI: https://doi.org/10.1145/1498698.1564507 (https://doi.org/10.1145/1498698.1564507)</li>
<li><span class="citation" data-cites="BLOL2006">[@BLOL2006]</span>: Barbay J., López-Ortiz A., Lu T. (2006) Faster Adaptive Set Intersections for Text Searching. In: Àlvarez C., Serna M. (eds) Experimental Algorithms. WEA 2006. Lecture Notes in Computer Science, vol 4007. Springer, Berlin, Heidelberg</li>
<li><span class="citation" data-cites="BYS2005">[@BYS2005]</span>: Baeza-Yates R., Salinger A. (2005) Experimental Analysis of a Fast Intersection Algorithm for Sorted Sequences. In: Consens M., Navarro G. (eds) String Processing and Information Retrieval. SPIRE 2005. Lecture Notes in Computer Science, vol 3772. Springer, Berlin, Heidelberg</li>
<li><span class="citation" data-cites="BY2004">[@BY2004]</span>: Baeza-Yates R. (2004) A Fast Set Intersection Algorithm for Sorted Sequences. In: Sahinalp S.C., Muthukrishnan S., Dogrusoz U. (eds) Combinatorial Pattern Matching. CPM 2004. Lecture Notes in Computer Science, vol 3109. Springer, Berlin, Heidelberg</li>
<li><span class="citation" data-cites="BK2002">[@BK2002]</span>: Jérémy Barbay and Claire Kenyon. 2002. Adaptive intersection and t-threshold problems. In Proceedings of the thirteenth annual ACM-SIAM symposium on Discrete algorithms (SODA ’02). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 390-399.</li>
<li><span class="citation" data-cites="DLOPM2001">[@DLOPM2001]</span> Erik D. Demaine, Alejandro López-Ortiz, and J. Ian Munro. 2001. Experiments on Adaptive Set Intersections for Text Retrieval Systems. In Revised Papers from the Third International Workshop on Algorithm Engineering and Experimentation (ALENEX ’01), Adam L. Buchsbaum and Jack Snoeyink (Eds.). Springer-Verlag, London, UK, UK, 91-104.</li>
<li><span class="citation" data-cites="DLOM2000">[@DLOM2000]</span>: Erik D. Demaine, Alejandro López-Ortiz, and J. Ian Munro. 2000. Adaptive set intersections, unions, and differences. In Proceedings of the eleventh annual ACM-SIAM symposium on Discrete algorithms (SODA ’00). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 743-752</li>
<li><span class="citation" data-cites="HL1971">[@HL1971]</span> Hwang, F. K., &amp; Lin, S. (1971). Optimal merging of 2 elements with n elements. Acta Informatica, 1(2), 145-158.</li>
</ul>
</body>
</html>
